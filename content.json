{"meta":{"title":"冯佳欣的博客","subtitle":"滴水穿石","description":"记录一点一滴","author":"冯佳欣","url":"https://fengjiaxin.github.io"},"pages":[{"title":"标签","date":"2017-01-05T10:17:16.000Z","updated":"2017-01-05T11:39:14.780Z","comments":true,"path":"tags/index.html","permalink":"https://fengjiaxin.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-01-05T10:16:57.000Z","updated":"2017-01-05T11:38:57.999Z","comments":true,"path":"categories/index.html","permalink":"https://fengjiaxin.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"TreeMap源码学习(三)","slug":"TreeMap源码学习 (三) ","date":"2017-02-26T09:46:58.000Z","updated":"2017-02-26T12:17:57.536Z","comments":true,"path":"2017/02/26/TreeMap源码学习 (三) /","link":"","permalink":"https://fengjiaxin.github.io/2017/02/26/TreeMap源码学习 (三) /","excerpt":"","text":"在将红黑树增加删除查询这几个难点解决掉后，就剩下一些基本的知识了，就今天进行整理。 TreeMap基本知识TreeMap定义public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fast的；关于迭代器的fail-fast机制将会另起一篇文章进行讲解。 TreeMap属性// 比较器 private final Comparator&lt;? super K&gt; comparator; // 红黑树根节点 private transient Entry&lt;K,V&gt; root = null; // 集合元素数量 private transient int size = 0; // &quot;fail-fast&quot;集合修改记录 private transient int modCount = 0; TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。 Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序； Entry中的key比较大小是根据比较器comparator来进行判断的。size是红黑数中节点的个数。 Entry是树的节点类，我们来看一下Entry的定义： static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { K key; V value; // 左孩子节点 Entry&lt;K,V&gt; left = null; // 右孩子节点 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 红黑树用来表示节点颜色的属性，默认为黑色 boolean color = BLACK; /** * 用key，value和父节点构造一个Entry，默认为黑色 */ Entry(K key, V value, Entry&lt;K,V&gt; parent) { this.key = key; this.value = value; this.parent = parent; } public K getKey() { return key ; } public V getValue() { return value ; } public V setValue(V value) { V oldValue = this.value ; this.value = value; return oldValue; } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals( key,e.getKey()) &amp;&amp; valEquals( value,e.getValue()); } public int hashCode() { int keyHash = (key ==null ? 0 : key.hashCode()); int valueHash = (value ==null ? 0 : value.hashCode()); return keyHash ^ valueHash; } public String toString() { return key + &quot;=&quot; + value; } } Entry类主要是定义了树的孩子和父亲节点引用，和红黑颜色属性，并对equals和hashCode进行重写，以利于比较是否相等。 HashMap构造函数/** * 默认构造方法，comparator为空，代表使用key的自然顺序来维持TreeMap的顺序，这里要求key必须实现Comparable接口 */ public TreeMap() { comparator = null; } /** * 用指定的比较器构造一个TreeMap */ public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator; } /** * 构造一个指定map的TreeMap，同样比较器comparator为空，使用key的自然顺序排序 */ public TreeMap(Map&lt;? extends K, ? extends V&gt; m) { comparator = null; putAll(m); } /** * 构造一个指定SortedMap的TreeMap，根据SortedMap的比较器来来维持TreeMap的顺序 */ public TreeMap(SortedMap&lt;K, ? extends V&gt; m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } } 从构造方法中可以看出，要创建一个红黑树实现的TreeMap必须要有一个用于比较大小的比较器，因为只有能够比较大小才能实现红黑树的左孩子&lt;树根&lt;右孩子的特点。 TreeMap遍历方式遍历TreeMap的键值对第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue(); } 遍历TreeMap的键第一步：根据keySet()获取TreeMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key); } 遍历TreeMap的值第一步：根据value()获取TreeMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 Integer value = null; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); } 总结 耗时4天的源代码分析工作终于搞定了，又更加深入的理解了红黑树的插入和删除，但是情况太多，必须画图来理解思想，看源代码真的很棒，比我高出一大截，慢慢学习吧，有句话说的好，中国人很多，但是平庸的人更多，每天坚持一点，一定会成功的。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"TreeMap","slug":"TreeMap","permalink":"https://fengjiaxin.github.io/tags/TreeMap/"}]},{"title":"TreeMap源码学习(二)","slug":"TreeMap源码学习 (二) ","date":"2017-02-26T07:46:58.000Z","updated":"2017-02-26T12:02:23.092Z","comments":true,"path":"2017/02/26/TreeMap源码学习 (二) /","link":"","permalink":"https://fengjiaxin.github.io/2017/02/26/TreeMap源码学习 (二) /","excerpt":"","text":"今天接着学习红黑树的删除，删除的情况比插入节点的情况复杂的多，那么今天就仔细整理一下TreeMap的remove实现。 红黑树的删除需要以下两个步奏： 将红黑树当成一颗二叉查找树，将节点删除。 通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。 删除节点的关键是： 如果删除的是红色节点，不会违背红黑树的规则。 如果删除的是黑色节点，那么这个路径上就少了一个黑色节点，则违背了红黑树的规则。 那么来分析一下红黑树删除节点会有哪几种情况，其实与二叉树类似： 被删除的节点没有孩子节点，即叶子节点。可直接删除。 被删除的节点只有一个孩子节点，那么直接删除该节点，然后用它的孩子节点顶替它的位置。 被删除的节点有两个孩子节点。这种情况二叉树的删除有一个技巧，就是查找到要删除的节点X，然后找到x的后继节点M，然后将M节点的值复制给X，此时M就最多只有一个子节点N(后继节点M一定没有左子树)，若M没有孩子则进入1的情况，否则进入2的情况。 如上图，我们假定节点X是要删除的节点，而节点M是找到X右子树的最小元素，所以节点M是X的替代节点，也就是说M是真正要删除的节点。上面我们分析了此时的M只会有一个子节点N，当删除节点M后，N将替代M作为M节点的父节点的子节点。删除的节点M是黑色（删除红色不影响上面分析了），此时如果N是红色，只需将N设置为黑色，就会重新达到平衡，不会出现该路径上少了一个黑色节点的情况。 如果N是黑色的，情况就比较复杂，需要对红黑树进行调整，而这种情况又分为了以下几种，下面进行图解： ①N的兄弟节点B是红色。方法是：交换P和B的颜色，左旋父节点P。此时并未完成平衡，左子树仍然少了一个黑色节点，进入情况③。（B为红色，P必然为黑色） ②N的父节点P是黑色，且兄弟节点B和它的两个孩子节点也都是黑色。方法是：将N的兄弟节点B改为红色，这样从P出发到叶子节点的路径都包含了相同的黑色节点，但是，对于节点P这个子树，P的父节点G到P的叶子节点路径上的黑色节点就少了一个，此时需要将P整体看做一个节点，继续调整。 ③N的父节点P为红色，兄弟节点B和它的两个孩子节点也都是黑色。此时只需要交换P和B的颜色，将P改为黑色，B改为红色，则可到达平衡。这相当于既然节点N路径少了一个黑色节点，那么B路径也少一个黑色节点，这两个路径达到平衡，为了防止P路径少一个黑色节点，将P节点置黑，则达到最终平衡。 ④N的兄弟节点B是黑色，B的左孩子节点BL是红色，B的右孩子节点BR是黑色，P为任意颜色。方法是：交换B和BL的颜色，右旋节点B。此时N子树路径并没有增加黑色节点，也就是没有达到平衡，此时进入下一种情况⑤。 ⑤N的兄弟节点B是黑色，B的右孩子节点BR是红色，B的左孩子节点BL任意颜色，P任意颜色。方法是：BR变为黑色，P变为黑色，B变为P的颜色；左旋节点B。首先给N路径增加一个黑色节点P，P原位置上的颜色不变；S路径少了一个黑色节点，于是将BR改为黑色，最终达到了平衡。 上面对红黑树删除的原理和删除过程中遇到的情况进行了分析说明，我们得到的结论是红黑树的删除遇到的主要问题就是被删除路径上的黑色节点减少，于是需要进行一系列旋转和着色，当然上面的情况是基于M是X右子树的最小元素。我们具体看下TreeMap的代码是怎么实现的： public V remove(Object key) { // 根据key查找到对应的节点对象 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 记录key对应的value，供返回使用 V oldValue = p. value; // 删除节点 deleteEntry(p); return oldValue; } private void deleteEntry(Entry&lt;K,V&gt; p) { modCount++; // map容器的元素个数减一 size--; // If strictly internal, copy successor&apos;s element to p and then make p // point to successor. // 如果被删除的节点p的左孩子和右孩子都不为空，则查找其替代节点-----------这里表示要删除的节点有两个孩子（3） if (p.left != null &amp;&amp; p. right != null) { // 查找p的替代节点 Entry&lt;K,V&gt; s = successor (p); p. key = s.key ; p. value = s.value ; // 将p指向替代节点，※※※※※※从此之后的p不再是原先要删除的节点p，而是替代者p（就是图解里面讲到的M） ※※※※※※ p = s; } // p has 2 children // Start fixup at replacement node, if it exists. // replacement为替代节点p的继承者（就是图解里面讲到的N），p的左孩子存在则用p的左孩子替代，否则用p的右孩子 Entry&lt;K,V&gt; replacement = (p. left != null ? p.left : p. right); if (replacement != null) { // 如果上面的if有两个孩子不通过--------------这里表示要删除的节点只有一个孩子（2） // Link replacement to parent // 将p的父节点拷贝给替代节点 replacement. parent = p.parent ; // 如果替代节点p的父节点为空，也就是p为跟节点，则将replacement设置为根节点 if (p.parent == null) root = replacement; // 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的左孩子 else if (p == p.parent. left) p. parent.left = replacement; // 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的右孩子 else p. parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. // 将替代节点p的left、right、parent的指针都指向空，即解除前后引用关系（相当于将p从树种摘除），使得gc可以回收 p. left = p.right = p.parent = null; // Fix replacement // 如果替代节点p的颜色是黑色，则需要调整红黑树以保持其平衡 if (p.color == BLACK) fixAfterDeletion(replacement); } else if (p.parent == null) { // return if we are the only node. // 如果要替代节点p没有父节点，代表p为根节点，直接删除即可 root = null; } else { // No children. Use self as phantom replacement and unlink. // 判断进入这里说明替代节点p没有孩子--------------这里表示没有孩子则直接删除（1） // 如果p的颜色是黑色，则调整红黑树 if (p.color == BLACK) fixAfterDeletion(p); // 下面删除替代节点p if (p.parent != null) { // 解除p的父节点对p的引用 if (p == p.parent .left) p. parent.left = null; else if (p == p.parent. right) p. parent.right = null; // 解除p对p父节点的引用 p. parent = null; } } } /** * 查找要删除节点的替代节点 */ static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) { if (t == null) return null; // 查找右子树的最左孩子 else if (t.right != null) { Entry&lt;K,V&gt; p = t. right; while (p.left != null) p = p. left; return p; } else { // 查找左子树的最右孩子 Entry&lt;K,V&gt; p = t. parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p. right) { ch = p; p = p. parent; } return p; } } /** From CLR */ private void fixAfterDeletion(Entry&lt;K,V&gt; x) { // while循环，保证要删除节点x不是跟节点，并且是黑色（根节点和红色不需要调整） while (x != root &amp;&amp; colorOf (x) == BLACK) { // 如果要删除节点x是其父亲的左孩子 if (x == leftOf( parentOf(x))) { // 取出要删除节点x的兄弟节点 Entry&lt;K,V&gt; sib = rightOf(parentOf (x)); // 如果删除节点x的兄弟节点是红色---------------------------① if (colorOf(sib) == RED) { // 将x的兄弟节点颜色设置为黑色 setColor(sib, BLACK); // 将x的父节点颜色设置为红色 setColor(parentOf (x), RED); // 左旋x的父节点 rotateLeft( parentOf(x)); // 将sib重新指向旋转后x的兄弟节点 ，进入else的步奏③ sib = rightOf(parentOf (x)); } // 如果x的兄弟节点的两个孩子都是黑色-------------------------③ if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf (sib)) == BLACK) { // 将兄弟节点的颜色设置为红色 setColor(sib, RED); // 将x的父节点指向x，如果x的父节点是黑色，需要将x的父节点整天看做一个节点继续调整-------------------------② x = parentOf(x); } else { // 如果x的兄弟节点右孩子是黑色，左孩子是红色-------------------------④ if (colorOf(rightOf(sib)) == BLACK) { // 将x的兄弟节点的左孩子设置为黑色 setColor(leftOf (sib), BLACK); // 将x的兄弟节点设置为红色 setColor(sib, RED); // 右旋x的兄弟节点 rotateRight(sib); // 将sib重新指向旋转后x的兄弟节点，进入步奏⑤ sib = rightOf(parentOf (x)); } // 如果x的兄弟节点右孩子是红色-------------------------⑤ setColor(sib, colorOf (parentOf(x))); // 将x的父节点设置为黑色 setColor(parentOf (x), BLACK); // 将x的兄弟节点的右孩子设置为黑色 setColor(rightOf (sib), BLACK); // 左旋x的父节点 rotateLeft( parentOf(x)); // 达到平衡，将x指向root，退出循环 x = root; } } else { // symmetric // 如果要删除节点x是其父亲的右孩子，和上面情况一样，这里不再细讲 Entry&lt;K,V&gt; sib = leftOf(parentOf (x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf (x), RED); rotateRight( parentOf(x)); sib = leftOf(parentOf (x)); } if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf (sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(leftOf(sib)) == BLACK) { setColor(rightOf (sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf (x)); } setColor(sib, colorOf (parentOf(x))); setColor(parentOf (x), BLACK); setColor(leftOf (sib), BLACK); rotateRight( parentOf(x)); x = root; } } } setColor(x, BLACK); } 代码还是得多看几遍，太复杂了。 终于看完了红黑树的增加和删除，下面来看个稍微简单的查询： 红黑树的查询 public V get(Object key) { Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p. value); } final Entry&lt;K,V&gt; getEntry(Object key) { // Offload comparator-based version for sake of performance if (comparator != null) // 如果比较器为空，只是用key作为比较器查询 return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 取得root节点 Entry&lt;K,V&gt; p = root; // 从root节点开始查找，根据比较器判断是在左子树还是右子树 while (p != null) { int cmp = k.compareTo(p.key ); if (cmp &lt; 0) p = p. left; else if (cmp &gt; 0) p = p. right; else return p; } return null; } final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) { K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator ; if (cpr != null) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = cpr.compare(k, p.key ); if (cmp &lt; 0) p = p. left; else if (cmp &gt; 0) p = p. right; else return p; } } return null; } 到此，红黑树的增加、删除、查询都已经学习完毕了，同时我们也看了源代码，接下来就分析TreeMap的其余属性以及相关的遍历知识。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"TreeMap","slug":"TreeMap","permalink":"https://fengjiaxin.github.io/tags/TreeMap/"}]},{"title":"TreeMap源码学习(一)","slug":"TreeMap源码学习 (一)","date":"2017-02-25T07:46:58.000Z","updated":"2017-02-26T12:02:16.378Z","comments":true,"path":"2017/02/25/TreeMap源码学习 (一)/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/25/TreeMap源码学习 (一)/","excerpt":"","text":"今天来介绍下TreeMap,TreeMap是基于红黑树结构实现的一种Map，要分析TreeMap的实现首先就要对红黑树有所了解。构造图如下:蓝色线条：继承绿色线条：接口实现 TreeMap底层是基于红黑树（Red-Black tree）实现，所以在学习TreeMap之前我们先来了解下红黑树。 红黑树又称红-黑二叉树，它首先是一颗二叉树，它具有二叉树所有的特性，同时红黑树更是一颗自平衡的排序二叉树。 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。 红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则： 每个节点都只能是红色或者黑色 根节点是黑色 每个叶节点（NIL节点，空节点）是黑色的。 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 红黑树示意图如下： 但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。 下面来看下什么是红黑树的左旋和右旋： 对x进行左旋，意味着”将x变成一个左节点”。 对y进行右旋，意味着”将y变成一个右节点”。 TreeMap源码解析(基于JDK1.6.0_45) 红黑树的添加原理及TreeMap的put实现 将一个节点添加到红黑树中，通常需要下面几个步骤： 将红黑树当成一颗二叉查找树，将节点插入. 将新插入的节点设置为红色为什么新插入的节点一定要是红色的，因为新插入节点为红色，不会违背红黑规则第（5）条，少违背一条就少处理一种情况。 通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。 要想知道怎么样进行左旋和右旋，首先就要知道为什么要进行左旋和右旋。 我们来对比下红黑树的规则和新插入节点后的情况，看下新插入节点会违背哪些规则。 （1）节点是红色或黑色。 这一点肯定是不会违背的了。 （2）根节点是黑色。 这一点也不会违背了，如果是根节点，只需将根节点插入就好了，因为默认是黑色。 （3）每个叶节点（NIL节点，空节点）是黑色的。 这一点也不会违背的，我们插入的是非空的节点，不会影响空节点。 （4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 这一点是有可能违背的，我们将新插入的节点都设置成红色，如果其父节点也是红色的话，那就产生冲突了。 （5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 这一点也不会违背，因为我们将新插入的节点都设置成红色。 了解了红黑树左旋和右旋操作，以及新插入节点主要是可能会违背红黑树的规则（4）后，我们来分析下，添加新节点的过程有哪几种情况： （1）新插入节点为根节点。这种情况直接将新插入节点设置为根节点即可，无需进行后续的旋转和着色处理。（2）新插入节点的父节点是黑色。这种情况直接将新节点插入即可，不会违背规则（4）。（3）新插入节点的父节点是红色。这种情况会违背规则（4），而这种情况又分为了以下几种，下面进行图解： 1 新插入节点N的父节点P是祖父节点G的左孩子: 那么有一下三种情况 ①新插入节点N的父节点P和叔叔节点U都是红色。方法是：将祖父节点G设置为红色，父节点P和叔叔节点U设置为黑色，这时候就看似平衡了。但是，如果祖父节点G的父节点也是红色，这时候又违背规则（4）了，怎么办，方法是：将GPUZ这一组看成一个新的节点，按照前面的方案递归；又但是根节点为红就违反规则（2）了，怎么办，方法是直接将根节点设置为黑色（两个连续黑色是没问题的）。 ②新插入节点Z的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点N是P的右孩子。方法是：左旋父节点P。左旋后N和P角色互换，但是P和N还是连续的两个红色节点，还没有平衡，怎么办，看第三种情况。 ③新插入节点N的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点Z是P的左孩子。方法是：右旋祖父节点G，然后将P设置为黑色，G设置为红色，达到平衡。此时父节点P是黑色，所有不用担心P的父节点是红色。 2 新插入节点N的父节点P是祖父节点G的右孩子: ①新插入节点N的父节点P和叔叔节点U都是红色。方法是：将祖父节点G设置为红色，父节点P和叔叔节点U设置为黑色，这时候就看似平衡了。但是，如果祖父节点G的父节点也是红色，这时候又违背规则（4）了，怎么办，方法是：将GPUZ这一组看成一个新的节点，按照前面的方案递归；又但是根节点为红就违反规则（2）了，怎么办，方法是直接将根节点设置为黑色（两个连续黑色是没问题的）。 ②新插入节点Z的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点Z是P的左孩子。方法是：左旋父节点P。左旋后Z和P角色互换，但是P和N还是连续的两个红色节点，还没有平衡，怎么办，看第三种情况。 ③新插入节点Z的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点Z是P的右孩子。方法是：右旋祖父节点G，然后将P设置为黑色，G设置为红色，达到平衡。此时父节点P是黑色，所有不用担心P的父节点是红色。 上面分析了这么多，到底TreeMap是怎么实现的呢，我们来看下： public V put(K key, V value) { // 根节点 Entry&lt;K,V&gt; t = root; // 如果根节点为空，则直接创建一个根节点，返回 if (t == null) { // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; } // 记录比较结果 int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths // 当前使用的比较器 Comparator&lt;? super K&gt; cpr = comparator ; // 如果比较器不为空，就是用指定的比较器来维护TreeMap的元素顺序 if (cpr != null) { // do while循环，查找key要插入的位置（也就是新节点的父节点是谁） do { // 记录上次循环的节点t parent = t; // 比较当前节点的key和新插入的key的大小 cmp = cpr.compare(key, t. key); // 新插入的key小的话，则以当前节点的左孩子节点为新的比较节点 if (cmp &lt; 0) t = t. left; // 新插入的key大的话，则以当前节点的右孩子节点为新的比较节点 else if (cmp &gt; 0) t = t. right; else // 如果当前节点的key和新插入的key想的的话，则覆盖map的value，返回 return t.setValue(value); // 只有当t为null，也就是没有要比较节点的时候，代表已经找到新节点要插入的位置 } while (t != null); } else { // 如果比较器为空，则使用key作为比较器进行比较 // 这里要求key不能为空，并且必须实现Comparable接口 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 和上面一样，喜欢查找新节点要插入的位置 do { parent = t; cmp = k.compareTo(t. key); if (cmp &lt; 0) t = t. left; else if (cmp &gt; 0) t = t. right; else return t.setValue(value); } while (t != null); } // 找到新节点的父节点后，创建节点对象 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); // 如果新节点key的值小于父节点key的值，则插在父节点的左侧 if (cmp &lt; 0) parent. left = e; // 如果新节点key的值大于父节点key的值，则插在父节点的右侧 else parent. right = e; // 插入新的节点后，为了保持红黑树平衡，对红黑树进行调整 fixAfterInsertion(e); // map元素个数+1 size++; modCount++; return null; } /** 新增节点后对红黑树的调整方法 */ private void fixAfterInsertion(Entry&lt;K,V&gt; x) { // 将新插入节点的颜色设置为红色 x. color = RED; // while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整） while (x != null &amp;&amp; x != root &amp;&amp; x. parent.color == RED) { // 如果新插入节点x的父节点是祖父节点的左孩子 if (parentOf(x) == leftOf(parentOf (parentOf(x)))) { // 取得新插入节点x的叔叔节点 Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x))); // 如果新插入x的父节点是红色-------------------① if (colorOf(y) == RED) { // 将x的父节点设置为黑色 setColor(parentOf (x), BLACK); // 将x的叔叔节点设置为黑色 setColor(y, BLACK); // 将x的祖父节点设置为红色 setColor(parentOf (parentOf(x)), RED); // 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环 x = parentOf(parentOf (x)); } else { // 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子-------------------② if (x == rightOf( parentOf(x))) { // 左旋父节点 x = parentOf(x); rotateLeft(x); } // 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子-------------------③ // 将x的父节点设置为黑色 setColor(parentOf (x), BLACK); // 将x的祖父节点设置为红色 setColor(parentOf (parentOf(x)), RED); // 右旋x的祖父节点 rotateRight( parentOf(parentOf (x))); } } else { // 如果新插入节点x的父节点是祖父节点的右孩子，下面的步奏和上面的相似，只不过左旋右旋的区分，不在细讲 Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf (x), BLACK); setColor(y, BLACK); setColor(parentOf (parentOf(x)), RED); x = parentOf(parentOf (x)); } else { if (x == leftOf( parentOf(x))) { x = parentOf(x); rotateRight(x); } setColor(parentOf (x), BLACK); setColor(parentOf (parentOf(x)), RED); rotateLeft( parentOf(parentOf (x))); } } } // 最后将根节点设置为黑色，不管当前是不是红色，反正根节点必须是黑色 root.color = BLACK; } /** * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： * px px * / / * x y * / \\ --(左旋)-- / \\ * lx y x ry * / \\ / \\ * ly ry lx ly * */ private void rotateLeft(Entry&lt;K,V&gt; p) { if (p != null) { // 取得要选择节点p的右孩子 Entry&lt;K,V&gt; r = p. right; // &quot;p&quot;和&quot;r的左孩子&quot;的相互指向... // 将&quot;r的左孩子&quot;设为&quot;p的右孩子&quot; p. right = r.left ; // 如果r的左孩子非空，将&quot;p&quot;设为&quot;r的左孩子的父亲&quot; if (r.left != null) r. left.parent = p; // &quot;p的父亲&quot;和&quot;r&quot;的相互指向... // 将&quot;p的父亲&quot;设为&quot;y的父亲&quot; r. parent = p.parent ; // 如果&quot;p的父亲&quot;是空节点，则将r设为根节点 if (p.parent == null) root = r; // 如果p是它父节点的左孩子，则将r设为&quot;p的父节点的左孩子&quot; else if (p.parent. left == p) p. parent.left = r; else // 如果p是它父节点的左孩子，则将r设为&quot;p的父节点的左孩子&quot; p. parent.right = r; // &quot;p&quot;和&quot;r&quot;的相互指向... // 将&quot;p&quot;设为&quot;r的左孩子&quot; r. left = p; // 将&quot;p的父节点&quot;设为&quot;r&quot; p. parent = r; } } /** * 对红黑树的节点进行右旋转 * * 右旋示意图(对节点y进行右旋)： * py py * / / * y x * / \\ --(右旋)-- / \\ * x ry lx y * / \\ / \\ * lx rx rx ry * */ private void rotateRight(Entry&lt;K,V&gt; p) { if (p != null) { // 取得要选择节点p的左孩子 Entry&lt;K,V&gt; l = p. left; // 将&quot;l的右孩子&quot;设为&quot;p的左孩子&quot; p. left = l.right ; // 如果&quot;l的右孩子&quot;不为空的话，将&quot;p&quot;设为&quot;l的右孩子的父亲&quot; if (l.right != null) l. right.parent = p; // 将&quot;p的父亲&quot;设为&quot;l的父亲&quot; l. parent = p.parent ; // 如果&quot;p的父亲&quot;是空节点，则将l设为根节点 if (p.parent == null) root = l; // 如果p是它父节点的右孩子，则将l设为&quot;p的父节点的右孩子&quot; else if (p.parent. right == p) p. parent.right = l; //如果p是它父节点的左孩子，将l设为&quot;p的父节点的左孩子&quot; else p.parent .left = l; // 将&quot;p&quot;设为&quot;l的右孩子&quot; l. right = p; // 将&quot;l&quot;设为&quot;p父节点&quot; p. parent = l; } } 我花了一天多的时间看源代码，手动画图才弄懂，当然我也不能一直记住，那么就先写到这里吧，下一篇文章写关于删除的情况，删除更加复制，路漫漫其修远兮啊！","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"TreeMap","slug":"TreeMap","permalink":"https://fengjiaxin.github.io/tags/TreeMap/"}]},{"title":"HashSet源码学习","slug":"HashSet源码学习","date":"2017-02-25T01:00:35.000Z","updated":"2017-03-01T00:16:18.263Z","comments":true,"path":"2017/02/25/HashSet源码学习/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/25/HashSet源码学习/","excerpt":"","text":"今天学习一下HashSet,HashSet是通过HashMap实现的。构造图如下:蓝色线条：继承绿色线条：接口实现 HashSet定义public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable 1.HashSet 是一个没有重复元素的集合。2.由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null元素。3.HashSet是非同步的。如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用Collections.synchronizedSet方法来“包装”set。 Set s = Collections.synchronizedSet(new HashSet(...)); 4.HashSet通过iterator()返回的迭代器是fail-fast的。 HashSet属性// 底层使用HashMap来保存HashSet的元素 private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map // 由于Set只使用到了HashMap的key，所以此处定义一个静态的常量Object类，来充当HashMap的value private static final Object PRESENT = new Object(); HashSet是用HashMap来保存数据，而主要使用到的就是HashMap的key。 看到private static final Object PRESENT = new Object();这里使用一个静态的常量Object类来充当HashMap的value。 既然这里map的value是没有意义的，为什么不直接使用null值来充当value呢？ Java首先将变量PRESENT分配在栈空间，而将new出来的Object分配到堆空间，这里的new Object()是占用堆内存的（一个空的Object对象占用8byte），而null值我们知道，是不会在堆空间分配内存的；从根源上避免NullPointerException的出现。 HashSet构造函数/** * 使用HashMap的默认容量大小16和默认加载因子0.75初始化map，构造一个HashSet */ public HashSet() { map = new HashMap&lt;E,Object&gt;(); } /** * 构造一个指定Collection参数的HashSet，这里不仅仅是Set，只要实现Collection接口的容器都可以 */ public HashSet(Collection&lt;? extends E&gt; c) { map = new HashMap&lt;E,Object&gt;(Math. max((int) (c.size()/.75f) + 1, 16)); // 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中 addAll(c); } /** * 使用指定的初始容量大小和加载因子初始化map，构造一个HashSet */ public HashSet( int initialCapacity, float loadFactor) { map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); } /** * 使用指定的初始容量大小和默认的加载因子0.75初始化map，构造一个HashSet */ public HashSet( int initialCapacity) { map = new HashMap&lt;E,Object&gt;(initialCapacity); } /** * 不对外公开的一个构造方法（默认default修饰），底层构造的是LinkedHashMap，dummy只是一个标示参数，无具体意义 */ HashSet( int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); } 从构造方法可以很轻松的看出，HashSet的底层是一个HashMap，理解了HashMap后，这里没什么可说的。只有最后一个构造方法有写区别，这里构造的是LinkedHashMap，该方法不对外公开，实际上是提供给LinkedHashSet使用的，而第三个参数dummy是无意义的，只是为了区分其他构造方法。 API方法摘要 HashSet源码解析(基于JDK1.6.0_45)增加和删除 /** * 利用HashMap的put方法实现add方法 */ public boolean add(E e) { return map .put(e, PRESENT)== null; } /** * 利用HashMap的remove方法实现remove方法 */ public boolean remove(Object o) { return map .remove(o)==PRESENT; } /** * 添加一个集合到HashSet中，该方法在AbstractCollection中 */ public boolean addAll(Collection&lt;? extends E&gt; c) { boolean modified = false; // 取得集合c迭代器Iterator Iterator&lt;? extends E&gt; e = c.iterator(); // 遍历迭代器 while (e.hasNext()) { // 将集合c的每个元素加入到HashSet中 if (add(e.next())) modified = true; } return modified; } /** * 删除指定集合c中的所有元素，该方法在AbstractSet中 */ public boolean removeAll(Collection&lt;?&gt; c) { boolean modified = false; // 判断当前HashSet元素个数和指定集合c的元素个数，目的是减少遍历次数 if (size() &gt; c.size()) { // 如果当前HashSet元素多，则遍历集合c，将集合c中的元素一个个删除 for (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); ) modified |= remove(i.next()); } else { // 如果集合c元素多，则遍历当前HashSet，将集合c中包含的元素一个个删除 for (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) { if (c.contains(i.next())) { i.remove(); modified = true; } } } return modified; } 是否包含 /** * 利用HashMap的containsKey方法实现contains方法 */ public boolean contains(Object o) { return map .containsKey(o); } /** * 检查是否包含指定集合中所有元素，该方法在AbstractCollection中 */ public boolean containsAll(Collection&lt;?&gt; c) { // 取得集合c的迭代器Iterator Iterator&lt;?&gt; e = c.iterator(); // 遍历迭代器，只要集合c中有一个元素不属于当前HashSet，则返回false while (e.hasNext()) if (!contains(e.next())) return false; return true; } 由于HashMap基于hash表实现，hash表实现的容器最重要的一点就是可以快速存取，那么HashSet对于contains方法，利用HashMap的containsKey方法，效率是非常之快的。在我看来，这个方法也是HashSet最核心的卖点方法之一。 容量检查 /** * Returns the number of elements in this set (its cardinality). * * @return the number of elements in this set (its cardinality) */ public int size() { return map .size(); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * * @return &lt;tt&gt; true&lt;/tt&gt; if this set contains no elements */ public boolean isEmpty() { return map .isEmpty(); } HashSet遍历方式通过Iterator遍历HashSet1.根据iterator()获取HashSet的迭代器。2.遍历迭代器获取各个元素。 // 假设set是HashSet对象 for(Iterator iterator = set.iterator(); iterator.hasNext(); ) { iterator.next(); } 通过for-each遍历HashSet1.根据toArray()获取HashSet的元素集合对应的数组。2.遍历数组，获取各个元素。 // 假设set是HashSet对象，并且set中元素是String类型 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str); 总结 HashSet和HashMap、Hashtable的区别","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"https://fengjiaxin.github.io/tags/HashSet/"}]},{"title":"LinkedList源码学习","slug":"LinkedList源码学习","date":"2017-02-25T00:49:04.000Z","updated":"2017-02-28T01:56:04.264Z","comments":true,"path":"2017/02/25/LinkedList源码学习/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/25/LinkedList源码学习/","excerpt":"","text":"今天来介绍下LinkedList，LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。构造图如下:蓝色线条：继承绿色线条：接口实现LinkedList是基于链表结构的一种List，在分析LinkedList源码前有必要对链表结构进行说明。 1.链表的概念 链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。 1.1.单向链表单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。 1.2.单向循环链表单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。 1.3.双向链表从名字就可以看出，双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。 1.4.双向循环链表双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。而LinkedList就是基于双向循环链表设计的。 LinkedList简介LinkedList定义public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList 是一个继承于AbstractSequentialList的双向循环链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 LinkedList属性看看LinkedList的底层的属性 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); private transient int size = 0; LinkedList中提供了上面两个属性，其中size和ArrayList中一样用来计数，表示list的元素数量，而header则是链表的头结点，Entry则是链表的节点对象。 private static class Entry&lt;E&gt; { E element; // 当前存储元素 Entry&lt;E&gt; next; // 下一个元素节点 Entry&lt;E&gt; previous; // 上一个元素节点 Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) { this.element = element; this.next = next; this.previous = previous; } } Entry为LinkedList 的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。结合上面双向链表的示意图很容易看懂。 LinkedList构造函数/** * 构造一个空的LinkedList . */ public LinkedList() { //将header节点的前一节点和后一节点都设置为自身 header.next = header. previous = header ; } /** * 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列 */ public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } 需要注意的是空的LinkedList构造方法，它将header节点的前一节点和后一节点都设置为自身，这里便说明LinkedList 是一个双向循环链表，如果只是单存的双向链表而不是循环链表，他的实现应该是这样的： public LinkedList() { header.next = null; header. previous = null; } 非循环链表的情况应该是header节点的前一节点和后一节点均为null。 LinkedList源码解析(基于JDK1.6.0_45)增加 /** * 将一个元素添加至list尾部 */ public boolean add(E e) { // 在header前添加元素e，header前就是最后一个结点，就是在最后一个结点的后面添加元素e addBefore(e, header); return true; } /** * 在指定位置添加元素 */ public void add(int index, E element) { // 如果index等于list元素个数，则在队尾添加元素(header之前)，否则在index节点前添加元素 addBefore(element, (index== size ? header : entry(index))); } private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) { // 用entry创建一个要添加的新节点，next为entry，previous为entry.previous，意思就是新节点插入entry前面，确定自身的前后引用， Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); // 下面修改newEntry的前后节点的引用，确保其链表的引用关系是正确的 // 将上一个节点的next指向自己 newEntry. previous.next = newEntry; // 将下一个节点的previous指向自己 newEntry. next.previous = newEntry; // 计数+1 size++; modCount++; return newEntry; } header作为双向循环链表的头结点是不保存数据的，也就是说hedaer中的element永远等于null。 /** 添加一个集合元素到list中*/public boolean addAll(Collection&lt;? extends E&gt; c) { // 将集合元素添加到list最后的尾部 return addAll(size , c);} /** 在指定位置添加一个集合元素到list中*/public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 越界检查 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+ &quot;, Size: &quot;+size ); Object[] a = c.toArray(); // 要插入元素的个数 int numNew = a.length ; if (numNew==0) return false; modCount++; // 找出要插入元素的前后节点 // 获取要插入index位置的下一个节点，如果index正好是list尾部的位置那么下一个节点就是header，否则需要查找index位置的节点 Entry successor = (index== size ? header : entry(index)); // 获取要插入index位置的上一个节点，因为是插入，所以上一个点击就是未插入前下一个节点的上一个 Entry predecessor = successor. previous; // 循环插入 for (int i=0; i&lt;numNew; i++) { // 构造一个节点，确认自身的前后引用 Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); // 将插入位置上一个节点的下一个元素引用指向当前元素（这里不修改下一个节点的上一个元素引用，是因为下一个节点随着循环一直在变） predecessor. next = e; // 最后修改插入位置的上一个节点为自身，这里主要是为了下次遍历后续元素插入在当前节点的后面，确保这些元素本身的顺序 predecessor = e; } // 遍历完所有元素，最后修改下一个节点的上一个元素引用为遍历的最后一个元素 successor. previous = predecessor; // 修改计数器 size += numNew; return true;} 删除 /** * 删除第一个匹配的指定元素 */ public boolean remove(Object o) { // 遍历链表找到要被删除的节点 if (o==null) { for (Entry&lt;E&gt; e = header .next; e != header; e = e.next ) { if (e.element ==null) { remove(e); return true; } } } else { for (Entry&lt;E&gt; e = header .next; e != header; e = e.next ) { if (o.equals(e.element )) { remove(e); return true; } } } return false; } private E remove(Entry&lt;E&gt; e) { if (e == header ) throw new NoSuchElementException(); // 被删除的元素，供返回 E result = e. element; // 下面修正前后对该节点的引用 // 将该节点的上一个节点的next指向该节点的下一个节点 e. previous.next = e.next; // 将该节点的下一个节点的previous指向该节点的上一个节点 e. next.previous = e.previous; // 修正该节点自身的前后引用 e. next = e.previous = null; // 将自身置空，让gc可以尽快回收 e. element = null; // 计数器减一 size--; modCount++; return result; } 修改 /** * 修改指定位置索引位置的元素 */ public E set( int index, E element) { // 查找index位置的节点 Entry&lt;E&gt; e = entry(index); // 取出该节点的元素，供返回使用 E oldVal = e. element; // 用新元素替换旧元素 e. element = element; // 返回旧元素 return oldVal; } set方法看起来简单了很多，只要修改该节点上的元素就好了，但是不要忽略了这里的entry()方法，重点就是它。 查询 方法entry()根据index查询节点，我们知道数组是有下标的，通过下标操作天然的支持根据index查询元素，而链表中是没有index概念呢，那么怎么样才能通过index查询到对应的元素呢，下面就来看看LinkedList是怎么实现的。 /** * 查找指定索引位置的元素 */ public E get( int index) { return entry(index).element ; } /** * 返回指定索引位置的节点 */ private Entry&lt;E&gt; entry( int index) { // 越界检查 if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+ &quot;, Size: &quot;+size ); // 取出头结点 Entry&lt;E&gt; e = header; // size&gt;&gt;1右移一位代表除以2，这里使用简单的二分方法，判断index与list的中间位置的距离 if (index &lt; (size &gt;&gt; 1)) { // 如果index距离list中间位置较近，则从头部向后遍历(next) for (int i = 0; i &lt;= index; i++) e = e. next; } else { // 如果index距离list中间位置较远，则从头部向前遍历(previous) for (int i = size; i &gt; index; i--) e = e. previous; } return e; } 现在知道了，LinkedList是通过从header开始index计为0，然后一直往下遍历（next），直到到底index位置。为了优化查询效率，LinkedList采用了二分查找（这里说的二分只是简单的一次二分），判断index与size中间位置的距离，采取从header向后还是向前查找。 基于双向循环链表实现的LinkedList，通过索引Index的操作时低效的，index所对应的元素越靠近中间所费时间越长。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）。 是否包含 // 判断LinkedList是否包含元素(o) public boolean contains(Object o) { return indexOf(o) != -1; } // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) { int index = 0; if (o==null) { for (Entry e = header .next; e != header; e = e.next ) { if (e.element ==null) return index; index++; } } else { for (Entry e = header .next; e != header; e = e.next ) { if (o.equals(e.element )) return index; index++; } } return -1; } // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) { int index = size ; if (o==null) { for (Entry e = header .previous; e != header; e = e.previous ) { index--; if (e.element ==null) return index; } } else { for (Entry e = header .previous; e != header; e = e.previous ) { index--; if (o.equals(e.element )) return index; } } return -1; } 和public boolean remove(Object o) 一样，indexOf查询元素位于容器的索引位置，都是需要对链表进行遍历操作，很低效。 判断容量 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() { return size ; } /** * {@inheritDoc} * * &lt;p&gt;This implementation returns &lt;tt&gt;size() == 0 &lt;/tt&gt;. */ public boolean isEmpty() { return size() == 0; } 和ArrayList一样，基于计数器size操作，容量判断很方便。 LinkedList实现的Deque双端队列/** * Adds the specified element as the tail (last element) of this list. * * @param e the element to add * @return &lt;tt&gt; true&lt;/tt&gt; (as specified by {@link Queue#offer}) * @since 1.5 */ public boolean offer(E e) { return add(e); } /** * Retrieves and removes the head (first element) of this list * @return the head of this list, or &lt;tt&gt;null &lt;/tt&gt; if this list is empty * @since 1.5 */ public E poll() { if (size ==0) return null; return removeFirst(); } /** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */ public E removeFirst() { return remove(header .next); } /** * Retrieves, but does not remove, the head (first element) of this list. * @return the head of this list, or &lt;tt&gt;null &lt;/tt&gt; if this list is empty * @since 1.5 */ public E peek() { if (size ==0) return null; return getFirst(); } /** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */ public E getFirst() { if (size ==0) throw new NoSuchElementException(); return header .next. element; } /** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to {@link #addFirst}. * * @param e the element to push * @since 1.6 */ public void push(E e) { addFirst(e); } /** * Inserts the specified element at the beginning of this list. * * @param e the element to add */ public void addFirst(E e) { addBefore(e, header.next ); } 对LinkedList以及ArrayList的迭代效率比较结论：ArrayList使用最普通的for循环遍历比较快，LinkedList使用foreach循环比较快。 看一下两个List的定义： public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 注意到ArrayList是实现了RandomAccess接口而LinkedList则没有实现这个接口。 做foreach循环的时候，编译器默认会使用这个集合的Iterator。 总结：LinkedList知识概括 LinkedList 实际上是通过双向链表去实现的；它包含一个非常重要的内部类：Entry；Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。 LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。 LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 ArrayList和LinkedList的比较 顺序插入速度ArrayList会比较快，因为ArrayList是基于数组实现的；LinkedList则不同，每次顺序插入的时候LinkedList将new一个对象出来，再加上一些引用赋值的操作，所以顺序插入LinkedList必然慢于ArrayList。 LinkedList里面不仅维护了待插入的元素，还维护了Entry的前置Entry和后继Entry，如果一个LinkedList中的Entry非常多，那么LinkedList将比ArrayList更耗费一些内存。 ArrayList使用最普通的for循环遍历比较快，LinkedList使用foreach循环比较快；ArrayList的遍历效率会比LinkedList的遍历效率高一些。 有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：（1）LinkedList做插入、删除的时候，慢在寻址，快在只需要改变前后Entry的引用地址。（2）ArrayList做插入、删除的时候，慢在数组元素的批量copy，快在寻址。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://fengjiaxin.github.io/tags/LinkedList/"}]},{"title":"ArrayList源码学习","slug":"ArrayList源码学习","date":"2017-02-25T00:33:23.000Z","updated":"2017-02-27T10:13:36.006Z","comments":true,"path":"2017/02/25/ArrayList源码学习/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/25/ArrayList源码学习/","excerpt":"","text":"关于Java的集合我经常用到，学习的数据结构知识也差不多啦，那么今天就来分析一下Java中的ArrayList源代码，看看Java中的代码是如何编写的。 一、介绍ArrayList继承了AbstractList，实现了List。构造图如下:蓝色线条：继承绿色线条：接口实现 二、ArrayList定义public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector。 三、ArrayList属性 ArrayList就是用数组实现的List容器，底层用数组来保存数据。 // 保存ArrayList中数据的数组 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; ArrayList包含了两个重要的对象：elementData 和 size。 (1) elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长。 (2) size则是动态数组的实际大小。 ArrayList构造函数 // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; } // ArrayList构造函数。默认容量是10。 public ArrayList() { this(10); } // 构造一个包含指定元素的list，这些元素的是按照Collection的迭代器返回的顺序排列的 public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } 第一个构造方法使用提供的initialCapacity来初始化elementData数组的大小。 第二个构造方法调用第一个构造方法并传入参数10，即默认elementData数组的大小为10。 第三个构造方法则将提供的集合转成数组返回给elementData（返回若不是Object[]将调用Arrays.copyOf方法将其转为Object[]）。 四、ArrayList源码解析(基于JDK1.6.0_45) 增加 /* * 添加一个元素 */ public boolean add(E e) { // 进行扩容检查 ensureCapacity( size + 1); // Increments modCount // 将e增加至list的数据尾部，容量+1 elementData[size ++] = e; return true; } /** * 在指定位置添加一个元素 */ public void add(int index, E element) { // 判断索引是否越界，这里会抛出异常。。。 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot; +size); // 进行扩容检查 ensureCapacity( size+1); // Increments modCount // 对数组进行复制处理，目的就是空出index的位置插入element，并将index后的元素位移一个位置 System. arraycopy(elementData, index, elementData, index + 1, size - index); // 将指定的index位置赋值为element elementData[index] = element; // list容量+1 size++; } /** * 增加一个集合元素 */ public boolean addAll(Collection&lt;? extends E&gt; c) { //将c转换为数组 Object[] a = c.toArray(); int numNew = a.length ; //扩容检查 ensureCapacity( size + numNew); // Increments modCount //将c添加至list的数据尾部 System. arraycopy(a, 0, elementData, size, numNew); //更新当前容器大小 size += numNew; return numNew != 0; } /** * 在指定位置，增加一个集合元素 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot; + index + &quot;, Size: &quot; + size); Object[] a = c.toArray(); int numNew = a.length ; ensureCapacity( size + numNew); // Increments modCount // 计算需要移动的长度（index之后的元素个数） int numMoved = size - index; // 数组复制，空出第index到index+numNum的位置，即将数组index后的元素向右移动numNum个位置 if (numMoved &gt; 0) System. arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将要插入的集合元素复制到数组空出的位置中 System. arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } /** * 数组容量检查，不够时则进行扩容 */ public void ensureCapacity( int minCapacity) { modCount++; // 当前数组的长度 int oldCapacity = elementData .length; // 最小需要的容量大于当前数组的长度则进行扩容 if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; // 新扩容的数组长度为旧容量的1.5倍+1 int newCapacity = (oldCapacity * 3)/2 + 1; // 如果新扩容的数组长度还是比最小需要的容量小，则以最小需要的容量为长度进行扩容 if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: // 进行数据拷贝，Arrays.copyOf底层实现是System.arrayCopy() elementData = Arrays.copyOf( elementData, newCapacity); } } 删除 /** * 根据索引位置删除元素 */ public E remove( int index) { // 数组越界检查 RangeCheck(index); modCount++; // 取出要删除位置的元素，供返回使用 E oldValue = (E) elementData[index]; // 计算数组要复制的数量 int numMoved = size - index - 1; // 数组复制，就是将index之后的元素往前移动一个位置 if (numMoved &gt; 0) System. arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收 // 不要忘了size减一 elementData[--size ] = null; // Let gc do its work return oldValue; } /** * 根据元素内容删除，只删除匹配的第一个 */ public boolean remove(Object o) { // 对要删除的元素进行null判断 // 对数据元素进行遍历查找，知道找到第一个要删除的元素，删除后进行返回，如果要删除的元素正好是最后一个那就惨了，时间复杂度可达O(n) 。。。 if (o == null) { for (int index = 0; index &lt; size; index++) // null值要用==比较 if (elementData [index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) // 非null当然是用equals比较了 if (o.equals(elementData [index])) { fastRemove(index); return true; } } return false; } /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) { modCount++; // 原理和之前的add一样，还是进行数组复制，将index后的元素向前移动一个位置。 int numMoved = size - index - 1; if (numMoved &gt; 0) System. arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size ] = null; // Let gc do its work } /** * 数组越界检查 */ private void RangeCheck(int index) { if (index &gt;= size ) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot; +size); } 增加和删除方法到这里就解释完了，代码是很简单，主要是：1.数组扩容，2.数组复制，这两个操作都是极费效率的，最惨的情况下(添加到list第一个位置，删除list最后一个元素或删除list第一个索引位置的元素)时间复杂度可达O(n)。 上面两张图分别是数组扩容和数组复制的过程，需要注意的是，数组扩容伴随着开辟新建的内存空间以创建新数组然后进行数据复制，而数组复制不需要开辟新内存空间，只需将数据进行复制。 增加元素可能会进行扩容，而删除元素却不会进行缩容，如果在已删除为主的场景下使用list，一直不停的删除而很少进行增加，那么会出现浪费空间，需要将数组的大小调整为当前实际元素大小，进行释放空间。 /** * 将底层数组的容量调整为当前实际元素的大小，来释放空间。 */ public void trimToSize() { modCount++; // 当前数组的容量 int oldCapacity = elementData .length; // 如果当前实际元素大小 小于 当前数组的容量，则进行缩容 if (size &lt; oldCapacity) { elementData = Arrays.copyOf( elementData, size ); } 更新 /** * 将指定位置的元素更新为新元素 */ public E set( int index, E element) { // 数组越界检查 RangeCheck(index); // 取出要更新位置的元素，供返回使用 E oldValue = (E) elementData[index]; // 将该位置赋值为行的元素 elementData[index] = element; // 返回旧元素 return oldValue; } 查找 /** * 查找指定位置上的元素 */ public E get( int index) { RangeCheck(index); return (E) elementData [index]; } 是否包含 public boolean contains(Object o) { return indexOf(o) &gt;= 0; } public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData [i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData [i])) return i; } return -1; } public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i--) if (elementData [i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData [i])) return i; } return -1; } contains主要是检查indexOf，也就是元素在list中出现的索引位置也就是数组下标，再看indexOf和lastIndexOf代码是不是很熟悉，没错，和public boolean remove(Object o) 的代码一样，都是元素null判断，都是循环比较。 容量判断 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() { return size ; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt; true&lt;/tt&gt; if this list contains no elements */ public boolean isEmpty() { return size == 0; } 由于使用了size进行计数，发现list大小获取和判断真的好容易。 总结： ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。 ArrayList的克隆函数，即是将全部元素克隆到一个数组中。 ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 ArrayList遍历方式ArrayList支持3种遍历方式 1、通过迭代器遍历。即通过Iterator去遍历。Integer value = null; Iterator iter = list.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); } 2、随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 Integer value = null; int size = list.size(); for (int i=0; i&lt;size; i++) { value = (Integer)list.get(i); } 3、for循环遍历。Integer value = null; for (Integer integ:list) { value = integ; } 下面通过一个实例，比较这3种方式的效率，实例代码(ArrayListRandomAccessTest.java)如下： import java.util.*; import java.util.concurrent.*; /* * @desc ArrayList遍历方式和效率的测试程序。 * */ public class ArrayListRandomAccessTest { public static void main(String[] args) { List list = new ArrayList(); for (int i=0; i&lt;100000; i++) list.add(i); //isRandomAccessSupported(list); iteratorThroughRandomAccess(list) ; iteratorThroughIterator(list) ; iteratorThroughFor2(list) ; } private static void isRandomAccessSupported(List list) { if (list instanceof RandomAccess) { System.out.println(&quot;RandomAccess implemented!&quot;); } else { System.out.println(&quot;RandomAccess not implemented!&quot;); } } public static void iteratorThroughRandomAccess(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) { list.get(i); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughIterator(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) { iter.next(); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughFor2(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;); } } 运行结果： iteratorThroughRandomAccess：3 ms iteratorThroughIterator：8 ms iteratorThroughFor2：5 ms 由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！ 总结 ArrayList和LinkedList的区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 Vector还有一个子类Stack.","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://fengjiaxin.github.io/tags/ArrayList/"}]},{"title":"HashMap源码学习(四)-扩容机制","slug":"HashMap源码学习(四)- 扩容机制","date":"2017-02-23T08:42:20.000Z","updated":"2017-02-24T23:56:56.953Z","comments":true,"path":"2017/02/23/HashMap源码学习(四)- 扩容机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/23/HashMap源码学习(四)- 扩容机制/","excerpt":"","text":"本文继续学习HashMap的方法：扩容方法。 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 JDK1.7的resize的源码如下: 1 void resize(int newCapacity) { //传入新的容量 2 Entry[] oldTable = table; //引用扩容前的Entry数组 3 int oldCapacity = oldTable.length; 4 if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 5 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 6 return; 7 } 8 9 Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 10 transfer(newTable); //！！将数据转移到新的Entry数组里 11 table = newTable; //HashMap的table属性引用新的Entry数组 12 threshold = (int)(newCapacity * loadFactor);//修改阈值 13 } 使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1 void transfer(Entry[] newTable) { 2 Entry[] src = table; //src引用了旧的Entry数组 3 int newCapacity = newTable.length; 4 for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组 5 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 6 if (e != null) { 7 src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） 8 do { 9 Entry&lt;K,V&gt; next = e.next; 10 int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 11 e.next = newTable[i]; //标记[1] 12 newTable[i] = e; //将元素放在数组上 13 e = next; //访问下一个Entry链上的元素 14 } while (e != null); 15 } 16 } 17 } newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod一下表的大小。其中哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。 JDK1.8的resize源码如下: 1 final Node&lt;K,V&gt;[] resize() { 2 Node&lt;K,V&gt;[] oldTab = table; 3 int oldCap = (oldTab == null) ? 0 : oldTab.length; 4 int oldThr = threshold; 5 int newCap, newThr = 0; 6 if (oldCap &gt; 0) { 7 // 超过最大值就不再扩充了，就只好随你碰撞去吧 8 if (oldCap &gt;= MAXIMUM_CAPACITY) { 9 threshold = Integer.MAX_VALUE; 10 return oldTab; 11 } 12 // 没超过最大值，就扩充为原来的2倍 13 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; 14 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) 15 newThr = oldThr &lt;&lt; 1; // double threshold 16 } 17 else if (oldThr &gt; 0) // initial capacity was placed in threshold 18 newCap = oldThr; 19 else { // zero initial threshold signifies using defaults 20 newCap = DEFAULT_INITIAL_CAPACITY; 21 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); 22 } 23 // 计算新的resize上限 24 if (newThr == 0) { 25 26 float ft = (float)newCap * loadFactor; 27 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? 28 (int)ft : Integer.MAX_VALUE); 29 } 30 threshold = newThr; 31 @SuppressWarnings({&quot;rawtypes&quot;，&quot;unchecked&quot;}) 32 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; 33 table = newTab; 34 if (oldTab != null) { 35 // 把每个bucket都移动到新的buckets中 36 for (int j = 0; j &lt; oldCap; ++j) { 37 Node&lt;K,V&gt; e; 38 if ((e = oldTab[j]) != null) { 39 oldTab[j] = null; 40 if (e.next == null) 41 newTab[e.hash &amp; (newCap - 1)] = e; 42 else if (e instanceof TreeNode) 43 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); 44 else { // 链表优化重hash的代码块 45 Node&lt;K,V&gt; loHead = null, loTail = null; 46 Node&lt;K,V&gt; hiHead = null, hiTail = null; 47 Node&lt;K,V&gt; next; 48 do { 49 next = e.next; 50 // 原索引 51 if ((e.hash &amp; oldCap) == 0) { 52 if (loTail == null) 53 loHead = e; 54 else 55 loTail.next = e; 56 loTail = e; 57 } 58 // 原索引+oldCap 59 else { 60 if (hiTail == null) 61 hiHead = e; 62 else 63 hiTail.next = e; 64 hiTail = e; 65 } 66 } while ((e = next) != null); 67 // 原索引放到bucket里 68 if (loTail != null) { 69 loTail.next = null; 70 newTab[j] = loHead; 71 } 72 // 原索引+oldCap放到bucket里 73 if (hiTail != null) { 74 hiTail.next = null; 75 newTab[j + oldCap] = hiHead; 76 } 77 } 78 } 79 } 80 } 81 return newTab; 82 }","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://fengjiaxin.github.io/tags/HashMap/"}]},{"title":"HashMap源码学习(三)-功能实现","slug":"HashMap源码学习(三)- 功能实现","date":"2017-02-23T08:32:20.000Z","updated":"2017-02-24T23:56:50.094Z","comments":true,"path":"2017/02/23/HashMap源码学习(三)- 功能实现/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/23/HashMap源码学习(三)- 功能实现/","excerpt":"","text":"HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行深入学习。 1、确定哈希桶数组索引位置 HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 方法一： static final int hash(Object key) { //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 方法二： static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算 } 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 注意：Object的hashCode()方法中的hashCode是具体怎么计算的呢？ Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样元素的分布相对比较均匀。但是，模运算的消耗较大，在HashMap中调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度16。 2、分析HashMap的put方法 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 HashMap的put方法执行过程可以通过下图来理解 JDK1.8HashMap的put方法源码如下: 1 public V put(K key, V value) { 2 // 对key的hashCode()做hash 3 return putVal(hash(key), key, value, false, true); 4 } 5 6 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, 7 boolean evict) { 8 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 9 // 步骤1：tab为空则创建 10 if ((tab = table) == null || (n = tab.length) == 0) 11 n = (tab = resize()).length; 12 // 步骤2：计算index，并对null做处理 13 if ((p = tab[i = (n - 1) &amp; hash]) == null) 14 tab[i] = newNode(hash, key, value, null); 15 else { 16 Node&lt;K,V&gt; e; K k; 17 // 步骤3：节点key存在，直接覆盖value 18 if (p.hash == hash &amp;&amp; 19 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) 20 e = p; 21 // 步骤4：判断该链为红黑树 22 else if (p instanceof TreeNode) 23 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); 24 // 步骤5：该链为链表 25 else { 26 for (int binCount = 0; ; ++binCount) { 27 if ((e = p.next) == null) { 28 p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 29 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st 30 treeifyBin(tab, hash); 31 break; 32 } // key已经存在直接覆盖value 33 if (e.hash == hash &amp;&amp; 34 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) 35 break; 36 p = e; 37 } 38 } 39 40 if (e != null) { // existing mapping for key 41 V oldValue = e.value; 42 if (!onlyIfAbsent || oldValue == null) 43 e.value = value; 44 afterNodeAccess(e); 45 return oldValue; 46 } 47 } 48 ++modCount; 49 // 步骤6：超过最大容量 就扩容 50 if (++size &gt; threshold) 51 resize(); 52 afterNodeInsertion(evict); 53 return null; 54 } 这样就把哈希桶数组索引位置、put方法讲解了一下，这样我们就在以后Java调用时更好地应用HashMap，那么下一章节就学习一下扩容机制，这个算法我记得在算法导论中曾经有相关的题目，下一章继续学习。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://fengjiaxin.github.io/tags/HashMap/"}]},{"title":"HashMap源码学习(二)-存储结构","slug":"HashMap源码学习(二)- 存储结构","date":"2017-02-23T08:22:20.000Z","updated":"2017-02-25T00:33:59.806Z","comments":true,"path":"2017/02/23/HashMap源码学习(二)- 存储结构/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/23/HashMap源码学习(二)- 存储结构/","excerpt":"","text":"HshMap的内部实现 搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。这篇文章主要学习存储结构。 存储结构-字段 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下所示： 1 哈希桶数组 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组。 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) { ... } public final K getKey(){ ... } public final V getValue() { ... } public final String toString() { ... } public final int hashCode() { ... } public final V setValue(V newValue) { ... } public final boolean equals(Object o) { ... } } Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 2 HashMap就是使用哈希表来存储的 哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。 例如程序执行下面代码： map.put(&quot;啦啦&quot;,&quot;嘿嘿&quot;); 系统将调用”啦啦”这个key的hashCode()方法得到其hashCode值，然后再通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？ 答案就是好的Hash算法和扩容机制。 3 HashMap的扩容字段 从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Loadfactor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。 threshold = length * Load factor。 也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Loadfactor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。 size字段就是HashMap中实际存在的键值对数量。modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数。 HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://fengjiaxin.github.io/tags/HashMap/"}]},{"title":"HashMap源码学习(一)-介绍","slug":"HashMap源码学习(一)-介绍","date":"2017-02-23T08:12:20.000Z","updated":"2017-02-24T04:43:15.078Z","comments":true,"path":"2017/02/23/HashMap源码学习(一)-介绍/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/23/HashMap源码学习(一)-介绍/","excerpt":"","text":"最近学习处理大数据，一般方法都是先将数据进行哈希分类，虽然学习数据结构的时候很了解HashMap的原理，但是并不清楚Java中是如何实现的，那么今天就结合原理和源代码好好总结一下HashMap这个类。 一、HashMap的引入 数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。 1.数组 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难； ##2.链表## 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？ 答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。 二、HashMap数据结构简介 Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： 1 HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 2 LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 3 TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述三种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。","categories":[{"name":"JAVA源码学习","slug":"JAVA源码学习","permalink":"https://fengjiaxin.github.io/categories/JAVA源码学习/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://fengjiaxin.github.io/tags/HashMap/"}]},{"title":"回调机制","slug":"回调机制","date":"2017-02-23T07:19:50.000Z","updated":"2017-02-23T08:09:58.061Z","comments":true,"path":"2017/02/23/回调机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/23/回调机制/","excerpt":"","text":"之前在学习操作系统的时候，Linux系统是用c语言编写，当时就涉及到了回调机制，回调函数就是指函数先在某处注册，而他将在某个需要的时刻被调用。虽然字面很简单，但是今天有必要将其和同步异步的概念结合起来，然后利用Java语言更好地理解回调机制。 一、 异步和同步 讲通俗点，异步就是不需要等当前执行的动作完成，就可以继续执行后面的动作。 通常一个程序执行的顺序是：从上到下，依次执行。后面的动作必须等前面动作执行完成以后方可执行。这就是同步。 这里引用一个例子进行说明。 案例：A、张三打电话给李四，让李四帮忙写份材料。B、李四接到电话的时候，手上有自己的工作要处理，但他答应张三，忙完手上的工作后马上帮张三写好材料，并传真给张三。C、通完电话后，张三外出办事。 说明：张三给李四通完电话后，就出去办事了，他并不需要等李四把材料写好才外出。那么张三让李四写材料的消息就属于异步消息。相反，如果张三必须等李四把材料写好才能外出办事的话，那么这个消息就属于同步消息了。 二、 异步的实现 传统的程序执行代码都是从上到下，一条一条执行的。 在以上的案例中，如果李四需要几个小时以后才能帮张三写好材料的话，那张三就必须等几个小时，这样张三这几个小时就无法干其他的事情。 可以使用以下办法来处理这种问题： 张三找王五去给李四打电话，等李四写好材料后，由王五转交给张三。这样张三就可以外出办其他的事情了。 问题得到了合理的解决，之前张三一条线的工作，由张三和王五两条线来完成了，两边同时进行，彼此不耽误。 三、 计算机语言的实现 以前由一个线程来处理的工作，可以通过新增一个线程来达到异步的目的。这也就是JAVA中的多线程技术。 最后李四写好的材料必须交给张三，以做他用。这就是回调。 回调机制可以这样理解： A发送消息给B，B处理好A要求的事情后，将结果返回给A，A再对B返回的结果来做进一步的处理。 四、 Java代码的实现回调的实现 /** * 回调接口 * @author: 冯佳欣 * @date: 2017年2月23日 下午3:45:06 */ public interface CallBack { /** * 执行回调方法 * @param objects 将处理后的结果作为参数返回给回调函数 * @return: void */ public void execute(Object...objects); } 消息的发送者 /** * 简单本地发送异步消息的类 * @author: 冯佳欣 * @date: 2017年2月23日 下午3:47:07 */ public class Local implements CallBack, Runnable { /** * 远程接收消息的类。 */ private Remote remote; /** * 发送出去的消息 */ private String message; public Local(Remote remote ,String message){ super(); this.remote = remote; this.message = message; } public void sendMessage(){ //当前线程的名称 System.out.println(Thread.currentThread().getName()); //创建一个新的线程发送消息 Thread thread = new Thread(this); thread.start(); //当前线程继续执行 System.out.println(&quot;Message has been sent by Local&quot;); } @Override public void run() { remote.excuteMessage(message, this); } /** * 发送消息后的回调函数 */ @Override public void execute(Object... objects) { //打印返回的消息 System.out.println(objects[0]); //打印发送消息的线程名称 System.out.println(Thread.currentThread().getName()); //中断发送消息的线程 Thread.interrupted(); } public static void main(String[] args){ Local local = new Local(new Remote(),&quot;hello&quot;); local.sendMessage(); } } 远程消息的接收者 /** * 处理消息的远程类 * @author: 冯佳欣 * @date: 2017年2月23日 下午3:49:43 */ public class Remote { /** * 处理消息 * @param msg 接收的消息 * @param callBack 回调函数处理类 * @return: void */ public void excuteMessage(String msg,CallBack callBack){ /** * 模拟远程类正在处理其他事情 */ for(int i =0;i&lt;10000;i++) { } /** * 处理完其他事情，现在来处理消息 */ System.out.println(msg); System.out.println(&quot;I have executed the message by Local&quot;); /** * 执行回调 */ callBack.execute(new String[]{&quot;Nice to meet you~!&quot;}); } } 执行结果为 main Message has been sent by Local hello I have executed the message by Local Nice to meet you~! 注意：remote.executeMessage(message, this); executeMessage方法需要接收一个message参数，表示发送出去的消息，而CallBack参数是他自己，也就是这里的this。表示发送消息后，由Local类自己来处理，调用自身的execute方法来处理消息结果。 如果这里不是用this，而是用其他的CallBack接口的实现类的话，那就不能称之为“回调”了，在OO的世界里，那就属于“委派”。也就是说，“回调”必须是消息的发送者来处理消息结果，否则不能称之为回调。这个概念必须明确。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"回调","slug":"回调","permalink":"https://fengjiaxin.github.io/tags/回调/"}]},{"title":"Comparable接口的实现和使用","slug":"Comparable接口的实现和使用","date":"2017-02-20T14:07:31.000Z","updated":"2017-02-20T14:38:31.996Z","comments":true,"path":"2017/02/20/Comparable接口的实现和使用/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/20/Comparable接口的实现和使用/","excerpt":"","text":"在c语言中，有一个非常重要的概念就是回调函数，所谓回调函数，就是指函数先在某处注册，而他将在某个需要的时刻被调用。 关于回调函数的概念，我将另起一篇文章进行学习。 在Java中没有指针的概念，那么如何在Java语言中实现类似于函数指针的功能？可以利用接口与类来实现同样的效果，具体而言，就是先定义一个接口，然后在接口中声明要被调用的方法，接着实现这个接口，最后把这个实现类的一个对象作为参数传递给调用程序，调用程序通过这个参数来调用指定的函数，从而实现回调函数的功能。 那么接下来学习Compareble接口的实现和使用。 1.什么是Comparable接口 此接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序 ，类的 compareTo 方法被称为它的自然比较方法 。实现此接口的对象列表（和数组）可以通过 Collections.sort （和 Arrays.sort ）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。 2.实现什么方法int compareTo(T o) 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。” 参数： o - 要比较的对象。 返回： 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 抛出： ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。 3.代码实例import java.util.Arrays; import java.util.Random; class Employee implements Comparable&lt;Employee&gt;{ private int id; private String name; private double salary; public Employee(String n,double s){ this.name = n; this.salary =s; Random ID = new Random(); id = ID.nextInt(10000000); } public int getId() { return id; } public String getName() { return name; } public double getSalary() { return salary; } @Override //这里比较的是什么 sort方法实现的就是按照此比较的东西从小到大排列 public int compareTo(Employee o) { if(id&lt;o.id) return -1; if(id&gt;o.id) return 1; return 0; } } public class EmployeeSortTest { public static void main(String[] args) { Employee[] staff = new Employee[3]; staff[0] = new Employee(&quot;fengjiaxin&quot;,35000); staff[1] = new Employee(&quot;yangqi&quot;,40000); staff[2] = new Employee(&quot;james&quot;,50000); //sort方法可以实现对对象数组排序，但是必须实现 Comparable接口 Arrays.sort(staff); for(Employee e:staff) System.out.println(&quot;id:&quot;+e.getId()+&quot; name:&quot;+e.getName()+&quot; salary:&quot;+e.getSalary()); } } 4.与Comparator的区别 Comparator位于包java.util下，而Comparable位于包java.lang下，Comparable接口将比较代码嵌入自身类中，而后者在一个独立的类中实现比较。 如果类的设计师没有考虑到Compare的问题而没有实现Comparable接口，可以通过 Comparator来实现比较算法进行排序，并且为了使用不同的排序标准做准备，比如：升序、降序。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"Comparable","slug":"Comparable","permalink":"https://fengjiaxin.github.io/tags/Comparable/"}]},{"title":"null关键字理解","slug":"null关键字理解","date":"2017-02-19T13:35:07.000Z","updated":"2017-02-23T14:31:42.413Z","comments":true,"path":"2017/02/19/null关键字理解/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/19/null关键字理解/","excerpt":"","text":"关键字是电脑语言里事先定义的，有特别意义的标识符，有时又叫保留字，还有特别意义的变量。Java的关键字对Java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。Java语言规定了Java中的关键字不能作为标识符。那么，今天，我们来探讨一下Java中的关键字null。 一、null是代表不确定的对象 Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。 比如：int a = null;是错误的。Ojbect o = null是正确的。 Java中，变量的适用都遵循一个原则，先定义，并且初始化后，才可以使用。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。 我们在定义一个引用类型变量时，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。但我们下面使用变量的时候就会报错。但只要先给变量指定一个null值，问题就解决了。例： Connection conn = null; try { conn = DriverManager.getConnection(&quot;url&quot;, &quot;user&quot;, &quot;password&quot;); } catch (SQLException e) { e.printStackTrace(); } String catalog = conn.getCatalog(); 如果刚开始的时候不指定conn = null，则最后一句就会报错。 二、null本身不是对象，也不是Objcet的实例 null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。 三、Java默认给变量赋值 在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。赋值原则是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。 四、null的其他作用1、判断一个引用类型数据是否null。 用==来判断。2、释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。 五、null与””的相关问题问题一：null和””的区别String s=null; string.trim()就会抛出为空的exception String s=&quot;&quot;; string.trim()就不会抛,为什么? NULL代表声明了一个空对象，根本就不是一个字符串；””代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。 NULL代表声明了一个空对象,对空对象做任何操作都不行的,除了=和==；””是一个字符串了,只是这个字符串里面没有内容了 String s=null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指乡任何内存空间 String s=&quot;&quot;;这个引用已经指向了一块是空字符串的内存空间，是一个实际的东西。 String s=null;//null是未分配堆内存空间 String a;//分配了一个内存空间,没存入任何对象 String a=&quot;&quot;;//分配了一个内存空间,存了一个字符串对象 问题二： String s;和String s=null;和String s=”a”;有什么区别？ 针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a，这是为什么呢？这三句声明语句，各自作了什么呢？ 第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。 第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了 主要要理解的是String s; s为一个引用，它不是对象 第一个是没有初始化的引用； 第二个为空引用； 第三个是在字符串池里写入一个字符’a’,然后用s指向它。 另外， String s=”a”和String s=new String(“a”);是有本质上的区别的；前者是在字符串池里写入一个字符’a’,然后用s指向它；后者是在堆上创建一个内容为”a”的字符串对象。 String str=&quot;aaa&quot;; //于栈上分配内存 String str=new String(&quot;aaa&quot;); //于堆上分配内存 String s; 系统会自动赋值null String s;只是给s分配一个内存空间 String s=null;是分配的空间中存储的值为空值 String s=&quot;a&quot;;这句就不用我多说了分配的空间的值为字符a 问题三： 声明了一个string a;变量 在以后的判断中，a==””和a==null有何不同? 如果没有给a赋过值，a==””会导致异常。 在实际处理时，往往认为””和null代表相同的含义，即都代表无值。 此时建议用如下语法： if(a==null || a==&quot;&quot;) { } 如果a为null，就不会执行后面的判断，直接返回true；null是用来判断引用类型是否分配了存储空间 ，””是针对字符串的。string类型实际上是字符串指针，也即是一个引用类型 所以如果没有给a赋过值，a==””会导致异常 问题四： String abc=null;String abc=””;String abc;三种写法有什么区别？1：创建一个空字符串对象。2：创建一个字符串为空的字符串对象。3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存 对于最后一种表示,你不能if(abc==null),或者int length = abc.length();编译的时候会提示可能没有初始化。 String abc=null; String abc=&quot;&quot;; 一般推荐使用第二种。 第一种abc指向null，很多时候要判断字符串是否为空时，容易漏掉这种情况，在调用String的相关方法的时候就会出错 第二种则相对简单，String的方法都可以用，判断的时候也不会出错。 1) String abc=null; 2) String abc; 3）String a=&quot;&quot;; 4) String b=&quot;&quot;; 5) String c=new String(&quot;&quot;); 6) String d=new String(&quot;&quot;); //1)等于2），和C语言不同，**JAVA为安全原因不允许一个悬挂引用，没有赋值的引用地址一律自动赋值为NULL，以防止访问到任意内存 ** //3)和4)中,变量a和b将会指向同一内存地址(&quot;&quot;的地址) //5)和6)中，变量c和d不会指向同一地址,而是两个&quot;&quot;内容的地址,并且和a,b不同,实际上,3)和4)相当于new String(&quot;&quot;).intern(). //String类维护着一个字符串池,对于像3)和4)这样的赋值方法,String会在这个池中查找字符串是否已经在池中,如果在,就直接指向该地址, //如果不在,生成一个实例放入池中再指向那个地址,可见对于同样内容的字符串多次引用时3)4)的方法要比5)6)的方法剩内存,之所以这样做,是因为String是一个内容不可变的量,运用的是设计模式GOF.FlyWeight 但有个关键的一点,这就是: String s;在什么情况下可以等同于String s=null;而在什么情况下又不等同？ 考虑下面的代码: //StringTest.java public class StringTest { static String s; //１ public static void main(String[] args) { //String s; //２ System.out.println(s); } } 编译并运行上面的代码,将打印null。 可见标有１号的行是自动初始化了的(s被自动初始化为null)。 而如果把标有２号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。由此得出结论： 在成员变量的定义中,String s;等同于String s=null; 而在本地变量(方法变量)的定义中,String s;不等同于String s=null;,这时要使用s必须显式地赋值。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[]},{"title":"Java反射机制","slug":"Java反射机制","date":"2017-02-16T13:27:01.000Z","updated":"2017-02-19T13:31:47.210Z","comments":true,"path":"2017/02/16/Java反射机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/16/Java反射机制/","excerpt":"","text":"最近在学习Spring的AOP，即面向切面编程，在前些时间我用静态代理的模式演绎了代理设计模式，Java本身有一个反射机制，就是在运行期间确定类，Spring关于AOP的底层实现其中有一个模块就是JDK的动态代理，那么今天就来系统整理一下关于Java的反射机制。 一、什么是反射？ 反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。 程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java反射框架主要提供以下功能：1.在运行时判断任意一个对象所属的类；2.在运行时构造任意一个类的对象；3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；4.在运行时调用任意一个对象的方法 二、反射的基本运用1、获得Class对象 有三种方法： (1)使用Class类的forName静态方法: /* * 获取字节码对象的方式： * 1，Object类中的getClass()方法的。 * 想要用这种方式，必须要明确具体的类，并创建对象。 * 麻烦 . * */ public static void getClassObject_1(){ Person p = new Person(); Class clazz = p.getClass(); Person p1 = new Person(); Class clazz1 = p1.getClass(); System.out.println(clazz==clazz1); } (2)直接获取某一个对象的class /* * 方式二： * 2，任何数据类型都具备一个静态的属性.class来获取其对应的Class对象。 * 相对简单，但是还是要明确用到类中的静态成员。 * 还是不够扩展。 * */ public static void getClassObject_2(){ Class class1 = Person.class; Class class2 = Person.class; System.out.println(class1==class2); } (3)调用某个对象的getClass()方法 /* * 方式三： * 只要通过给定的类的 字符串名称就可以获取该类，更为扩展。 * 可是用Class类中的方法完成。 * 该方法就是forName. * 这种方式只要有名称即可，更为方便，扩展性更强。 */ public static void getClassObject_3() throws ClassNotFoundException{ String className = &quot;Reflect.Person&quot;; Class clazz = Class.forName(className); System.out.println(clazz); } 附上Person.java public class Person { private int age; private String name; public Person(int age, String name) { super(); this.age = age; this.name = name; System.out.println(&quot;Person param run...&quot;+this.name+&quot;:&quot;+this.age); } public Person() { super(); System.out.println(&quot;Person run...&quot;); } public void show(){ System.out.println(name+&quot;....show run...&quot;+age); } public void paramMethod(String str,int num){ System.out.println(&quot;paramMethod run.....&quot;+str+&quot;:&quot;+num); } } 2、判断是否为某个类的实例 用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法： public native boolean isInstance(Object obj); 3、创建实例 通过反射来生成对象主要有两种方式。（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。 public static void createNewObject() throws ClassNotFoundException, InstantiationException, IllegalAccessException{ //早期：new时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存， // 并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象. // cn.itcast.bean.Person p = new cn.itcast.bean.Person(); //现在： String name = &quot;Reflect.Person&quot;; //找寻该名称类文件，并加载进内存，并产生Class对象。 Class clazz = Class.forName(name); //如何产生该类的对象呢？ Object obj = clazz.newInstance(); System.out.println(obj); } （2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。 public static void createNewObject2() throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { /* * 当获取指定名称对应类中的所体现的对象时， * 而该对象初始化不使用空参数构造该怎么办呢？ * 既然是通过指定的构造 函数进行对象的初始化， * 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。 * 该方法是：getConstructor(paramterTypes); * */ String name = &quot;Reflect.Person&quot;; //找寻该名称类文件，并加载进内存，并产生Class对象。 Class clazz = Class.forName(name); //获取到了指定的构造函数对 象。 Constructor constructor = clazz.getConstructor(int.class,String.class); //通过该构造器对象的newInstance方法进行对象的初始化。 Object obj = constructor.newInstance(38,&quot;小明&quot;); System.out.println(obj); } 4、获取方法 获取某个Class对象的方法集合，主要有以下几个方法： getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 5、获取构造器信息 获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例: public T newInstance(Object ... initargs) 此方法可以根据传入的参数来调用对应的Constructor创建对象实例 6、获取类的成员变量（字段）信息 getFiled: 访问公有的成员变量 getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量。 7、调用方法 当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为: public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 代码示例如下： public class ReflectDemo4 { public static void main(String[] args) throws Exception { getMethodDemo_2(); } public static void getMethodDemo_2() throws Exception { Class clazz = Class.forName(&quot;Reflect.Person&quot;); Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class,int.class); Object obj = clazz.newInstance(); method.invoke(obj, &quot;小强&quot;,89); } public static void getMethodDemo_1() throws Exception{ Class clazz = Class.forName(&quot;Reflect.Person&quot;); Method method = clazz.getMethod(&quot;show&quot;, null);//获取空参数一般方法。 Constructor constructor = clazz.getConstructor(int.class,String.class); Object o = constructor.newInstance(89,&quot;小明&quot;); method.invoke(o, null); } /* * 获取指定Class中的所有公共函数。 */ public static void getMethodDemo() throws Exception { Class clazz = Class.forName(&quot;Reflect.Person&quot;); Method[] methods = clazz.getMethods();//获取的都是公有的方法。 methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。 for(Method method : methods){ System.out.println(method); } } } 8、取消权限，将细节全暴露 调用Field.setAccessible(true)：暴力访问，可访问全部私有变量。 public class ReflectDemo3 { public static void main(String[] args) throws Exception { getFieldDemo(); } /* * 获取字节码文件中的字段。 */ public static void getFieldDemo() throws Exception { Class clazz = Class.forName(&quot;Reflect.Person&quot;); Field field = null;//clazz.getField(&quot;age&quot;);//只能获取公有的， field = clazz.getDeclaredField(&quot;age&quot;);//只获取本类，但包含私有。 //对私有字段的访问取消权限检查。暴力访问。 field.setAccessible(true); Object obj = clazz.newInstance(); field.set(obj, 89); Object o = field.get(obj); System.out.println(o); // cn.itcast.bean.Person p = new cn.itcast.bean.Person(); // p.age = 30; } } 三、反射的基本例子 学习了反射，为了了解优越性，我们假定一台电脑，每当添加一个设备时，我们将这些设备抽象为一个接口，当添加一个设备时，只需让该设备实现接口，并将该接口信息写入properties文件中读取即可，这个过程并不需要修改代码，只许修改配置文件即可，那么下面介绍代码： PCI接口： public interface PCI { public void open(); public void close(); } 电脑主机: public class MainBoard { public void run(){ System.out.println(&quot;MainBoard run.......&quot;); } public void usePCI(PCI p){ p.open(); p.close(); } } 网卡： public class NetCard implements PCI { @Override public void open() { System.out.println(&quot;NetCard run......&quot;); } @Override public void close() { System.out.println(&quot;NetCard close...&quot;); } } 声卡： public class SoundCard implements PCI { @Override public void open() { System.out.println(&quot;SoundCard run......&quot;); } @Override public void close() { System.out.println(&quot;SoundCard close......&quot;); } } 测试文件： public class ReflectTest { public static void main(String[] args) throws Exception { MainBoard mb = new MainBoard(); mb.run(); File configFile = new File(&quot;pci.properties&quot;); Properties prop = new Properties(); FileInputStream fis = new FileInputStream(configFile); prop.load(fis); for(int i=0;i&lt;prop.size();i++){ String pciName = prop.getProperty(&quot;pci&quot;+(i+1)); Class clazz = Class.forName(pciName); PCI p = (PCI) clazz.newInstance(); mb.usePCI(p); } fis.close(); } } 配置文件pci.prtperties： pci1 = Reflect.test.NetCard pci2 = Reflect.test.SoundCard 这样我们添加设备，不需要修改代码，只需在配置文件中修改代码即可。 是不是很熟悉，Spring框架为我们提供配置文件，我们只需在配置文件中写类的名称，然后Spring利用反射机制为我们建立实体类及依赖关系，这种动态机制为我们开发者开发提供了方便。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://fengjiaxin.github.io/tags/反射/"}]},{"title":"Set中hashCode学习","slug":"Set中hashCode()学习","date":"2017-02-10T00:48:25.000Z","updated":"2017-02-12T13:02:00.020Z","comments":true,"path":"2017/02/10/Set中hashCode()学习/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/10/Set中hashCode()学习/","excerpt":"","text":"我在复习Set的时候，知道Set集合中的元素不重复，是利用对象的hashCode()方法保证的，我本身也学过数据结构的hash表，但是本着不撞南墙不死心的态度，我决定总结一下hash算法并分析Java中的hashCode()究竟是怎么一回事。 Hash表： Hash表也称散列表，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。 1.设计思想： Hash表采用一个映射函数 f : key —&gt; address 将关键字映射到该记录在表中的存储位置，从而在想要查找该记录时，可以直接根据关键字和映射关系计算出该记录在表中的存储位置，通常情况下，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置(注意这里的存储位置只是表中的存储位置，并不是实际的物理地址)称作为Hash地址。 2.构造方法：1)直接定址法 取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000作为Hash地址。 2)平方取中法 对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。 3)折叠法 将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。 4)除留取余法 如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。在这里p的选取非常关键，p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。 3.Hash表大小的确定 Hash表大小的确定也非常关键，如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费，如果选取小了的话，则容易造成冲突。在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。 4.冲突的解决 在上述例子中，发生了冲突现象，因此需要办法来解决，否则记录无法进行正确的存储。通常情况下有2种解决办法： 1)开放定址法 即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法； 比如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash表长为14，Hash函数为address(key)=key%11，当插入12，13，25时可以直接插入，而当插入23时，地址1被占用了，因此沿着地址1依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将23插入其中。 2)链地址法 采用数组和链表相结合的办法，将Hash地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如上述例子中，采用链地址法形成的Hash表存储表示为： 虽然能够采用一些办法去减少冲突，但是冲突是无法完全避免的。因此需要根据实际情况选取解决冲突的办法。 5.Hash表的平均查找长度 Hash表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。 查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数； 查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，再除以表长即为查找不成功时的平均查找长度。 下面举个例子： 有一组关键字{23，12，14，2，3，5}，表长为14，Hash函数为key%11，则关键字在表中的存储如下： 地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 关键字 23 12 14 2 3 5 比较次数 1 2 1 3 3 2 因此查找成功时的平均查找长度为(1+2+1+3+3+2)/6=11/6； 查找失败时的平均查找长度为(1+7+6+5+4+3+2+1+1+1+1+1+1+1)/14=38/14； 这里有一个概念装填因子=表中的记录数/哈希表的长度，如果装填因子越小，表明表中还有很多的空单元，则发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。因此，Hash表的平均查找长度和装填因子有关。 6.Hash表的优缺点 Hash表存在的优点显而易见，能够在常数级的时间复杂度上进行查找，并且插入数据和删除数据比较容易。但是它也有某些缺点，比如不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。 到这里Hash表我也复习的差不多，那我开始分析Object对象的hashCode()方法和set中的HashCode()方法： 一、java对象的比较 等号(==)：对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等； equals()：对比两个对象实例是否相等；当对象所属的类没有重写根类Object的equals()方法时，equals()判断的是对象实例的ID（内存地址），是否是同一对象实例；该方法就是使用的等号(==)的判断结果。 当对象所属的类重写equals()方法（可能因为需要自己特有的“逻辑相等”概念)时，equals()判断的根据就因具体实现而异，有些类是需要比较对象的某些指或内容，如String类重写equals()来判断字符串的值是否相等。判断逻辑相等。 hashCode(): 计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 查看Object类中的hashCode()方法源代码： public native int hashCode(); 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的；所以native关键字的函数都是操作系统实现的，java只能调用。 默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。 二、hashCode的作用 Java中的集合（Collection）有两类，一类是List，再有一类是Set。后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 Java采用了哈希表的原理，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值，然后将哈希值和集合长度进行&amp;运算，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就表示发生冲突，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。 这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！ 三、Java 对象的equal方法和hashCode方法的关系 Java对象相同指的是两个对象通过eqauls方法判断的结果为true Java对象的eqauls方法和hashCode方法是这样规定的： 相等的对象必须具有相等的哈希码（或者散列码）。 如果两个对象的hashCode相同，它们并不一定相同。 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。 关于第二点，两个对象的hashCode相同，它们并不一定相同 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 总结： 绑定：当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 绑定原因：Hashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。 默认： ==默认比较对象在JVM中的地址。 hashCode 默认返回对象在JVM中的存储地址。 equal比较对象，默认也是比较对象在JVM中的地址，同==","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"hashCode","slug":"hashCode","permalink":"https://fengjiaxin.github.io/tags/hashCode/"}]},{"title":"华为在线笔试总结（一）","slug":"华为在线笔试总结（二）","date":"2017-02-09T10:56:53.000Z","updated":"2017-02-12T12:58:10.012Z","comments":true,"path":"2017/02/09/华为在线笔试总结（二）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/09/华为在线笔试总结（二）/","excerpt":"","text":"在总结之前，我先复习一下有关String对象的知识。 # String类 # String类是final类型的，所以不能被被继承，方法不能被覆盖。它是一个引用数据类型，它的对象是一个字符串，程序中用” “标示的都是字符串。字符串是一个特殊的对象，字符串对象最大的特点是它为一个常量，一经初始化，永远不会改变，这是它跟其它引用数据类型最大的不同之处。 常见的操作方法： 1、获取1.1 字符串中的包含的字符数，也就是字符串的长度； int length（）:获取长度。 （跟数组length的区别） 1.2 根据位置获取位置上某个字符。 char charAt（int index）： 1.3 根据字符获取该字符在字符串中的位置。 int indexOf（int ch）：返回的是ch在字符串中第一次出现的位置。 int indexOf（int ch,int fromIndex）:从fromIndex指定位置开始，获取ch在字符串中的位置。 int indexOf（String str）：返回的是str在字符串中第一次出现的位置。 int indexOf（String str,int fromIndex）:从fromIndex指定位置开始，获取str在字符串中的位置。（str字符串） int lastIndexOf（int ch）：返回指定字符在此字符串中最后一次出现的索引。 2、判断2.1 字符串中是否包含某一个字串。 boolean contains(str);① 2.2 字符串中是否有内容 boolean isEmpty（）;原理就是判断长度是否为0； 2.3 字符串中是否是以指定内容开头。 boolean startsWith（str）; 2.4 字符串中是否是以指定内容结尾。 boolean endsWith（str）; 2.5 判读字符串的内容是否相同，复写了Object类中的equals方法。 boolean equals（str）； 2.6 判断内容是否相同，并忽略大小写。 boolean equalsIgnoreCase（str）； 3. 转换3.1 将字符数组转成字符串； 构造函数：String（char[]） String（char[]，offset，count）：将字符数组中的一部分转成字符串。 offset起始位置，count取字符的个数。 静态方法： static String copyValueOf(char[]); static String copyValueOf(char[] data,int offset ,int count) static String valueOf(char[]): 3.2 将字符串转成字符数组； char[] toCharArray(); 3.3 将字节数组转成字符串； String（byte[]） String（byte[]，offset，count） 3.4 将字符串转成字节数组; Byte[] getBytes(); 3.5 将基本数据类型转成字符串。 static String valueOf（int） static String valueOf（double） (3+””和String valueOf（3）) 特殊：字符串和字节数组在转换过程中，是可以指定编码表的。 4. 替换String replace（oldchar，newchar）； 5. 切割String[] split（regex）； 6. 字串，获取字符串中的一部分。String substring(begin); String substring(begin,end); 7. 转换，去除空格，比较。7.1 将字符串转成大写或者小写。 String toUpperCase(); String toLowerCase(); 7.2 将字符串两端的多个空格去除。 String trim(); 7.3 对两个字符串进行自然顺序的比较。 Int compareTo(string ); # 接下来就是笔试题： # 扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:)3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR 基本规则：（1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；（2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）（3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；（4）输入的两手牌不会出现相等的情况。 答案提示：（1）除了炸弹和对王之外，其他必须同类型比较。（2）输入已经保证合法性，不用检查输入是否是合法的牌。（3）输入的顺子已经经过从小到大排序，因此不用再排序了. 输入描述: 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。 输出描述: 输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。 输入例子: 4 4 4 4-joker JOKER 输出例子: joker JOKER 注意：本道题目的输入规定是4 4 4 4-joker JOKER要想获取两组字符串正确做法是： Scanner sc = new Scanner(System.in); String[] left,right; String[] line; String nextLine,outString; while(sc.hasNext()) { nextLine = sc.nextLine(); line = nextLine.split(&quot;-&quot;); left = line[0].split(&quot; &quot;); right = line[1].split(&quot; &quot;); //处理业务逻辑 } 那么当牌个数相等时如何比较牌面大小呢？ 一种简单的方法就是获取字符串所在基础字符串的位置 即 private static int count(String str){ return &quot;345678910JOKA2jokerJOKER&quot;.indexOf(str); } 写到这里，基本答案就出来了。 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); String[] left,right; String[] line; String nextLine,outString; while(sc.hasNext()){ nextLine = sc.nextLine(); if(nextLine.contains(&quot;joker JOKER&quot;)) outString = &quot;joker JOKER&quot;; else{ line = nextLine.split(&quot;-&quot;); left = line[0].split(&quot; &quot;); right = line[1].split(&quot; &quot;); if(left.length ==4 &amp;&amp; right.length!=4) outString = line[0]; else if(left.length!=4 &amp;&amp; right.length==4) outString = line[1]; else if(left.length==right.length){ if(count(left[0])&gt;count(right[0])) outString = line[0]; else outString = line[1]; }else{ outString = &quot;ERROR&quot;; } } System.out.println(outString); } } private static int count(String str){ return &quot;345678910JQKA2jokerJOKER&quot;.indexOf(str); } }","categories":[{"name":"笔试总结","slug":"笔试总结","permalink":"https://fengjiaxin.github.io/categories/笔试总结/"}],"tags":[]},{"title":"华为在线笔试总结（一）","slug":"华为在线笔试总结（一）","date":"2017-02-09T10:04:25.000Z","updated":"2017-02-12T12:56:24.719Z","comments":true,"path":"2017/02/09/华为在线笔试总结（一）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/09/华为在线笔试总结（一）/","excerpt":"","text":"在总结之前，我得自身反省一下，明明想法其实已经想的差不多了，但是总差一些细节，尤其关于Scanner类，这个类非常重要，方法一定要记住。 ## Scanner类## 在源码中应该包括下句： import java.util.Scanner; Scanner是新增的一个简易文本扫描器，在 JDK 5.0之前，是没有的。 构造方法： public Scanner(InputStream source) //用指定的输入流来创建一个Scanner对象 方法： public void close() //关闭 public Scanner useDelimiter(String pattern) //设置分隔模式 ,String可以用Pattern取代 public boolean hasNext() //检测输入中，是否，还有单词 public boolean hasNextInt() //检测输入中，是否，还有单词 public String next() //读取下一个单词，默认把空格作为分隔符 public int hasNextInt();查看是否有int类型的token的分割段 public String nextLine() //读行 读取键盘输入 Scanner sc = new Scanner(System.in); while(sc.hasNext()) { //处理业务 } 好了，在了解了一些基本信息后，我们开始看题： 输入包括多组测试数据。每组输入第一行是两个正整数N和M（0 &lt; N &lt;= 30000,0 &lt; M &lt; 5000）,分别代表学生的数目和操作的数目。学生ID编号从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为’Q’的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少；当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 我第一次做题的时候忽略了两点： M限制了查询次数 A、B的大小关系不确定 在了解了这两个陷阱后，代码如下： import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int num = 0; int count = 0; int A=0,B =0; while(sc.hasNext()){ num = sc.nextInt(); count = sc.nextInt(); int[] grade = new int[num]; for(int i=0;sc.hasNext() &amp;&amp; i&lt;num ;i++) grade[i] = sc.nextInt(); String ch = null; for(int i=0;sc.hasNext() &amp;&amp; i&lt;count;i++){ ch = sc.next(); A = sc.nextInt(); B = sc.nextInt(); if(ch.equals(&quot;U&quot;)) grade[A-1] = B; if(ch.equals(&quot;Q&quot;)){ int result = max(grade,A,B); System.out.println(result); } } } } public static int max(int[] array,int begin,int end){ int min = Math.min(begin,end)-1; int max = Math.max(begin,end); int result = array[min]; for(int i =min+1;i&lt;max;i++){ if(array[i]&gt;result) result = array[i]; } return result; } } 总结：在习惯了编辑器后，发现有些代码拼写不正确，还有多练习把！！！","categories":[{"name":"笔试总结","slug":"笔试总结","permalink":"https://fengjiaxin.github.io/categories/笔试总结/"}],"tags":[]},{"title":"排序的Java实现","slug":"排序的Java实现","date":"2017-02-04T12:46:53.000Z","updated":"2017-02-12T12:55:12.116Z","comments":true,"path":"2017/02/04/排序的Java实现/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/04/排序的Java实现/","excerpt":"","text":"数据结构学习了好久，有时候不复习都快忘了，那么今天我就来复习一下内部排序，包括选择排序、插入排序、冒泡排序、归并排序、快速排序、希尔排序、堆排序；然后简单介绍一下各种排序的思想，然后利用Java进行实现；最后比较各算法的优劣。 1、选择排序 基本原理：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮比较，得到较小的记录并与第二个记录的位置进行交换；重复该过程，直到进行比较的记录只有一个时为止。 具体实现： public class TestSelectSort { public static void main(String[] args) { int[] a = {5,4,9,8,7,6,0,1,3,2}; selectSort(a); show(a); } public static void selectSort(int[] a){ int i,j; int temp =0,flag =0; for(i =0;i&lt;a.length;i++){ temp =a[i]; flag =i; for(j =i+1;j&lt;a.length;j++){ if(a[j]&lt;temp){ temp= a[j]; flag =j; } } if(flag!=i){ a[flag] =a[i]; a[i] = temp; } } } public static void show(int[] a){ for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } } 2、插入排序： 基本思想：对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列；接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中，直到最后一个记录插入到有序序列为止。 具体实现： public class TestInsertSort { public static void main(String[] args) { int[] array = {7,3,4,9,10,6}; insertSort(array); for(int i=0;i&lt;array.length;i++) System.out.print(array[i]+&quot; &quot;); } public static void insertSort(int[] a){ if(a!=null){ for(int i=1;i&lt;a.length;i++){ int temp = a[i],j =i; if(temp&lt;a[j-1]){ while(j&gt;=1 &amp;&amp; temp&lt;a[j-1]){ a[j] = a[j-1]; j--; } } a[j] = temp; } } } } 3、冒泡排序 基本思想：对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行第一轮比较和换位后，n个记录最大的记录位于第n位；然后对前(n-1)个记录进行第二轮比较；重复该过程直到进行比较的记录只剩下一个为止。 具体实现： public class TestBubbleSort { public static void main(String[] args) { int[] array = {4,2,9,10,8,6}; BubbleSort(array); for(int i=0;i&lt;array.length;i++){ System.out.print(array[i]+&quot; &quot;); } } public static void BubbleSort(int[] a){ int i,j,temp,len = a.length; for( i=0;i&lt;len-1;i++){ for(j =0;j&lt;len-i-1;j++){ if(a[j]&gt;a[j+1]){ temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } } 4、归并排序 基本思想：对于给定的一组记录（假设共有n个记录），首先将每两个相邻的长度为1的子序列进行归并，得到n/2（向上取整）个长度为2或1的有序子序列，在将其进行两两归并，反复执行此过程，直到得到一个有序序列。 具体实现： public class TestMergeSort { public static void main(String[] args) { int[] a = {5,3,4,2,9,7,6,1}; MergeSort(a, 0, a.length-1); for(int i =0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void Merge(int[] array,int left,int middle,int right){ int i,j,k,n1,n2; n1 = middle-left+1; n2 = right-middle; int[] L = new int[n1]; int[] R = new int[n2]; for(i =0,k =left;i&lt;n1;i++,k++) L[i] = array[k]; for(j =0,k=middle+1;j&lt;n2;j++,k++) R[j] = array[k]; for(k =left,i =0,j =0;i&lt;n1 &amp;&amp; j&lt;n2;k++){ if(L[i]&lt;R[j]) array[k] = L[i++]; else array[k] = R[j++]; } //没有再声明一个变量是因为一下两种情况只会出现一种情况。 if(i&lt;n1){ for(j =i;j&lt;n1;j++,k++) array[k] =L[j]; } if(j&lt;n2){ for(i =j;i&lt;n2;i++,k++) array[k] =R[i]; } } public static void MergeSort(int[] array,int left,int right){ if(left&lt;right){ int middle = (left+right)/2; MergeSort(array, left, middle); MergeSort(array,middle+1,right); Merge(array,left,middle,right); } } } 5、快速排序 基本思想：对于一组给定的记录，通过一趟排序后，将原序列分为两个部分，其中前一部分的所有记录均比后一部分的所有记录小，然后再依次对前后两部分的记录进行快速排序，递归该过程，直到序列中的所有记录均有序为止。 具体实现： public class TestQuickSort { public static void main(String[] args) { int[] a = {5,3,2,9,7,6,1}; quickSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void sort(int[] array,int low,int high){ int i,j,index; if(low&gt;=high) return; i =low; j = high; index = array[low]; while(i&lt;j){ while(i&lt;j &amp;&amp; array[j]&gt;index) j--; if(i&lt;j) array[i++] = array[j]; while(i&lt;j &amp;&amp; array[i]&lt;index) i++; if(i&lt;j){ array[j--] = array[i]; } } array[i] = index; sort(array,low,i-1); sort(array,i+1,high); } public static void quickSort(int[] array){ sort(array,0,array.length-1); } } 6、希尔排序 基本思想：先将待排序的的数组元素分成多个子序列，使得整个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，代整个待排序序列“基本有序后”，最后在对所有元素进行一次直接插入排序。 具体实现： public class TestShellSort { public static void main(String[] args) { int[] a = {5,3,2,9,7,6,1}; shellSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void shellSort(int[] array){ int len = array.length; int i,j,h;//h为步长 int temp; for(h =len/2;h&gt;0;h/=2){ for(i =h;i&lt;len;i++){//从每组至少第二个元素开始遍历 temp = array[i]; for(j=i-h;j&gt;=0;j-=h){ if(temp&lt;array[j]) array[j+h] = array[j]; else break; } array[j+h] = temp; } } } } 7、堆排序 基本思想：对于给定的n个记录，初始时把这些记录看做一颗顺序存储的二叉树，然后将其调整为一个最大堆，然后将堆的最后一个元素和堆顶元素进行交换，堆的最后一个元素即为最大记录；接着将前（n-1）个元素重新调整为一个最大堆，在将堆顶元素和最后一个元素进行交换得到次的的记录，重复该过程直到调整的堆中只剩下一个元素为止，该元素为最小记录，此时得到一个有序序列。 具体实现： public class TestHeapSort { public static void main(String[] args) { int[] a = {4,3,2,7,6,5}; heapSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void adjustHeap(int[] a,int pos,int len){ int temp; int child; for(temp = a[pos];2*pos+1&lt;=len;pos = child){ child = 2*pos+1; if(child&lt;len &amp;&amp; a[child+1]&gt;a[child]) child++; if(a[child]&gt;temp) a[pos] = a[child]; else break; } a[pos] = temp; } public static void heapSort(int[] array){ int i; int len = array.length; for(i=len/2-1;i&gt;=0;i--) adjustHeap(array, i, len-1); for(i = len-1;i&gt;=0;i--){ int temp = array[0]; array[0] = array[i]; array[i] = temp; adjustHeap(array, 0, i-1); } } } 8、这7种排序算法的比较","categories":[{"name":"JAVA数据结构","slug":"JAVA数据结构","permalink":"https://fengjiaxin.github.io/categories/JAVA数据结构/"}],"tags":[]},{"title":"JAVA多线程（二）","slug":"JAVA多线程（二）","date":"2017-02-04T10:41:27.000Z","updated":"2017-02-04T11:44:08.110Z","comments":true,"path":"2017/02/04/JAVA多线程（二）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/04/JAVA多线程（二）/","excerpt":"","text":"接着上篇博客继续，还有一些多线程的概念，我以前也没听过，正好整理学习一下，加油！！ 1、sleep()方法与wait()方法的不同？ 区别主要显示在一下几个方面： 原理不同，sleep()方法时Thread的静态方法，是线程控制自身流程的，会让此线程暂停一段时间，把机会让给其他线程；而wait()方法时Object的方法，用于线程见的通信，这个方法会使拥有该对象锁的进程等待，直到其他线程调用notify()方法。 对锁的处理机制不同，sleep()方法不涉及线程间通信，不释放锁，而wait()会释放掉它所占用的锁，从而使线程所在对象的其他synchronized数据可被别的线程使用。 使用区域不同，sleep()可以在任何地方使用，而wait()方法必须放在同步控制方法或语句块中使用；除此之外，sleep()方法必须捕获异常，而wait()方法不需要，在sleep()过程中，有可能被其他对象调用它的interrupt(),产生interruptedException异常。 那么扩展一下：sleep()和yield()有什么区别？ sleep()给其他线程运行机会时不考虑线程的优先级，而yield()只给相同优先级或更高优先级的线程运行的机会。 线程执行sleep()后转入阻塞状态，所以在休眠的时间段内肯定不会被执行；但是yield()只是使当前线程重新回到可执行状态，所以可能执行yield()后进入到可执行状态后马上又被执行。 sleep()方法抛出InterruptedException，而yield()没有声明任何异常。 sleep()方法比yield()有更好地可移植性（操作系统方面）。 2、终止线程的方法？ stop()和suspend()方法。 stop()方法释放已经锁定的所有监视资源，suspend()不会释放锁。这两种方式都不安全，一般建议让线程自行结束进入Dead状态；在学习这个方法前，先补充一下基础知识。 关键字volatile,类型修饰符，系统每次用它时都是直接从内存中读取，而不是从缓存中读取。 那么建议方式是通过设置flag()标志来控制循环是否执行，通过这种方法来让线程离开run()方法从而终止线程。 实例代码如下： public class MyThreadStop implements Runnable { private volatile Boolean flag; public void stop(){ flag = false; } @Override public void run() { while(flag){ //执行 } } } 在上例中，调用stop()虽然能够终止线程，但是，当线程处于非运行状态时，这个方法就不可用啦，此时可以使用interrupt()方法来打破阻塞的情况，当interrupt()被调用时，会抛出interruptedException异常，可以通过在run()方法中来捕获这个异常让线程安全退出。 示例代码如下： public class MYThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread go to sleep&quot;); try { Thread.sleep(5000); System.out.println(&quot;thread end&quot;); } catch (InterruptedException e) { //e.printStackTrace(); System.out.println(&quot;thread is interupted&quot;); } } }); thread.start(); thread.interrupt(); } } 运行结果如下： thread go to sleep thread is interupted 3、什么是守护线程？ 守护线程是指程序在运行时在后台提供一种通用服务的线程，用户线程跟守护线程的差别在：如果用户线程已经全部退出运行，只剩下守护线程存在，JVM也就退出了。 在Java中，守护线程一般具有较低的优先级，它可以由用户设置，方法就是在调用start()前调用对象的setDaemon(true)方法，注意：当在一个守护线程中产生了其他线程，那么这些新产生的线程默认还是守护线程。 说了这么多，代码实战一下更加清晰明了： class ThreadJoin extends Thread{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;:begin&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;:end&quot;); } } public class ThreadJoinDemo { public static void main(String[] args) { System.out.println(&quot;test:begin&quot;); Thread t1 = new ThreadJoin(); t1.setDaemon(true); t1.start(); System.out.println(&quot;test:end&quot;); } } 运行结果： test:begin test:end Thread-0:begin 其中守护线程最典型的的一个例子就是垃圾回收器，只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源。 4、join()方法的作用是什么？ join()的作用是让调用该方法的线程在执行完run()方法后，再执行join()方法后面的代码。简单来说就是将两个线程合并，实现同步的功能；具体就是可以通过线程A的join()方法来等待线程A的结束，或者使用线程A的join(2000)方法来等待线程A的结束，但最多只等2s。 来，写个代码实例把： public class JoinTest { public static void main(String[] args) { Thread t = new Thread(new ThreadImp()); t.start(); try { t.join(1000); if(t.isAlive()){ System.out.println(&quot;t has not finished&quot;); }else{ System.out.println(&quot;t has finished&quot;); } System.out.println(&quot;joinFinish&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } class ThreadImp implements Runnable{ @Override public void run() { System.out.println(&quot;ThreadImp begin:&quot;); try { Thread.sleep(5000); System.out.println(&quot;ThreadImp end:&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果如下： ThreadImp begin: t has not finished joinFinish ThreadImp end: 到这里，关于线程的知识差不多整理完毕，有很多知识我也是重新学习了一遍，代码重新编写一次，写了这么多可真累，不过以后再捡起来就相对容易些了，先记录这些吧，以后再有新知识，新感悟在补充。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://fengjiaxin.github.io/tags/多线程/"}]},{"title":"JAVA多线程（一）","slug":"JAVA多线程（一）","date":"2017-02-03T12:42:34.000Z","updated":"2017-02-04T10:40:29.378Z","comments":true,"path":"2017/02/03/JAVA多线程（一）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/JAVA多线程（一）/","excerpt":"","text":"在上学期学习了操作系统的相关知识，首先学的就是进程与线程的知识概念，但是linux操作系统是用c语言编写的，并且关于线程的代码太底端，平时做题也是运用伪代码来写的，那么今天在整理Java多线程的相关知识的同时，正好与之前学习的操作系统知识相结合，那么这篇文章主要介绍一下多线程的Java实现。 1、线程与进程的概念 线程是指程序在执行过程中，能够执行程序代码的一个执行单元，在Java语言中有四种状态：运行、就绪、挂起、结束。 进程是指一段正在执行的程序，而线程有时成为轻量级进程，是程序执行的最小单元，一个进程可以有多个线程，各个线程之间共享程序的内存空间（代码段、数据段、堆空间）以及一些进程级的资源，但是各个线程拥有自己的栈空间。 在网上找到一个图片很合适的表现的进程与线程的对比关系，图如下： 在操作系统级别上，程序的执行都是以进程为单位，每个进程通常有多个线程互不影响并发的执行，那么为什么使用多线程呢？ 使用多线程可以减少程序的响应时间。 与进程相比，线程的创建和切换开销更小。 多CPU或多核计算机本身就具有执行多线程的能力。 使用多线程能简化程序的结构，使程序便于理解和维护。 2、同步和异步的区别？ 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 3、如何实现JAVA多线程？ Java虚拟机允许应用程序并发的运行多个线程，在Java中，一共有三种实现方式，那么根据我的掌握程度，我只写前两个实现方式。 继承Thread类，重写run()方法 声明实现Runnable接口类，并实现run()方法。 对于方式一： 启动线程的唯一方法就是通过Thread的start()方法。start()方法是一个本地方法，将启动一个新线程，并执行run()方法；需要注意的是：调用start()方法是使得该线程变为可运行状态，什么时候运行线程代码是由操作系统决定。 代码示例如下： class Demo extends Thread { private String name; Demo(String name)//构造函数 { //this.name = name; super(name); } public void run()//复写run方法 { for ( int i = 0 ; i &lt; 60 ; i++ ) { System.out.println(Thread.currentThread().getName()+&quot;run=&quot;+i); } } } public class ThreadExtendsDemo { public static void main(String[] args) { Demo t1 = new Demo(&quot;one&quot;);//创建一个对象t1 Demo t2 = new Demo(&quot;two&quot;); t1.start();// 通过调用start方法，开启多线程 t2.start(); run(); } private static void run() { for(int i =0;i&lt;60;i++) System.out.println(&quot;main&quot; +i); } } 需要注意的是： t1.start()开启线程并执行该线程的run方法。 t1.run()仅仅是对象调用方法。而线程创建了，并没有运行。还是在主线程的运行中。 对于方式二： 首先定义类实现Runnable接口，实现run()方法；然后创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象；最有调用Thread的start()方法。 代码示例如下： class MyThread implements Runnable{ @Override public void run() { System.out.println(&quot;Thread Body&quot;); } } public class ThreadImmDemo { public static void main(String[] args) { MyThread thread = new MyThread(); Thread t = new Thread(thread); t.start(); } } 其实，不管是通过继承Thread类还是通过实现Runnable接口来实现多线程的方法，最终还是通过Thread对象的API来控制线程。 在学习了这两种方式实现多线程，那么有一个问题：一个类是否可以同时继承Thread类并实现Runnable接口？ 答案是可以的;代码示例如下： public class Test extends Thread implements Runnable { public static void main(String[] args) { Thread t = new Thread(new Test()); t.start(); } } 上面这段代码是可以编译通过的，因为Test类从Thread类继承了run()方法，这个继承的run()方法可以被当做对RUnnable接口的实现，因此此段代码可以编译通过。 4、run()方法和start()方法的区别？ 通常，系统通过调用线程类的start()方法来启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以被JVM来调度执行；在调度过程中，JVM通过调用线程类的run()方法来完成实际的操作，当run()方法结束后，此线程就会终止。 如果直接调用run()方法，这会别当做一个普通的函数调用，程序中仍然只有主线程这一个线程；由此可知，只有通过调用线程类的start()方法才能真正达到多线程的目的。 5、多线程同步的实现方法？Java主要提供了3种实现同步机制的方法： 1 synchronized关键字 在Java中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的一段synchronized代码时，需要先获取这个锁，然后去执行相应的代码，执行结束后，释放锁。 synchronized关键字有两种用法：synchronized方法和synchronized块，此外，该关键字可以用作于静态方法、类、或某个实例。 讲解了这么多，我编写一个买票程序，使用两个线程买票，一个线程在同步块中，一个线程在同步函数中，代码实例如下： class Ticket implements Runnable{ private int ticket =100; boolean flag = true; @Override public void run() { if(flag){ while(true){ synchronized (this) { if(ticket&gt;0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;runs=&quot;+ticket--); } catch (InterruptedException e) { e.printStackTrace(); } } } } } else{ show(); } } private synchronized void show() { while(true){ if(ticket&gt;0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;show =&quot;+ticket--); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public class TicketDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } t.flag = false; t2.start(); } } 那么如果同步函数被static修饰后，使用的锁是什么呢？我们知道静态进内存时一定没有本类对象，但一定有该类对应的字节码文件对象，即类.class,实在不行，我们创建一个对象，Object obj = new Objext();然后利用obj锁。 2 wait()和notify()方法 在synchronized代码被执行期间，线程可以通过调用对象的wait()方法，释放对象锁，进入等待状态，并且可以调用notify()或notifyAll()方法通知正在等待的其他线程。其中，notify()方法仅唤醒一个线程（等待队列的第一个线程），并允许它去获得锁；notifyAll()方法唤醒所有等待这个对象的线程并允许他们获得锁（让这些线程竞争获得）。 接下来编写一个生产者消费者的实例，代码实例如下： public class ProducerConsumerDemo { public static void main(String[] args) { Resource res = new Resource(); Producer pro = new Producer(res); Consumer con = new Consumer(res); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } class Resource{ private String name ; private int count =1; private boolean flag = false;//true代表有产品，false代笔没有产品 //生产 public synchronized void set(String name){ while(flag){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } this.name = name; System.out.println(Thread.currentThread().getName()+&quot;...生产者&quot;+this.name); flag = true; this.notifyAll(); } //消费 public synchronized void out(){ while(!flag){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName()+&quot;...消费者&quot;+this.name); flag = false; this.notifyAll(); } } class Producer implements Runnable{ private Resource res; Producer(Resource res){ this.res = res; } @Override public void run() { while(true){ res.set(&quot;商品&quot;); } } } class Consumer implements Runnable{ private Resource res; Consumer(Resource res){ this.res = res; } @Override public void run() { while(true){ res.out(); } } } 3 Lock JDK5后新增了Lock接口以及一个实现类ReentrantLock(重入锁)，我也第一次接触，好好学习一下，Lock也可以用来实现多线程的同步，它提供一些放法实现多线程的同步： 1 lock():以阻塞的方式获取锁，即如果获取到了锁，立即返回，如果别的线程持有锁，当前线程等待，直到获取锁后返回。 2 tryLock():以非阻塞的方式来获取锁，只是试探获取，如果获取到锁，立即返回true,否则返回false。 3 lockInterruptibly():如果获取到了锁，立即返回，否则，当前线程处于休眠状态，直到获得锁，注意：如果当前线程被别的线程中断，会收到InterruptedException异常。 先总结到这里，没想到写了这么多还有很多没写完，那么只好再写一篇啦。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://fengjiaxin.github.io/tags/多线程/"}]},{"title":"finally块中的代码什么时候被执行","slug":"finally块中的代码什么时候被执行","date":"2017-02-03T10:08:53.000Z","updated":"2017-02-12T03:52:13.137Z","comments":true,"path":"2017/02/03/finally块中的代码什么时候被执行/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/finally块中的代码什么时候被执行/","excerpt":"","text":"在上篇文章明白异常处理机制后，我们知道一般捕获异常用try/catch,一般情况下会有finally块，那么今天我就整理一下finally代码块的相关知识。 那么我们提出一个问题：try{}里有一个return语句，那么紧跟try的finally{}的代码是否会被执行？如果会的话，什么时候被执行，在return前还是return后？ 解答：在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally中的代码一定会被执行，因此任何语句要执行都只能在return前执行（除非碰到exit函数），因此finally块中的代码在return前执行。此外，如果try-finally或catch-finally中都有return,那么finally块中的return语句将会覆盖别处的return语句，最终返回到调用者那里的是finally中的return值。 代码示例如下： public class TestFinally1 { public static int testfinally(){ try{ return 1; }catch(Exception e){ return 0; }finally{ System.out.println(&quot;execute finally&quot;); } } public static void main(String[] args) { int result = testfinally(); System.out.println(result); } } 结果运行如下： execute finally 1 从上面的例子中可以看出，在执行return语句之前确实执行了finally块中的代码；那么如果在finally块中放置return语句，会不会覆盖呢？ 代码示例如下： public static int testfinally2(){ try { return 1; } catch (Exception e) { return 0; }finally{ System.out.println(&quot;execute finally2&quot;); return 3; } } public static void main(String[] args) { int result = testfinally2(); System.out.println(result); } 结果运行如下： execute finally2 3 从上面的例子中可以看出，当finally块中有return语句时，将会覆盖函数中其它return语句；此外，由于在一个方法体中内部定义的变量都存储在栈中，在这个函数结束后，其对应的栈会被回收，此时在其方法体中定义的变量将不存在了，因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。因此，对于基本类型的数据，在finally块中改变return的值对返回值没有任何影响，而对引用类型的数据会有影响。 代码示例如下： public class TestReturn { public static int testFinally1(){ int result =1; try{ result =2; return result; }catch(Exception e){ return 0; }finally{ result = 3; System.out.println(&quot;excuate testFinally1&quot;); } } public static StringBuffer testFinally2(){ StringBuffer s = new StringBuffer(&quot;hello&quot;); try{ return s; }catch(Exception e){ return null; }finally{ s.append(&quot; world&quot;); System.out.println(&quot;excuate testFinally2&quot;); } } public static void main(String[] args) { System.out.println(testFinally1()); System.out.println(testFinally2()); } } 结果运行如下： excuate testFinally1 2 excuate testFinally2 hello world 解析：程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后在返回。 在testFinally1()方法调用return前，先把result的值1存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值将不会影响到程序的返回结果。 testFinally2()中，在调用return前先把s存储在一个指定的位置，由于s为引用类型，因此在finally块中修改s将会修改程序的返回结果。 写了这么多，总结的也应该比较到位，那我在网上找一道相关的面试题进行解答。 出现在Java程序中的finally块是不是一定会被执行？ 答:不一定，以下两种情况都不会。 当程序在进入try{}语句块之前就出现异常，会直接结束。例如在try{}之前有语句int i= 9/0;那么会直接抛出异常，导致没有执行try{}中的代码。 当程序在try{}中强制退出也不会执行。例如在try{System.exit(0)}。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"finally代码块","slug":"finally代码块","permalink":"https://fengjiaxin.github.io/tags/finally代码块/"}]},{"title":"Java异常机制及原理","slug":"Java异常机制及相关问题","date":"2017-02-03T03:48:39.000Z","updated":"2017-02-09T07:31:40.878Z","comments":true,"path":"2017/02/03/Java异常机制及相关问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/Java异常机制及相关问题/","excerpt":"","text":"编写看这么多Java代码，有时候需要对可能出现的异常进行捕捉，有时候直接抛出，懵懵懂懂，那么今天重新看一遍关于Java异常处理机制，进行系统的总结。 1、异常机制概述 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 2 、异常处理的流程 当程序中抛出一个异常后，程序从程序中导致异常的代码处跳出，java虚拟机检测寻找和try关键字匹配的处理该异常的catch块，如果找到，将控制权交到catch块中的代码，然后继续往下执行程序，try块中发生异常的代码不会被重新执行。如果没有找到处理该异常的catch块，在所有的finally块代码被执行和当前线程的所属的ThreadGroup的uncaughtException方法被调用后，遇到异常的当前线程被中止。 3、异常的结构 异常的继承结构：Throwable为基类，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。 ４、Error异常 Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。 5、RuntimeException异常 Exception异常包括RuntimeException异常和其他非RuntimeException的异常。RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。 出现RuntimeException后，系统会把异常一直往上层抛出，知道遇到处理代码为止。若没有处理块，则抛到最上层；如果是多线程就用Thread.run()方法抛出，如果是单线程，就用main()方法抛出。抛出之后，如果是线程，那么这个线程退出了。如果是主程序抛出的异常，那么整个程序就退出了。 6、Checked Exception异常 Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。 7、应该在声明方法抛出异常还是在方法中捕获异常？ 处理原则：捕捉并处理哪些知道如何处理的异常，而传递哪些不知道如何处理的异常。 8、使用finally块释放资源 finally关键字保证无论程序使用任何方式离开try块，finally中的语句都会被执行。在以下三种情况下会进入finally块： try块中的代码正常执行完毕。 在try块中抛出异常。 在try块中执行return、break、continue。 因此，当你需要一个地方来执行在任何情况下都必须执行的代码时，就可以将这些代码放入finally块中。当你的程序中使用了外界资源，如数据库连接，文件等，必须将释放这些资源的代码写入finally块中。 必须注意的是：在finally块中不能抛出异常。JAVA异常处理机制保证无论在任何情况下必须先执行finally块然后再离开try块，因此在try块中发生异常的时候，JAVA虚拟机先转到finally块执行finally块中的代码，finally块执行完毕后，再向外抛出异常。如果在finally块中抛出异常，try块捕捉的异常就不能抛出，外部捕捉到的异常就是finally块中的异常信息，而try块中发生的真正的异常堆栈信息则丢失了。 示例代码如下： Connection con = null; try { con = dataSource.getConnection(); …… } catch(SQLException e) { …… throw e;//进行一些处理后再将数据库异常抛出给调用者处理 } finally { try { con.close(); } catch(SQLException e) { e.printStackTrace(); …… } } 运行程序后，调用者得到的信息如下： java.lang.NullPointerException at myPackage.MyClass.method1(methodl.java:266) 而不是我们期望得到的数据库异常。这是因为这里的con是null的关系，在finally语句中抛出了NullPointerException，在finally块中增加对con是否为null的判断可以避免产生这种情况。 9、在使用异常处理时，还需要注意以下几个问题： Java异常用到了多态的概念，在进行异常捕捉时，先捕捉子类，再捕捉基类的异常信息，否则，捕获子类的代码块永远不会执行。 今早抛出异常，同时对捕捉的异常进行处理；而对于运行时异常，根本不需要理会。 可以根据实际需求自定义异常类，只要继承Exception类即可。 异常能处理就处理，不能处理就抛出。对于一般异常，如果不能进行有效的处理，最好转换为运行时异常抛出，对于最终没有处理的异常，JVM会进行处理。 10、在声明方法时候抛出异常 语法：throws（略） 为什么要在声明方法抛出异常？ 方法是否抛出异常与方法返回值的类型一样重要。假设方法抛出异常却没有声明该方法将抛出异常，那么客户程序员可以调用这个方法而且不用编写处理异常的代码。那么，一旦出现异常，那么这个异常就没有合适的异常控制器来解决。 为什么抛出的异常一定是已检查异常？ RuntimeException与Error可以在任何代码中产生，它们不需要由程序员显示的抛出，一旦出现错误，那么相应的异常会被自动抛出。遇到Error，程序员一般是无能为力的；遇到RuntimeException，那么一定是程序存在逻辑错误，要对程序进行修改；只有已检查异常才是程序员所关心的，程序应该且仅应该抛出或处理已检查异常。而已检查异常是由程序员抛出的，这分为两种情况：客户程序员调用会抛出异常的库函数；客户程序员自己使用throw语句抛出异常。 注意： 覆盖父类某方法的子类方法不能抛出比父类方法更多的异常，所以，有时设计父类的方法时会声明抛出异常，但实际的实现方法的代码却并不抛出异常，这样做的目的就是为了方便子类方法覆盖父类方法时可以抛出异常。 11、在方法中如何抛出异常 语法：throw（略） 抛出什么异常？ 对于一个异常对象，真正有用的信息是异常的对象类型，而异常对象本身毫无意义。比如一个异常对象的类型是ClassCastException，那么这个类名就是唯一有用的信息。所以，在选择抛出什么异常时，最关键的就是选择异常的类名能够明确说明异常情况的类。 异常对象通常有两种构造函数：一种是无参数的构造函数；另一种是带一个字符串的构造函数，这个字符串将作为这个异常对象除了类型名以外的额外说明。 那么总结了这么多，我们做几道题进行热身： 1、Error和Exception有什么区别 答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 2、列出一些你常见的运行时异常？ ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 3、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。 4、TimedOutException不是一个RuntimeException，下面的那些选项载入程序中，使程序可以正常运行？ A public void final() B public void final() throws Exception C public void final() throws TimedOutException D public void final() throw TimedOutException E public throw TimedOutException void final() 答案：BC 试题分析： 如果一个程序在运行时候有异常发生，而这个异常又不是RuntimeException或者Error，那么程序必须对这个异常进行捕获处理或者声明抛出该异常。捕获异常使用try-catch-finally，而声明异常则是在声明方法的同时将会发生的异常进行声明，使用关键字throws。 A项没有使用关键字声明异常，所以是错误的。由于Exception是所有异常的父类，当然也可以代表TimedOutException，所以B项是正确的。C项符合声明异常的格式，是正确的。在D项中，throw是抛出异常，而不是声明异常，关键字使用错误，所以D项是错的。E项的语法格式是错误的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://fengjiaxin.github.io/tags/Exception/"},{"name":"Error","slug":"Error","permalink":"https://fengjiaxin.github.io/tags/Error/"}]},{"title":"如何实现对象的clone","slug":"如何实现对象的clone","date":"2017-02-02T13:38:30.000Z","updated":"2017-02-12T12:53:19.194Z","comments":true,"path":"2017/02/02/如何实现对象的clone/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/如何实现对象的clone/","excerpt":"","text":"有两种方式： 1. 实现Cloneable接口并重写Object类中的clone()方法； Java中所有的类默认继承自Object类，而Object类提供了讴歌clone()方法，这个方法的作用是返回一个Object对象的复制，这个复制函数返回的是一个新的对象而不是一个引用，那么如何使用呢？代码如下： class Obj implements Cloneable{ private int aInt =0; public int getInt(){ return aInt; } public void setAInt(int int1){ aInt = int1; } public void changeInt(){ this.aInt =1; } public Object clone(){ Object o = null; try { o = (Object)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } public class TestRef { public static void main(String[] args) { Obj a = new Obj(); Obj b = (Obj) a.clone(); b.changeInt(); System.out.println(a.getInt());//0 System.out.println(b.getInt());//1 } } 2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆;代码如下： import java.io.Serializable; public class Employee implements Serializable { private static final long serialVersionUID = -6470090944414208496L; private String name; private int id; transient private int salary; @Override public String toString(){ return &quot;Employee{name=&quot;+name+&quot;,id=&quot;+id+&quot;,salary=&quot;+salary+&quot;}&quot;; } //getter and setter methods public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getSalary() { return salary; } public void setSalary(int salary) { this.salary = salary; } } 注意：static代笔类的静态成员，transient代表对象的临时数据，因此被声明为这两种类型的数据成员是不能够被序列化的。 现在我们假设需要把我们的对象写入文件，之后从相同的文件中将其反序列化，因此我们需要一些工具方法，通过使用ObjectInputStream和ObjectOutputStream来达到序列化的目的。 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; /** * A simple class with generic serialize and deserialize method implementations * * */ public class SerializationUtil { // deserialize to Object from given file public static Object deserialize(String fileName) throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(fileName); ObjectInputStream ois = new ObjectInputStream(fis); Object obj = ois.readObject(); ois.close(); return obj; } // serialize the given object and save it to file public static void serialize(Object obj, String fileName) throws IOException { FileOutputStream fos = new FileOutputStream(fileName); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); fos.close(); } } 测试程序： import java.io.IOException; public class SerializationTest { public static void main(String[] args) { String fileName=&quot;employee.ser&quot;; Employee emp = new Employee(); emp.setId(100); emp.setName(&quot;Pankaj&quot;); emp.setSalary(5000); //serialize to file try { SerializationUtil.serialize(emp, fileName); } catch (IOException e) { e.printStackTrace(); return; } Employee empNew = null; try { empNew = (Employee) SerializationUtil.deserialize(fileName); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } System.out.println(&quot;emp Object::&quot;+emp); System.out.println(&quot;empNew Object::&quot;+empNew); } } 运行以上测试程序，可以得到以下输出。 emp Object::Employee{name=Pankaj,id=100,salary=5000} empNew Object::Employee{name=Pankaj,id=100,salary=0} 由于salary是一个transient变量，它的值不会被存入文件中，因此也不会在新的对象中被恢复。类似的，静态变量的值也不会被序列化，因为他们是属于类而非对象的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://fengjiaxin.github.io/tags/clone/"}]},{"title":"hibernate如何提高性能和二级缓存的含义","slug":"hibernate如何提高性能和二级缓存的含义","date":"2017-02-02T12:37:04.000Z","updated":"2017-02-12T03:53:51.198Z","comments":true,"path":"2017/02/02/hibernate如何提高性能和二级缓存的含义/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/hibernate如何提高性能和二级缓存的含义/","excerpt":"","text":"之前编写了hibernate的一些相关代码，现在总结一些细节。问题： 在使用Hibernate时如何提高性能？ 延迟加载，当hibernate从数据库中获取一个对象数据，获取一个对象的集合属性值时或者获取某一个对象所关联的另一个对象时，并不会立即从数据库中加载到对象中，而是通过建立一个代理对象，把这个对象的属性值都设置为默认值，只有这些数据在被使用时才会从数据库中加载对应的数据。 缓存技术。hibernate提供了一级缓存与二级缓存，合理的利用缓存有助于提高系统的性能，通过合理配置缓存的参数可以避免不合理的利用缓存导致内存的过度消耗降低系统的性能。 优化查询语句。 说了这么多，那么什么是hibernate的二级缓存？ 缓存的目的是为了通过减少应用程序对物理数据源访问的次数来提高程序运行的效率，原理则是把当前或接下来一段时间可能会用到的数据保存在内存中，在使用时直接从内存中读取。 在hibernate中有一级缓存和二级缓存的概念，一级缓存由Session来管理，二级缓存由SessionFactory来管理，在使用时二级缓存可有可无，但是一级缓存必不可少。 一级缓存的使用场合如下：当使用session查询数据时，首先会在Session内部查找该对象是否存在，若存在，直接返回，否则，到数据库中区查询，并将查询结果缓存起来以便后期使用；缺点是当使用Session来表示一次会话中，它的生命周期较短，并且它是线程不安全的，不能够被多个线程共享，因此在实际使用中对效率的提升并不明显。 二级缓存用来为Hibernate配置一种全局的缓存，以便实现多个线程和事物共享。在使用了二级缓存机制后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，最后才去数据库中查找，与一级缓存相比，二级缓存是独立于hibernate的软件部件，属于第三方的产品，hibernate3以后默认使用的产品是EhCache. 二级缓存一般适用于以下几种情况： 数据量较小，如果数据量较大，缓存太多，大量消耗内存，造成内存资源短缺，从而降低系统的性能。 对数据的修改较少，如果进行大量的修改，就需要频繁的同步，也会影响系统的性能。 不会被大量的应用共享的数据，如果数据被大量线程或事物共享，多线程访问的同步机制会影响系统的性能。 不是很重要的数据，如果数据非常重要，对数据的准确性要求非常高，最好不要使用二级缓存。","categories":[{"name":"Web总结","slug":"Web总结","permalink":"https://fengjiaxin.github.io/categories/Web总结/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://fengjiaxin.github.io/tags/hibernate/"}]},{"title":"静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同","slug":"静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同","date":"2017-02-02T11:55:46.000Z","updated":"2017-02-09T07:52:37.110Z","comments":true,"path":"2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","excerpt":"","text":"Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 代码示例如下： /** * 扑克类（一副扑克） * */ public class Poker { private static String[] suites = {&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;}; private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; private Card[] cards; /** * 构造器 * */ public Poker() { cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) { for(int j = 0; j &lt; faces.length; j++) { cards[i * 13 + j] = new Card(suites[i], faces[j]); } } } /** * 洗牌 （随机乱序） * */ public void shuffle() { for(int i = 0, len = cards.length; i &lt; len; i++) { int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; } } /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) { return cards[index]; } /** * 卡片类（一张扑克） * [内部类] * */ public class Card { private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) { this.suite = suite; this.face = face; } @Override public String toString() { String faceStr = &quot;&quot;; switch(face) { case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); } return suite + faceStr; } } } 测试代码如下： class PokerTest { public static void main(String[] args) { Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A } } 面试题：下面的代码哪些地方会产生编译错误？ class Outer { class Inner {} pｕblic static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); } } 解答：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： new Outer().new Inner();","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"静态嵌套类","slug":"静态嵌套类","permalink":"https://fengjiaxin.github.io/tags/静态嵌套类/"},{"name":"内部类","slug":"内部类","permalink":"https://fengjiaxin.github.io/tags/内部类/"}]},{"title":"抽象类（abstract class）和接口（interface）有什么异同","slug":"抽象类（abstract-class）和接口（interface）有什么异同","date":"2017-02-02T11:21:13.000Z","updated":"2017-02-12T12:58:58.529Z","comments":true,"path":"2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","excerpt":"","text":"如果一个类中包含抽象方法，那么这个类就是抽象类，在Java中可以通过abstract关键字声明该类或该方法时抽象的；接口就是指一些方法的集合，接口中的所有方法都没有方法体。 只要包含一个抽象方法的类就必须别声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明的抽象方法不能包含方法体，在实现时，必须包含相同的或者更低的访问级别；接口中的所有方法都是抽象的，接口中的成员变量都是static final类型。 接口与抽象类的相同点如下： 都不能被实例化。 接口类的实现类或抽象类的子类都只有实现了接口或抽象类的方法后才能被实例化。 接口是抽象类的不同点如下： 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法，而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。 接口需要实现，但是抽象类只能被继承。 接口强调特定功能的实现，其设计理念是“has- a”关系，而抽象类强调所属关系，其设计理念为“is- a”关系。 接口中定义的成员变量默认为public static final,并且必须赋给其初值，其所有成员方法都是public、abstract的；而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法。 接口被用于实现比较常用的功能，便于日后的维护或添加删除方法；而抽象类更倾向于充当公共类的角色，不适用于日后重新对里面的代码进行修改。 一般而言，抽象类多用于在同类事物中有无法具体描述的方法的场景，所以当子类和父类之间存在有逻辑上的层次结构时，推荐使用抽象类；而接口多用于不同类之间，定义不同类之间的通信规则。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"https://fengjiaxin.github.io/tags/抽象类/"},{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"}]},{"title":"Java中字符串与存储的机制","slug":"Java中字符串与存储的机制","date":"2017-02-02T10:29:28.000Z","updated":"2017-02-12T13:11:36.766Z","comments":true,"path":"2017/02/02/Java中字符串与存储的机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中字符串与存储的机制/","excerpt":"","text":"今天准备总结一下String对象的存储机制 字符串的声明与初始化有如下两种情况： String s1 = new String(“abc”)//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后用new关键字在堆中创建新的对象 String s2 = “abc”//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后s2指向字符串常量池中”abc”对象的首地址。 具体来说： String s1 = &quot;abc&quot;//把&quot;abc&quot;放到常量池中，在编译时产生 String s2 = &quot;ab&quot;+&quot;c&quot;//把&quot;ab&quot;+&quot;c&quot;转换成字符串常量&quot;abc&quot;放到常量区中 String s3 = new String(&quot;abc&quot;)//在运行时把&quot;abc&quot;放到堆里面 String对象的intern()方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象 在明白了以上两点，那么我们来做两道笔试题： 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？StringBuffer对象适用于字符串经常操作，不产生而额外内存，而String对象不可变，一旦创建不能修改，但是操作简单，效率高，所以适用于字符串较少时，操作次数少的情况下。 请说出下面程序的输出。 class StringEqualTest { public static void main(String[] args) { String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); } } **结果为** System.out.println(s1==s2);//false System.out.println(s1==s5);//true System.out.println(s1==s6);//false System.out.println(s1==s6.intern());//true System.out.println(s2==s2.intern());//false 解释：字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象； String s6 = s3+s4//等价于 StringBuilder temp = s3; temp.append(s4); String s6 = temp.toString(); 所以S6是创建一个新的StringBuilder对象的toString()方法处理成String对象，因此s1==s6为false。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"String","slug":"String","permalink":"https://fengjiaxin.github.io/tags/String/"},{"name":"常量池","slug":"常量池","permalink":"https://fengjiaxin.github.io/tags/常量池/"}]},{"title":"Java中i++和++i的区别和理解","slug":"Java中i++和++i的区别和理解","date":"2017-02-02T09:31:43.000Z","updated":"2017-02-12T13:11:56.820Z","comments":true,"path":"2017/02/02/Java中i++和++i的区别和理解/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中i++和++i的区别和理解/","excerpt":"","text":"今天在做Java题时碰到了关于i++的问题，题目是这样的： public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 最终答案是0。 关于值传递我还是理解的，但是i=i++这个语句我又有点懵了，于是找了相关资料，总结就是JVM的机制所引起的，接下来我要详细介绍一下这方面知识，也算给自己一个交代。 jvm里面有两个存储区，一个是暂存区（是一个堆栈，以下称为堆栈），另一个是变量区。jvm会这样运行这条语句： JVM把count值（其值是0）拷贝到临时变量区。 count值加1，这时候count的值是1。 返回临时变量区的值。 返回值赋值给count，此时count值被重置成0。 所以上题的i= i++应该是下面的过程 int i =0; temp = i;//temp 为临时变量 i =i+1;//i =1 i = temp //i =0 对于自增运算++j与j++，由于加一的执行顺序不同，所以Java中有中间缓存变量来储存其单个表达式的值，而j的自增自减的结果依然保留在原来的变量储存区。因为本体是j的值，而单个表达式的值是中间产生的一个临时变量值，是在整条计算表达式结束后就可以抛弃的值，所以用个临时中间缓存变量在放就可以了。 按字面理解就是i++ 等价于 temp =i;//jvm把i的值拷贝到临时变量temp i =i+1;//i自加1 返回临时变量temp的值0作为表达式i++/++i的值 感觉了解了Java的自增原理，那么我们在练习一道题： int j = 0; j =++j + j++ +j++ + j++; 最终结果为7，详细解答如下 j =j+1 =1; temp1 = j =1; temp2 = j =1; j = j+1 =2; temp3 = j = 2； j =j+1 =3; temp4 = j = 3; j = j+1 =4; j = temp1 +temp2 +temp3 +temp4 = 1+1+2+3 =7; 总结：今天算是终于弄明白i++的原理了，有些问题一定要弄清楚，不能糊弄过去，加油！！！","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"}]},{"title":"基本操作","slug":"基本操作","date":"2017-02-01T11:51:36.000Z","updated":"2017-02-09T07:52:24.959Z","comments":true,"path":"2017/02/01/基本操作/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/01/基本操作/","excerpt":"","text":"命令总结常用命令hexo new &quot;postName&quot; #新建文章 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://fengjiaxin.github.io/categories/备忘录/"}],"tags":[]},{"title":"Java典型设计模式-代理模式","slug":"Java典型设计模式-代理模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T10:11:15.098Z","comments":true,"path":"2017/01/09/Java典型设计模式-代理模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-代理模式/","excerpt":"","text":"最近在学习Spring，Spring的两个核心是依赖注入和面向切面编程，其中面向切面编程就是在一个方法的前后位置加入其余的方法以更好地实现，那么在SpringAOP中是采用JDK动态代理实现的，动态代理就是采用代理模式技术实现的，关于JDK动态代理我稍后总结，今天就用静态代理的例子好好学习代理模式。 代理模式：为其他对象提供一种代理以控制对这个对象的访问。 代理模式有一下优点： 职责清晰：真实的角色实现实际的业务逻辑，不用关心其他非本职的事务，通过后期的代理完成附加的事务，附带的结果就是编程简洁清晰。 高扩展性：具体主题角色随需求的不同可能有很多种，但只要实现了接口，代理类就完全可以在不做任何修改的情况下代理各种真实主题角色。 智能化：代理类介意在运行时才确定去代理的真实主题（动态代理）。 通过游戏代练的过程演示代理模式的应用，其类图如下所示： IGamePlayer接口： public interface IGamePlayer { public void killBoss(); public void upGrade(); } GamePlayer实现IGamePlayer接口中的方法： public class GamePlayer implements IGamePlayer { private String name =&quot;&quot;; public GamePlayer(String name) { super(); this.name = name; } @Override public void killBoss() { System.out.println(this.name+&quot;在打怪！！！！&quot;); } @Override public void upGrade() { System.out.println(this.name+&quot;成功升1级！！！！&quot;); } } GamePlayerProxy是代理类： public class GamePlayerProxy implements IGamePlayer { private IGamePlayer player = null; public GamePlayerProxy(IGamePlayer player) { super(); this.player = player; } @Override public void killBoss() { this.log(); player.killBoss(); } @Override public void upGrade() { player.upGrade(); this.count(); } private void log(){ System.out.println(&quot;打怪时间&quot;+new Date().toString()); } private void count(){ System.out.println(&quot;升一级耗费50小时&quot;); } } 应用程序代码： public class ClientDemo { public static void main(String[] args) { IGamePlayer player = new GamePlayer(&quot;冯佳欣&quot;); IGamePlayer proxy = new GamePlayerProxy(player); proxy.killBoss(); proxy.upGrade(); } } 程序运行结果： 打怪时间Sun Feb 12 17:23:41 CST 2017 冯佳欣在打怪！！！！ 冯佳欣成功升1级！！！！ 升一级耗费50小时","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-装饰模式","slug":"Java典型设计模式-装饰模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T10:12:13.141Z","comments":true,"path":"2017/01/09/Java典型设计模式-装饰模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-装饰模式/","excerpt":"","text":"最近在复习I/O,发现很多类都是通过装饰模式进行修饰，将原来的类修饰的更强大，那么今天就来总结一下装饰模式。 装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。装饰模式有以下四个角色： 抽象构件角色：用于规范需要装饰的对象。 具体构件角色：用于实现抽象构件接口，定义一个需要装饰的原始类。 装饰角色：该角色持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰角色：该角色负责对构件对象进行装饰 装饰模式类图如下： 装饰模式的优点： 装饰类和被装饰类可以独立发展，而不会相互耦合。 装饰模式是继承关系的一个替代方式，装饰类Decorator，不管装饰多少层，返回的对象还是Component。 装饰模式可以动态地扩展一个实现类的功能。 装饰模式的使用场景： 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以在动态地撤销。 需要为一批类进行改装或加装功能。 通过对裸车进行装饰的过程演示装饰模式的应用： Car接口： public interface Car { public void show(); } Benz实现IGamePlayer接口中的方法： public class Benz implements Car { @Override public void show() { System.out.println(&quot;奔驰车默认是黑色&quot;); } } 汽车修饰类CarDecorator： public abstract class CarDecorator { private Car car = null; public CarDecorator(Car car){ this.car = car; } public void show(){ this.car.show(); } } 汽车修饰实现类ConcreteCarDecorator： public class ConcreteCarDecorator extends CarDecorator { public ConcreteCarDecorator(Car car) { super(car); } public void print(){ System.out.println(&quot;彩绘喷漆&quot;); } public void setGps(){ System.out.println(&quot;安装GPS&quot;); } public void show(){ super.show(); this.print(); this.setGps(); } } 应用程序代码： public class ClientDemo { public static void main(String[] args) { Car car = new Benz(); CarDecorator cd = new ConcreteCarDecorator(car); cd.show(); } } 程序运行结果： 奔驰车默认是黑色 彩绘喷漆 安装GPS","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-策略模式","slug":"Java典型设计模式-策略模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T12:45:04.212Z","comments":true,"path":"2017/01/09/Java典型设计模式-策略模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-策略模式/","excerpt":"","text":"最近在学习Spring，在Spring中有多个地方使用策略模式，如Bean定义对象的创建和代理对象的创建等，那今天学习一下策略模式。 策略模式：针对一组算法，将每一个算法封装到具有共同接口的的独立类中，从而使得他们可以相互替换，使得算法可以在不影响客户端的情况下发生变化。 策略模式有以下三个角色： 环境角色：该角色也叫上下文角色，起到承上启下的作用，屏蔽高层模块对策略、算法的直接访问，它持有一个Strategy的引用。 抽象策略角色：该角色对策略、算法进行抽象，通常定义每个策略或算法必须具有的方法和属性。 具体策略角色：该角色实现抽象策略中的具体操作，含有具体的算法。 策略模式类图如下： 策略式有以下优点： 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当的使用继承可以把公共的代码移到父类中，从而避免代码重复。 策略模式提供了可以替换继承关系的办法，继承可以处理多种算法或行为，如果不适用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为，但是这样算法或行为的使用者和算法本身混在一起，从而不可能在独立演化。 使用策略模式可以避免使用多重条件转移语句。 策略模式的缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式造成很多的策略类。 策略模式的使用场景： 多个类只是在算法或行为上稍有不同的场景。 算法需要自由切换的场景。 需要屏蔽算法规则的场景。 通过图书销售中不同折扣算法演示策略模式。 DiscountStrategy.java public abstract class DiscountStrategy { private double price = 0; private int number =0; public DiscountStrategy(double price, int number) { super(); this.price = price; this.number = number; } public double getPrice() { return price; } public int getNumber() { return number; } public abstract double calculateDiscount(); } NoDiscountStrategy.java public class NoDiscountStrategy extends DiscountStrategy { public NoDiscountStrategy(double price, int number) { super(price, number); } @Override public double calculateDiscount() { return 0; } } FixDiscountStrategy.java public class FixDiscountStrategy extends DiscountStrategy { public FixDiscountStrategy(double price, int number) { super(price, number); } @Override public double calculateDiscount() { return getNumber()+1; } } PercentageDiscountStrategy.java public class PercentageDiscountStrategy extends DiscountStrategy { public PercentageDiscountStrategy(double price, int number) { super(price, number); } @Override public double calculateDiscount() { return getPrice()*getNumber()*0.15; } } ContextClient.java public class ContextClient { private DiscountStrategy ds = null; public ContextClient(DiscountStrategy ds) { super(); this.ds = ds; } public double contextCalDisc(){ return this.ds.calculateDiscount(); } public static void main(String[] args) { ContextClient context0 = new ContextClient(new NoDiscountStrategy(48.5, 20)); System.out.println(&quot;0折扣&quot;+context0.contextCalDisc()); ContextClient context1 = new ContextClient(new FixDiscountStrategy(48.5, 20)); System.out.println(&quot;固定折扣&quot;+context1.contextCalDisc()); ContextClient context2 = new ContextClient(new PercentageDiscountStrategy(48.5, 20)); System.out.println(&quot;15%折扣&quot;+context2.contextCalDisc()); } } 程序运行结果： 0折扣0.0 固定折扣21.0 15%折扣145.5","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-观察者模式","slug":"Java典型设计模式-观察者模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T09:32:04.751Z","comments":true,"path":"2017/01/09/Java典型设计模式-观察者模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-观察者模式/","excerpt":"","text":"观察者模式是类和类之间的关系，不涉及到继承。 观察者模式很好理解，类似于邮件订阅和RSS订阅，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 public interface Observer { public void update(); } public class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } } public class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } } public interface Subject { /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); } import java.util.Enumeration; import java.util.Vector; public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } public class ObserverTest { public static void main(String[] args) { Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); } } 运行结果： update self! observer1 has received! observer2 has received! 也许看完实例之后还是比较抽象，再将文字描述和代码实例看一两遍吧，然后结合工作中看哪些场景可以使用这种模式以加深理解。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"}]},{"title":"Java典型设计模式-外观模式","slug":"Java典型设计模式-外观模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T10:47:10.767Z","comments":true,"path":"2017/01/09/Java典型设计模式-外观模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-外观模式/","excerpt":"","text":"最近在学习Tomcat,Tomcat中多处使用外观（门面）模式，那么今天系统学习一下外观模式，以便更好地学习Tomcat。 外观模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，外观模式提供一个更高层次的接口，使得子系统轻易使用。外观模式有以下两个角色： 外观角色：客户端可以调用该角色的方法，该角色知晓相关子系统的功能和责任；正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统，该角色没有实际的业务逻辑，只是一个委托类。 子系统角色：可以同时有一个或多个子系统，每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道外观角色的存在，对于子系统而言，外观角色仅是另一个客户端。 外观模式类图如下： 外观模式的优点： 减少系统的相互依赖，所有的依赖都是对Facade对象的依赖，与子系统无关。 提高灵活性，不管子系统如何变化，只要不影响Facade对象，任何活动都是自由的。 提高安全性，Facade为提供的方法，外界就无法访问，提高系统的安全性。 装饰模式可以动态地扩展一个实现类的功能。 外观模式的使用场景： 为一个浮渣的模块或子系统提供一个供外界访问的接口。 子系统相对独立，外界对子系统的访问只要黑箱操作即可。 预防风险扩散，使用Facade进行访问操作控制。 使用外观模式模拟秘书为老板准备工作的过程： Airport.java： public class Airport { public void bookTicket(String from,String to){ System.out.println(&quot;订购了从&quot;+from+&quot;到&quot;+to+&quot;的机票&quot;); } } Hotel.java： public class Hotel { public void reserve(int days){ System.out.println(&quot;订了&quot;+days+&quot;天的房间&quot;); } } Restaurant.java： public class Restaurant { public void reserve(int num){ System.out.println(&quot;定了一座&quot;+num+&quot;个人的酒席&quot;); } } Driver.java： public class Driver { public void drive(String to){ System.out.println(&quot;司机开车到&quot;+to); } } Secretary.java： public class Secretary { private Driver driver = new Driver(); private Hotel hotel = new Hotel(); private Restaurant res = new Restaurant(); private Airport air = new Airport(); //安排出差 public void trip(String to,int days){ air.bookTicket(&quot;青岛&quot;, to); driver.drive(&quot;机场&quot;); hotel.reserve(days); } //安排饭局 public void repast(int num){ res.reserve(num); driver.drive(&quot;酒店&quot;); } } Boss.java public class Boss { public static void main(String[] args){ Secretary se = new Secretary(); System.out.println(&quot;老板告诉秘书要去上海出差10天&quot;); se.trip(&quot;上海&quot;, 10); System.out.println(&quot;................&quot;); System.out.println(&quot;老板告诉秘书邀请8个人吃饭&quot;); se.repast(8); } } 程序运行结果： 老板告诉秘书要去上海出差10天 订购了从青岛到上海的机票 司机开车到机场 订了10天的房间 ................ 老板告诉秘书邀请8个人吃饭 定了一座8个人的酒席 司机开车到酒店","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-命令模式","slug":"Java典型设计模式-命令模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T11:17:50.290Z","comments":true,"path":"2017/01/09/Java典型设计模式-命令模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-命令模式/","excerpt":"","text":"最近在学习Tomcat,Tomcat中的Connector组件是通过命令模式调用Container的，那么今天就来学习一下命令模式。 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以听、提供命令的撤销和恢复功能。 命令模式有以下两个角色： 命令角色：该角色声明一个给所有具体命令类的抽象接口，定义需要执行的命令。 具体命令角色：该角色定义一个接受者和行为者之间的若耦合，实现命令方法，并调用接受者的相应操作。 调用者角色：该角色负责调用命令对象执行请求。 接受者角色：该角色负责具体实施和执行一个请求。 命令模式类图如下： 命令模式的优点： 类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能只需要调用Command中的execute()方法，不需要了解是哪个接受者执行。 可扩展性：Command的子类可以非常容易的扩展，而调用者用Invoker和更高层次的模块Client不产生严重的代码耦合。 命令模式结合其他模式更优秀。 命令模式的缺点： 可能会导致系统中出现过多的具体命令类，在项目使用中慎重考虑使用。 命令模式模板例子： Command.java： public interface Command { public void execute(); } ComcreteCommand.java： public class ComcreteCommand implements Command { private Receiver receiver; public ComcreteCommand(Receiver receiver) { super(); this.receiver = receiver; } @Override public void execute() { this.receiver.action(); } } Receiver.java： public class Receiver { public void action(){ System.out.println(&quot;执行动作&quot;); } } Invoker.java： public class Invoker { private Command command; public void setCommand(Command command) { this.command = command; } public void action(){ this.command.execute(); } } Client.java： public class Client { public static void main(String[] args) { Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); Command command = new ComcreteCommand(receiver); invoker.setCommand(command); invoker.action(); } } 程序运行结果： 执行动作","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"}]},{"title":"Java典型设计模式-责任链模式","slug":"Java典型设计模式-责任链模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-12T12:18:48.212Z","comments":true,"path":"2017/01/09/Java典型设计模式-责任链模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-责任链模式/","excerpt":"","text":"最近在学习Tomcat,Tomcat中最容易发现的设计模式就是责任链设计模式，这个设计模式也是在Tomcat中Container设计的基础，整个容器就是通过一个链连接在一起的，这个链一直将请求正确地传递给最终处理请求的Servlet，那么就学习一下责任链设计模式。 责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止。 责任链模式有以下两个角色： 抽象处理者角色：该角色对请求进行抽象，并定义一个方法以设定和返回对下一个处理者的引用。 具体处理者角色：该角色接到请求后，可以选择将请求处理掉，或者将请求传给下一个处理者。 责任链模式类图如下： 责任链模式的优点： 责任链模式将请求和处理分开，请求者不知道是谁处理的，处理者可以不用知道请求的全貌。 提高系统的灵活性。 责任链模式的缺点： 降低程序的性能，每个请求都是从链头遍历到链尾，当链比较长的时候，性能会大幅下降。 不易于调试，由于采用类似递归的方式，调试的时候逻辑比较复杂。 可能会导致系统中出现过多的具体命令类，在项目使用中慎重考虑使用。 责任链模式的使用场景： 一个请求需要一系列的处理工作。 业务流的处理。 对系统进行补充扩展。 击鼓传花演示责任链模式板例子： Player.java： public abstract class Player { private Player successor; public abstract void handle(int i); protected void setSuccessor(Player aSuccessor){ this.successor = aSuccessor; } //传给下一个 public void next(int index){ if(successor!=null) successor.handle(index); else System.out.println(&quot;游戏结束&quot;); } } PlayerAjava： public class PlayerA extends Player { public PlayerA(Player successor){ this.setSuccessor(successor); } @Override public void handle(int i) { if(i==1) System.out.println(&quot;PlayerA喝酒&quot;); else{ System.out.println(&quot;PlayerA把花向下传&quot;); next(i); } } } PlayerB.java： public class PlayerB extends Player { public PlayerB(Player successor){ this.setSuccessor(successor); } @Override public void handle(int i) { if(i==2) System.out.println(&quot;PlayerB喝酒&quot;); else{ System.out.println(&quot;PlayerB把花向下传&quot;); next(i); } } } PlayerC.java： public class PlayerC extends Player { public PlayerC(Player successor){ this.setSuccessor(successor); } @Override public void handle(int i) { if(i==3) System.out.println(&quot;PlayerC喝酒&quot;); else{ System.out.println(&quot;PlayerC把花向下传&quot;); next(i); } } } PlayerD.java： public class PlayerD extends Player { public PlayerD(Player successor){ this.setSuccessor(successor); } @Override public void handle(int i) { if(i==4) System.out.println(&quot;PlayerD喝酒&quot;); else{ System.out.println(&quot;PlayerD把花向下传&quot;); next(i); } } } DrumBeater.java： public class DrumBeater { public static void main(String[] args) { Player player = new PlayerA(new PlayerB(new PlayerC(new PlayerD(null)))); player.handle(3); } } 程序运行结果： PlayerA把花向下传 PlayerB把花向下传 PlayerC喝酒","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"}]},{"title":"Java典型设计模式-适配器模式","slug":"Java典型设计模式-适配器模式","date":"2017-01-09T05:03:57.000Z","updated":"2017-02-12T09:32:41.710Z","comments":true,"path":"2017/01/09/Java典型设计模式-适配器模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-适配器模式/","excerpt":"","text":"适配器模式 适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。有点抽象，我们来看看详细的内容。 类的适配器模式 类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。 public class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } } public interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); } public class Adapter extends Source implements Targetable { public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } } public class AdapterTest { public static void main(String[] args) { Targetable target = new Adapter(); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 对象的适配器模式 对象的适配器模式的基本思路和类的适配器模式相同，只是将Adapter类作修改成Wrapper，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source) { super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } } public class AdapterTest { public static void main(String[] args) { Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 接口的适配器模式 接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行了。 在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： public interface Sourceable { public void method1(); public void method2(); } //抽象类Wrapper2： public abstract class Wrapper2 implements Sourceable{ public void method1(){} public void method2(){} } public class SourceSub1 extends Wrapper2 { public void method1(){ System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); } } public class SourceSub2 extends Wrapper2 { public void method2(){ System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); } } public class WrapperTest { public static void main(String[] args) { Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); } } 测试输出： the sourceable interface&apos;s first Sub1! the sourceable interface&apos;s second Sub2! 总结一下三种适配器模式的应用场景 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-单例模式","slug":"Java典型设计模式-单例模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-12T09:31:09.221Z","comments":true,"path":"2017/01/09/Java典型设计模式-单例模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-单例模式/","excerpt":"","text":"### 单例模式 ### 单例模式就是一个类只有一个实例，不允许外界创建新的对象，但是可以调用类的实例，代码如下： public class MyObject { private static MyObject myObject; private MyObject() { } public static MyObject getInstance() { if (myObject != null) { } else { myObject = new MyObject(); } return myObject; } } 但是这样会引发多线程问题，这个问题就先放下，对线程有了更深入的了解后在回看。 在学习了线程的知识后，从新看单例模式，发现果然不是只有上面一种单例模式，那么根据我学习的知识进行一下补充： 在Java语言中实现单例模式通常有两种表现方式： 饿汉式单例类：类加载时，就进行对象实例化。 懒汉式单例类：第一次引用类时，才进行对象实例化。上面的例子是非同步懒汉式单例类。 饿汉式单例类代码如下： package Design.Creational.Singleton; //恶汉式单例 public class Singleton1 { private static Singleton1 m_instance = new Singleton1(); private Singleton1(){ } public static Singleton1 getInstance(){ return m_instance; } } 第一个例子是线程不安全的，如果有连个线程同时调用实例方法，那么有可能会生成两个实例，违反了单例模式。 同步懒汉式代码如下： package Design.Creational.Singleton; //懒汉式单例 public class Singleton2 { private static Singleton2 m_instance = null; private Singleton2(){ } public synchronized static Singleton2 getInstance(){ if(m_instance==null) m_instance = new Singleton2(); return m_instance; } }","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"Java典型设计模式-抽象工厂方法模式","slug":"Java典型设计模式-抽象工厂方法模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-12T03:54:56.156Z","comments":true,"path":"2017/01/09/Java典型设计模式-抽象工厂方法模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-抽象工厂方法模式/","excerpt":"","text":"### 抽象工厂模式 ### 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则。 为解决这个问题，我们来看看抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码，这样就符合闭包原则了。 下面来看看代码： MyInterface、MyClassOne、MyClassTwo不变。 新增如下接口和类： public interface Provider { public MyInterface produce(); } public class MyFactoryOne implements Provider { @Override public MyInterface produce() { return new MyClassOne(); } } public class MyFactoryTwo implements Provider { @Override public MyInterface produce() { return new MyClassTwo(); } } 修改测试类FactoryTest如下： public class FactoryTest { public static void main(String[] args){ Provider provider = new MyFactoryOne(); MyInterface myi = provider.produce(); myi.print(); } } 再回顾：抽象工厂模式就是创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"Java典型设计模式-工厂方法模式","slug":"Java典型设计模式-工厂方法模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-09T07:38:25.119Z","comments":true,"path":"2017/01/09/Java典型设计模式-工厂方法模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-工厂方法模式/","excerpt":"","text":"### 工厂方法模式 ### 工厂方法模式分为三种：普通工厂模式、多个工厂方法模式和静态工厂方法模式。 #### 1 普通工厂模式 #### 普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 public interface MyInterface { public void print(); } public class MyClassOne implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassOne&quot;); } } public class MyClassTwo implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassTwo&quot;); } } public class MyFactory { public MyInterface produce(String type) { if (&quot;One&quot;.equals(type)) { return new MyClassOne(); } else if (&quot;Two&quot;.equals(type)) { return new MyClassTwo(); } else { System.out.println(&quot;没有要找的类型&quot;); return null; } } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produce(&quot;One&quot;); myi.print(); } } 再回头来理解这句话：普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 ### 2 多个工厂方法模式 ### 多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。我们修改MyFactory和FactoryTest如下： public class MyFactory { public MyInterface produceOne() { return new MyClassOne(); } public MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produceOne(); myi.print(); } } 再回头来理解这句话：多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。 ### 3 静态工厂方法模式 ### 静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。我们修改MyFactory和FactoryTest如下： public class MyFactory { public static MyInterface produceOne() { return new MyClassOne(); } public static MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyInterface myi = MyFactory.produceOne(); myi.print(); } 再回顾：静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"设计模式六大原则(5): 聚合/复用原则","slug":"设计模式六大原则-5-聚合-复用原则","date":"2017-01-06T03:58:37.000Z","updated":"2017-02-12T12:48:19.250Z","comments":true,"path":"2017/01/06/设计模式六大原则-5-聚合-复用原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-5-聚合-复用原则/","excerpt":"","text":"1 问题的由来 在实际开发中，新建一个类可能会用到多个以前的类的方法，但是在设计时是不能轻易采用继承机制的；因为在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 2 聚合/复用原则 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。 组合或聚合关系可以将成员对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见。 相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 3 举例说明 在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如下所示： 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。 现使用合成复用原则对其进行重构。在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如下所示： CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中。 如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。。 4 总结 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(4): 迪米特原则","slug":"设计模式六大原则-4-迪米特原则","date":"2017-01-06T03:58:12.000Z","updated":"2017-02-12T12:50:10.501Z","comments":true,"path":"2017/01/06/设计模式六大原则-4-迪米特原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-4-迪米特原则/","excerpt":"","text":"1 问题的由来 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 2 迪米特原则 通俗的来讲：就是一个类对自己依赖的类知道的越少越好。 对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。 更简单的定义：只与直接的朋友通信。 那么什么是直接的朋友？？？ 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。 出现成员变量、方法参数、方法返回值中的类为直接的朋友； 出现在局部变量中的类则不是直接的朋友。 也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 3 举例 举一个代码例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。 先看一个错误的例子 //总公司员工 class Employee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司员工 class SubEmployee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司管理 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } } //总公司管理 class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1){ System.out.println(e.getId()); } List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } public class Client{ public static void main(String[] args){ CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); } } 主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。 修改后的代码 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } public void printEmployee(){ List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list){ System.out.println(e.getId()); } } } class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 3 总结 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(3): 接口隔离原则","slug":"设计模式六大原则-3-接口隔离原则","date":"2017-01-06T03:57:45.000Z","updated":"2017-02-12T12:50:57.768Z","comments":true,"path":"2017/01/06/设计模式六大原则-3-接口隔离原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-3-接口隔离原则/","excerpt":"","text":"1 问题的由来 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类B和类D来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 2 接口隔离原则 客户端不应该依赖它不需要的接口 意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。 类间的依赖关系应该建立在最小的接口上 接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。 接下来是代码示例： public interface I { public void method1(); public void method2(); public void method3(); } public class B implements I{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } @Override public void method3() {//类B并不需要接口I的方法3功能，但是由于实现接口I，所以不得不实现方法3 //在这里写一个空方法 } } public class D implements I{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } @Override public void method1() {//类D并不需要接口I的方法1功能，但是由于实现接口I，所以不得不实现方法1 //在这里写一个空方法 } } //类A通过接口I依赖类B public class A { public void depend1(I i){ i.method1(); } } //类C通过接口I依赖类D public class C { public void depend1(I i){ i.method3(); } } public class Client { public static void main(String[] args) { A a = new A(); I i1 = new B(); a.depend1(i1); C c = new C(); I i2 = new D(); c.depend1(i2); } } 运行结果： 类B实现了接口I的方法1 类D实现了接口I的方法3 可以看出，如果接口过于臃肿，不同业务逻辑的抽象方法都放在一个接口内，会造成它的实现类必须实现自己并不需要的方法 这种设计方式显然是不妥当的。所以应该把接口I拆分成3个接口，使得实现类只需要实现自己需要的接口即可，修改代码如下： public interface I1 { public void method1(); } public interface I2 { public void method2(); } public interface I3 { public void method3(); } public class B implements I1,I2{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } } public class D implements I2,I3{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } } 3 与单一职责区别 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。4 总结 对于接口隔离原则来说，接口尽量小，但是也要有限度。 对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(2): 依赖倒置原则","slug":"设计模式六大原则-2-依赖倒置原则","date":"2017-01-06T03:57:15.000Z","updated":"2017-02-12T12:52:04.128Z","comments":true,"path":"2017/01/06/设计模式六大原则-2-依赖倒置原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-2-依赖倒置原则/","excerpt":"","text":"1 问题的由来 类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑。类B和C是底层模块，负责基本的原子操作。假如修改类A，将会给程序带来不必要的风险。 2 依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 抽象：即抽象类或接口，两者是不能够实例化的。 细节：即具体的实现类，实现接口或者继承抽象类所产生的类。 //具体Jim人类 public class Jim { public void eat(Apple apple){ System.out.println(&quot;Jim eat &quot; + apple.getName()); } } //具体苹果类 public class Apple { public String getName(){ return &quot;apple&quot;; } } public class Client { public static void main(String[] args) { Jim jim = new Jim(); Apple apple = new Apple(); jim.eat(apple); } } 运行结果：Jim eat apple 其实上面这个设计很不好，如果吃香蕉的话，就要改变依赖类，怎么吃水果是人自己的选择，为什么还要修改自己的代码；并且Jim类和Apple类紧耦合，不太符合低耦合，高内聚的原则，那怎么解决这类问题呢？ 而根据依赖倒置原则，我们可以提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。 修改代码如下 //人接口 public interface People { public void eat(Fruit fruit); } //水果接口 public interface Fruit { public String getName(); } //具体Jim人类 public class Jim implements People{ public void eat(Fruit fruit){ System.out.println(&quot;Jim eat &quot; + fruit.getName()); } } //具体苹果类 public class Apple implements Fruit{ public String getName(){ return &quot;apple&quot;; } } //具体香蕉类 public class Banana implements Fruit{ public String getName(){ return &quot;banana&quot;; } } public class Client { public static void main(String[] args) { People jim = new Jim(); Fruit apple = new Apple(); Fruit Banana = new Banana();//这里符合了里氏替换原则 jim.eat(apple); jim.eat(Banana); } } 运行结果： Jim eat apple Jim eat banana People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，做到了高层模块不应该依赖低层模块，两者都应该依赖于抽象。 People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节。 Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。 3 什么是倒置 就是提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。 4 依赖的三种实现方式 对象的依赖关系有三种方式来传递: 接口方法中声明依赖对象 public interface People { public void eat(Fruit fruit); } 构造方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public Jim(Fruit fruit){//构造方法传递依赖对象 this.fruit = fruit; } } Setter方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public void setFruit(Fruit fruit){//setter方式传递依赖对象 this.fruit = fruit; } } 5 优点 从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。 还有一个优点是，实际项目开发中，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。 6 总结 依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。 依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。 但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(1): 里氏替换原则","slug":"设计模式六大原则-1-里氏替换原则","date":"2017-01-06T03:56:46.000Z","updated":"2017-02-12T12:52:59.226Z","comments":true,"path":"2017/01/06/设计模式六大原则-1-里氏替换原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-1-里氏替换原则/","excerpt":"","text":"1 问题由来 对象有三大特性：封装、继承、多态，子类在继承父类后，经常任意重写父类的方法，这时候可能会导致父类的原功能发生故障。 2 里氏替换原则 通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。 更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。 //抽象父类电脑 public abstract class Computer { public abstract void use(); } class IBM extends Computer{ @Override public void use() { System.out.println(&quot;use IBM Computer.&quot;); } } class HP extends Computer{ @Override public void use() { System.out.println(&quot;use HP Computer.&quot;); } } public class Client{ public static void main(String[] args) { Computer ibm = new IBM(); Computer hp = new HP();//引用基类的地方能透明地使用其子类的对象。 ibm.use(); hp.use(); } } 3 四层含义 里氏替换原则包含以下4层含义： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。 子类中可以增加自己特有的方法。 在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 这个其实很好理解，就是入口更宽松，那么就以代码更好地理解吧！ import java.util.HashMap; public class Father { public void func(HashMap m){ System.out.println(&quot;执行父类...&quot;); } } import java.util.Map; public class Son extends Father{ public void func(Map m){//方法的形参比父类的更宽松 System.out.println(&quot;执行子类...&quot;); } } import java.util.HashMap; public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 HashMap h = new HashMap(); f.func(h); } } 运行结果：执行父类… 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 这个也不难理解，就是出口更严格，那么就以代码更好地理解吧！ import java.util.Map; public abstract class Father { public abstract Map func(); } import java.util.HashMap; public class Son extends Father{ @Override public HashMap func(){//方法的返回值比父类的更严格 HashMap h = new HashMap(); h.put(&quot;h&quot;, &quot;执行子类...&quot;); return h; } } public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 System.out.println(f.func()); } } 4 总结 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性，不符合设计模式的低耦合，高内聚，因此系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"Java设计模式简介（个人总结）","slug":"Java设计模式简介（个人总结）","date":"2017-01-05T14:06:21.000Z","updated":"2017-02-12T09:40:08.725Z","comments":true,"path":"2017/01/05/Java设计模式简介（个人总结）/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/Java设计模式简介（个人总结）/","excerpt":"","text":"这学期学习了软件工程课程，对Java语言的理解更近一步，但是不足还是那么多，在设计系统的过程中其实我就一直在思考设计模式的问题，都说了解了设计模式的程序员才能更好地设计出系统，那么今天我就本着执着的精神总结一下关于ava设计模式的的基本原则。 设计模式原则 书上总结有六大原则，首先就简单说明一下这六大原则。 开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 里氏代换原则（Liskov Substitution Principle） 子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用 子类返回值的能力是比父类小的 任何子类方法可以声明抛出父类方法声明异常的子类；而不能声明抛出父类没有声明的异常。 依赖倒转原则（Dependence Inversion Principle） 是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 到这里，相信都被概念弄蒙了，其实意思很好理解，就是降低耦合性，提高内聚性。基于这六大原则，前辈们总结出了23种设计模式供大家学习。 总体来说设计模式分为三大类： 创建型模式，是对类的实例化过程的抽象化，能够提供对象的创建和管理职责，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式：是描述如何将类或者对象结合在一起形成更大的结构，目的是通过组合类或者对象产生更大结构以适应更高层次的逻辑需求，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，是对不同对象之间划分责任和算法的抽象化，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"JVM内存管理（一）","slug":"JVM内存管理","date":"2017-01-05T03:17:28.000Z","updated":"2017-02-12T13:10:04.225Z","comments":true,"path":"2017/01/05/JVM内存管理/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/JVM内存管理/","excerpt":"","text":"在学习了Java之后，我们知道不需要显示的调用分配内存的函数，因为GC会帮我们回收释放内存，但是作为程序员，需要了解Java是如何管理内存的，这样在出现OutOfMemoryError时，才不至于手忙脚乱，那么在学习JVM内存管理，我们也需要从操作系统的角度来理解相关知识。 1、物理内存与虚拟内存 物理内存就是RAM，随机存储器，在计算机中，还有寄存器，用于存储计算单元执行指令的中间结果。虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，共享指的只是空间上的共享，在逻辑上仍然是不能互相访问的；虚拟地址不但可以让进程共享物理内存、提高内存利用率，而且还可以扩展内存的地址空间。 2、内核空见和用户空间 内核空间主要指的是操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑，为了保证操作系统的稳定性，运行在操作系统中的用户程序不能访问操作系统所使用的内存空间，用户程序可以调用操作系统提供的接口实现访问硬件资源、网络连接等功能。 3、在Java中哪些组件需要使用内存？ Java启动后作为一个进程运行在操作系统中，那么这个进程有哪些部分需要分配内存空间？ Java堆：Java堆是用于存储Java对象的内存区域；在Java堆中内存空间的管理由JVM来控制，对象创建由Java应用程序控制，但是对象空间所占的空间释放由管理堆内存的垃圾收集器来完成。 线程：Java运行实际程序的实体是线程。 类和类加载器：他们被存储在堆中，这个区域成为永久代。 NIO：基于通道和缓冲区来执行IO的新方式，分配的内存使用的是本机内存而不是Java堆上的内存，显然不需要讲数据复制到Java内存中。 JNI：JNI技术使得本机代码（C）可以调用Java方法，所以JNI也会增加Java运行时的本机内存占用。 4、JVM内存结构 JVM时按照运行时数据的存储结构来划分内存结构的，JVM在运行Java程序时，将他们划分为几种不同格式的数据，分别存储在不同的区域，这些数据统一称为运行时数据，运行时数据包括Java程序本身的数据信息和JVM运行Java程序需要的额外数据信息。 在Java虚拟机规范中将Java运行时数据划分为6种，分别是PC寄存器数据、Java栈、堆、方法区、本地方法区、运行时常量池。 1. PC寄存器：用于保存当前正在正常执行的程序的内存地址。 2. Java栈：每当创建一个线程时，JVM就会为这个线程创建一个对应的Java栈，在Java栈中又会含有多个栈帧，这些栈帧时与每个方法联系起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些内部变量、操作栈和方法返回值等信息。 3. 堆：是存储Java对象的地方，是JVM管理Java对象的核心存储区域，每一个存储在堆中的Java对象都会是这个对象的类的一个副本，它会复制包括继承自他父类的所有非静态属性。 4. 方法区：用于存储类结构信息的地方，属于Java堆中的永久区，可以被所有线程共享。 5. 运行时常量池：代表运行时每个class文件中的常量表，是方法区的一部分。 6. 本地方法栈：是为JVM运行Native方法准备的空间，和Java栈的作用类似 5、JVM内存分配策略 操作系统将内存分配策略分为三种。分别是静态内存分配、栈内存分配、堆内存分配。 静态内存分配指的是在程序编译时就能够确定每个数据在运行时的存储空间需求，在编译时就就可以给它们分配固定的内存空间。 栈式内存分配也成为动态内存分配，由一个雷士与堆栈的运行栈来实现的，和静态内存相反，程序对数据区的需求在编译时时完全未知的，只有到运行时才知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区的大小才能为其分配内存。 堆分配内存：在编写程序时除了在编译时能确定数据的存储空间和在程序入口处能知道存储空间外，还有一种情况就是当程序真正运行到相应代码时才会知道空间的大小。 JVM内存分配主要基于两种：堆和栈 Java栈式如何分配内存的呢？ Java栈的分配是和线程绑定在一起的，当我们创建一个线程时，JVM就会为这个线程创建一个新的Java栈，一个线程的方法的调用和返回对应于这个Java栈中的压栈和出栈；当线程激活一个java方法时，JVM就会在线程的Java堆栈里新压入一个帧，帧就成为了当前帧。 栈的存取速度比堆块，仅次于寄存器，栈数据可以共享，但是存在栈中的数据大小和生存周期必须是确定的。每个Java应用都唯一对应一个JVM实例，每个实例对应一个堆；应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用程序的所有线程共享，所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。 Java的堆是一个运行时数据区，堆是由垃圾回收器来负责，堆的优势是可以动态的分配内存大小，生存周期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的GC会自动收走这些不再使用的数据；缺点是由于是在运行时动态分配内存，存取速度较慢。 6、静态内存分配与回收 开发人员一般情况下不需要了解内存这个概念，因为内存的开辟与回收由JVM操作，但是在学习了操作系统之后，想要了解数据在Java是如何申请内存的，总结而言就是通常的显示内存申请有如下两种： 静态内存分配 动态内存分配 6.1 静态内存分配 在Java中静态内存分配是指在Java编译时就已经能确定需要的内存空间，当程序被加载时系统把内存一次性分配给它；这些内存不会再程序执行时发生变化，直到程序执行结束时内存才会被回收。在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存的。 6.2 动态内存分配和回收 在Java中对象的内存空间是动态分配的，所谓动态分配就是在程序执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。 从前面的分析中可知内存的分配实在对象创建时发生的，而内存的回收是以对象不再引用为前提的，这种动态内存的分配和回收是和Java中的一些数据结构类型关联的。 如何确定这个对象什么时候不再被使用，如何回收，这正是JVM的垃圾收集器的工作。 6.3 如何检测垃圾 垃圾收集器的工作： 正确检测出垃圾对象 释放垃圾对象占用的内存空间 如何检测出垃圾是GC上的关键；从前面的分析可以总结出：只要某个对象不再被其他的活动对象引用，这个对象就可以被回收了，活动对象指的是能够被一个根对象集合到达的对象。 那么根对象集合中有些什么呢？ 在方法中局部变量区的引用：对象直接存储在栈帧的局部变量区中。 在Java操作栈中的对象引用：对象直接在操作栈中持有。 在常量池的对象引用：每个类都会包含一个常量池，这些常用池中就会包含很多对象的引用。 在本地方法中次有的对象引用 类的Class对象 JVM在做垃圾回收时就会检查堆中的所有对象是否都会被这些跟对象直接或间接引用，能够被引用的对象就是活动对象，否则就被GC回收。 6.4 基于分代的垃圾收集算法 算法的设计思路：把对象按照寿命长短分组，分为年轻代和老年代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么把这个对象划分到老年代。老年代的收集频度不像年轻代那么频繁，这样就减少了每次垃圾收集时所要扫描的对象的数量，提高了垃圾回收效率。 这种设计思路是把堆划分为若干个子堆，每个子堆对应一个年龄代，如下图所示： JVM将整个堆划分为Young区，Old区，Perm区，分别存放不同年龄的对象，这三个区存放的对象有如下区别： Young区分为Eden区和Survivor区，其中所有新创建的对象都在Eden区，当Eden区满后会触发minor GC将Eden区让存活的对象复制到其中一个Survivor中，另外一个Survivor区中的存活对象也复制到这个Survivor中，保证始终有一个Survivor区是空的。 Old区存放的是Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将对象存放到Survivor区中，如果Survivor区中仍然存不下这些对象，GC收集器会将这些对象直接存放到Old区，如果Survivor区中的对象足够老，直接存放到Old区中，如果Old区中也满了，触发Full GC，回收整个堆内存。 Perm区存放的是类的Class对象，如果一个类被频繁的加载，可能会导致Perm区满，Perm区的垃圾回收也是有Full GC触发的。 6.5 minor GC、full GC、major GC区别 Minor GC 是指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。注意：除了将Eden区的非活动对象回收后，还会把一些老对象复制到Old区中。 Major GC 是清理老年代。 Full GC 是清理整个堆空间—包括年轻代和老年代。 许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的 6.6 Hotspot三类垃圾收集算法 Serial Collector(单线程收集器)：是JVM在client模式下的默认GC方式，当Eden空间不足时，触发Minor GC，会先检查之前每次Minor GC晋升到Old区的对象的平均大小，如果Old区的剩余空间小于平均大小，则直接触发Full GC，如果Old区的剩余空间大于平均大小，则看HandlePromotionFailure的值。如果为true，仅触发Minor GC，否则再触发一次Full GC。当Survivor区中的To Space放不下这些对象时，这些对象被放入Old区，如果Old或Perm区空间不足，将会触发Full GC。JVM的GC操作是串行的，JVM中的其他应用程序会全部停止。 parallel GC根据Minor GC和Full GC的不同分为三种，分别是ParNewGC，ParallelGC和ParallelOldGC。 ParNewGC：回收策略与Serial Collector相似，只是回收不是单线程的，而是多线程并行回收。 ParallelGC：Server下默认的GC方式。当在Eden中申请内存发生不够的情况时，看当前申请的空间是否大于Eden的一半，如果大于则直接在Old区中分配空间，如果小于则触发Minor GC。触发Minor GC前会检查过去每次晋升Old区的平均大小是否大于Old区的剩余空间。如果大于则再次触发Full GC，在这次触发后仍会按这个规则重新检查一次，Full GC会执行两次。 ParallelOldGC：与ParalelGC不同之处在于Full GC。Parallel GC的Full GC清空整个Heap堆中的垃圾对象，清除Perm区中已被卸载的类信息，并进行压缩。而ParallelOldGC清除Heap堆中的部分垃圾对象，并进行部分的空间压缩。GC程序是多线程，当同样暂停其他所有程序。 CMS Collector：既不是Minor GC，也不是Full GC，是基于两种GC之间的一种GC。触发规则是检查Old区或Prem区的使用率。触发CMS GC回收的只是Old区或Perm区的垃圾对象。与Minor GC或Full GC没有关系。这种模式下的Minor GC触发与回收规则与Serial GC基本一致。不同之处只是GC回收变成多线程而已。有两种情况触发Full GC。一种是Eden分配失败，Minor GC后分配到To Space，To Space不够再分配到Old区，Old区不够则触发Full GC。另外一种情况是，当CMS GC正在进行时先Old区申请内存失败，则会直接触发Full GC。 6.7 三种GC优缺点对比 GC 优点 缺点 Serial Collector(串行) 适合内存有限的情况 回手收慢 Parallel Collector(并行) 效率高 当Heap过大时，应用程序暂停时间较长 CMS Collector(并发) Old区回收暂停时间短 产生内存碎片，整个GC耗时较长，耗CPU","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://fengjiaxin.github.io/tags/GC/"}]},{"title":"数据库访问中遇到的问题","slug":"数据库访问中遇到的问题","date":"2017-01-03T07:45:27.000Z","updated":"2017-02-09T09:05:02.660Z","comments":true,"path":"2017/01/03/数据库访问中遇到的问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/数据库访问中遇到的问题/","excerpt":"","text":"今天在编码中出现了No suitable driver found for jdbc，又是找遍了网上的资料，基本上都说是三个问题： 连接URL格式出现了问题 驱动字符串出错(com.mysql.jdbc.Driver) 三是Classpath中没有加入合适的mysql_jdbc驱动 经过我的仔细检查，出现了两次错误，总结如下： 在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。但是在 Eclipse web 项目中，当执行 Class.forName(“om.mysql.jdbc.Driver”);时 不会去查找驱动的。所以本实例中我们需要把mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。 查看资料说Java1.8之后就不用写Class.forName(“com.mysql.jdbc.Driver”) ; 我就没写，后来将这句代码写上，发现成功连接数据库，下次还是写上吧。 那我就把自己写的DBUtil.java代码贴上吧！ public class DBUtil { public static Connection getConnection() { String username = &quot;root&quot;; String password = &quot;123456&quot;; String url = &quot;jdbc:mysql://localhost:3306/itat_shop&quot;; Connection con = null; //1.加载驱动程序 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); con = DriverManager.getConnection(url, username, password); } catch(ClassNotFoundException |SQLException e) { e.printStackTrace(); } return con; } public static void close(Connection con) { try { if(con!=null) con.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(java.sql.PreparedStatement ps) { try { if(ps!=null) ps.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(ResultSet rs) { try { if(rs!=null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }","categories":[{"name":"问题总结","slug":"问题总结","permalink":"https://fengjiaxin.github.io/categories/问题总结/"}],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"https://fengjiaxin.github.io/tags/jdbc/"},{"name":"mysql","slug":"mysql","permalink":"https://fengjiaxin.github.io/tags/mysql/"}]},{"title":"返回类型是接口的分析","slug":"返回类型是接口的分析","date":"2016-12-27T02:36:51.000Z","updated":"2017-02-09T07:52:12.952Z","comments":true,"path":"2016/12/27/返回类型是接口的分析/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/27/返回类型是接口的分析/","excerpt":"","text":"今天在学习Servlet的过程中，书上关于DaoFactory的代码如下： public class DAOFactory { public static IUserDao getUserDao() { return new UserDao(); } } 在这里IUserDao是一个接口类型，但是返回的确实一个实现类，这明显不是一个类型啊，我就带着疑问上网搜索，总结如下： 接口虽然不能被实例化，但是接口的实现类都可以向上转型为接口； 面向接口编程是指我们在编写代码时对数据参数的定义尽量写成接口，待真正实现的时候再用实际类型代替； 代码的耦合性降低，在运行时我只需修改实现类类型，就可以实现不同的功能，而不必要修改接口的代码。 总结：接口的实现类可以向上转型为接口类，表面上返回的是接口类型，实际上返回的却是接口的实现类，如果需要取出接口的实现类，可以向下转型。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"}]},{"title":"Servlet技术笔记","slug":"Servlet技术笔记","date":"2016-12-26T07:49:21.000Z","updated":"2017-02-12T13:03:54.927Z","comments":true,"path":"2016/12/26/Servlet技术笔记/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/26/Servlet技术笔记/","excerpt":"","text":"1 ServletAPI：1.1 Servlet接口的主要方法及作用： init():在Servlet实例化之后，Servlet容器会调用init()方法，来初始化该对象。 service():容器调用Service()方法来处理客户端的请求。 destroy():容器检测到一个Servlet对象应该从服务器中被移除的时候，容器调用该对象的destroy()方法，以便Servlet对象可以释放使用的资源。 getServletConfig():返回调用init()方法时传递给Servlet对象的ServletConfig对象。 1.2 ServletRequest和ServletResponse： Servlet由Servlet容器管理，当客户端请求时，容器创建一个ServletRequest对象，封装请求数据，同事创建一个ServletResponse对象，封装响应数据，这两个对象被容器作为service()方法的参数传递给Servlet。 1.3 ServletConfig: Servlet容器使用ServletConfig对象在Servlet初始化期间向它传递配置信息，一个Servlet只能有一个ServletConfig对象。 1.4 简单实例 编写HelloWorldServlet例子，源代码见HelloServlet.java 1.5HttpServlet HttpServlet继承自GenericServlet，当容器收到一个针对HttpServlet对象的请求时，调用顺序如下： 调用public 的service()方法； 将参数类型转换为HttpServletRequest和HttpServletResponse，然后调用protected 的service()方法，将转换后的参数传进去； 在protected 的service()方法中，首先调用HttpServletRequest对象的getMethod()方法，确定是get，还是post方法。然后调用相应的doGet()或者doPost()等方法。 因此，在编写HttpServlet的派生类时，只许重写响应的doXXX()方法。 1.6 HttpServletRequest和HttpServletResponse get()方法：提交的数据提交到URL中，传递给后台服务器。 post()方法：提交的数据作为请求正文的内容发送到服务端，在URL看不到附加的请求数据。 2 简单实例：OutputInfoServlet：代码见OutputInfoServlet.java。 一个登陆实例：需要编写LoginServlet2.java，CenterServlet.java，success.html，web.xml。 3 Servlet异常 ServletException：可以被init()，service()，doXXX()等方法抛出。 UnavailableException：是ServletException的子类，用于向Servlet容器指示这个Servlet永久的或暂时的不可用。 4 Servlet生命周期 加载和实例化：Servlet容器负责加载和实例化Servlet，容器是通过反射机制来创建Servlet实例，调用不带参数的构造方法。 初始化：调用init()方法，在处理客户端请求时完成一些初始化工作。 请求处理：调用Service()方法，若执行期间有错误，可以抛出ServletException或UnavailableException异常，如果UnavailableException指示该实例永久不可用，则调用该实例的desttroy()方法。 服务终止：Servlet容器检测Servlet实例应该被移除时，调用destroy()方法，释放该实例使用的资源，等待Java的垃圾回收期回收。 5 Servlet上下文 运行在Java虚拟机中的每一个Web应用程序都有一个与之相关的Servlet上下文，Servlet API提供了ServletContext接口表示上下文，接口中定义了一些方法，Servlet可以使用这些方法与它的Servlet容器践行通信。 编写页面访问统计的实例：一个Web应用程序只有一个ServletContext对象，而且该对象可以被Web应用程序的所有Servlet所访问，因此使用ServletContext对象保存共享信息。 源码如下：CountServlet.java 注意：不同的Web应用程序具有不同的Servlet上下文，所以不同web应用程序不能利用ServletContext来共享属性；并且访问次数在重启Tomcat服务器后，重新计数，所以为了永久保存访问次数，可以存到文件或数据库中。 6 请求转发6.1 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建，用于封装一个路径标识的服务器资源。利用该对象，可以把请求转发给Servlet或JSP页面。 forward()：用于将请求从一个Servlet传递给服务器上的另外的Servlet或JSP页面或HTML文件；这个方法必须在响应被提交给客户端之前调用，调用后，原先在响应缓存中没有提交的内容将被自动清除。 include()：用于在响应中包含其他资源的内容。 上述两个方法区别：利用include()方法将请求转发给其他Servlet，被调用的Servlet对该请求做出的响应将并入原先的响应对象中，原先的Servlet还可以继续输出响应信息；而利用forward()方法将请求转发给其他的Servlet，将由被调用的Servlet负责对请求做出响应，而原先的Servlet的执行则终止。 6.2 得到RequestDispatcher对象 ServletContext接口的getRequestDispatcher()方法：参数必须以/开始，被解释为相对于当前上下文根的路径。 ServletRequest接口的getRequestDispatcher()方法：参数不但可以是相对于上下文的路径，也可以是相对于当前Servlet的路径；例如/myServlet、myServlet均合法。 6.3 请求转发的实例 CenterServlet.java，LoginServlet2.java。 6.4 sendRedirect()和forward()的区别 HttpServletResponse接口的sendRedirect()和RequestDispatcher接口的forward()方法都可以利用另外的资源为客户端服务，但是工作原理有本质的区别。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1让Servlet2 为客户端服务 Servlet1调用SendRedirect()方法，将客户端的请求重定向到Servlet2 浏览器访问Servlet2 Servlet2 对客户端的请求做出响应 重定向这个过程对用户透明，浏览器会自动完成新的访问。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1想让Servlet2对客户端进行响应，调用forward()方法，将请求转发给Servlet2进行处理 Servlet2对请求做出响应 调用forward()方法，对浏览器来说是透明的，浏览器只知道发出一个请求。 还有一个重要区别：sendRidirect()方法不但可以在位于同一主机上的不同web应用程序之间的重定向，而且可以将客户端重定向到其他服务器上的web应用程序资源","categories":[{"name":"Web总结","slug":"Web总结","permalink":"https://fengjiaxin.github.io/categories/Web总结/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://fengjiaxin.github.io/tags/Servlet/"}]},{"title":"StacK的一些例子","slug":"Stack","date":"2016-12-20T12:41:17.000Z","updated":"2017-02-09T07:51:42.857Z","comments":true,"path":"2016/12/20/Stack/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/20/Stack/","excerpt":"","text":"栈就是后进先出的数据结构1. 栈的简单实现，采用数组实现class StackX{ private int maxSize; private long[] stackArray; private int top; public StackX(int s){ maxSize = s; stackArray = new long[maxSize]; top=-1; } public void push(long value){ stackArray[++top] = value; } public long pop(){ return stackArray[top--]; } public long peek(){ return stackArray[top]; } public boolean isEmpty(){ return (top==-1); } public boolean isFull(){ return (top==maxSize-1); } } class stackApp { public static void main(String[] args) { StackX theStack = new StackX(10); theStack.push(20); theStack.push(40); theStack.push(60); theStack.push(80); while(!theStack.isEmpty()){ long value = theStack.pop(); System.out.print(value); System.out.print(&quot; &quot;); } System.out.println(&quot;&quot;); } } 2. 实现单词逆序功能class StackY private int maxSize; private char[] stackArray; private int top; public StackY(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } public boolean isFull(){ return (top==maxSize-1); } } class Reverser{ private String input; private String output; public Reverser(String in){ this.input =in; } public String doRev(){ int stackSize =input.length(); StackY theStack = new StackY(stackSize); for(int i=0;i&lt;input.length();i++){ char ch = input.charAt(i); theStack.push(ch); } output = &quot;&quot;; while(!theStack.isEmpty()){ char ch = theStack.pop(); output = output +ch; } return output; } } class ReverseApp{ public static void main(String[] args) throws IOException{ String input,output; while(true){ System.out.print(&quot;Enter a String:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; Reverser theReverser = new Reverser(input); output = theReverser.doRev(); System.out.println(&quot;Reverse:&quot;+output); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 3. 实现分隔符匹配 具体实现思想：程序从字符串不断读取字符，每次读取一个字符，若发现它是左分隔符，将它压栈，当从输入中读到一个右分割符时，弹出栈顶的的左分割符，并且查看它是否和右分隔符相匹配，如果不匹配，则程序报错；如果栈中没有左分隔符和右分隔符匹配，程序也报错；分隔符没有被匹配，表现为把所有的字符读入之后，栈中仍留有分隔符。 class StackZ{ private int maxSize; private char[] stackArray; private int top; public StackZ(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } } class BracketChecker{ private String input; public BracketChecker(String in){ this.input =in; } public void check(){ int stackSize = input.length(); StackZ theStack = new StackZ(stackSize); for(int j =0;j&lt;input.length();j++){ char ch =input.charAt(j); switch(ch) { case&apos;{&apos;: case&apos;[&apos;: case&apos;(&apos;: theStack.push(ch); break; case&apos;}&apos;: case&apos;]&apos;: case&apos;)&apos;: if(!theStack.isEmpty()){ char chx = theStack.pop(); if(chx ==&apos;{&apos; &amp;&amp; ch!=&apos;}&apos; || chx ==&apos;[&apos; &amp;&amp; ch!=&apos;]&apos; || chx ==&apos;(&apos; &amp;&amp; ch!=&apos;)&apos;) System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); }else System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); break; default: break; } } if(!theStack.isEmpty()){ System.out.println(&quot;Error :missing right delimiter&quot;); } } } class BracketsApp{ public static void main(String[] args) throws IOException{ String input; while(true){ System.out.print(&quot;Enter string containing delimiters:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; BracketChecker theChecker = new BracketChecker(input); theChecker.check(); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 总结：在编程过程中，好的编程习惯就是将方法细化，任何可能重复的方法将其封装到一个方法中，下次再用调用即可。","categories":[{"name":"JAVA数据结构","slug":"JAVA数据结构","permalink":"https://fengjiaxin.github.io/categories/JAVA数据结构/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://fengjiaxin.github.io/tags/Stack/"}]},{"title":"关于javaWeb学习过程中的一些个人感悟","slug":"关于javaWeb学习过程中的一些个人感悟","date":"2016-12-19T07:48:47.000Z","updated":"2017-02-12T12:58:23.525Z","comments":true,"path":"2016/12/19/关于javaWeb学习过程中的一些个人感悟/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/19/关于javaWeb学习过程中的一些个人感悟/","excerpt":"","text":"在本科阶段，毕设是利用SpringMVC +Hibernate+sql做一个教务信息发布平台，当时是机械兔的我哪里会啊，就是不断的找网上相似的教学视频，然后看源码进行修改，说句实话，当时就是盲目的该，有些错误只能google,自己一点也分析不出来，但是没办法，为了完成毕业设计，只好照猫画虎的改。 但是现在研究生阶段开发评标系统，网上也没有源码，我也毫无参考，对框架就更无从编写，在与前辈的交流过程中，发现自己对Servlet和Jsp了解太少，基础知识太弱，并且很多框架就是将Servlet进行封装，如果不明白底层的原理，将来运用框架也一定会有很多问题的。框架不断在变，但是基础原理并没有变，为了以后能更扎实的编码学习。现在开始记录我的学习Servlet和Jsp之旅，特此见证。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://fengjiaxin.github.io/categories/个人感悟/"}],"tags":[]}]}