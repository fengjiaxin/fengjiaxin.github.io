{"meta":{"title":"fengjiaxin's blog","subtitle":"滴水穿石","description":"记录一点一滴","author":"冯佳欣","url":"https://fengjiaxin.github.io"},"pages":[{"title":"标签","date":"2017-01-05T10:17:16.000Z","updated":"2017-01-05T11:39:14.780Z","comments":true,"path":"tags/index.html","permalink":"https://fengjiaxin.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-01-05T10:16:57.000Z","updated":"2017-01-05T11:38:57.999Z","comments":true,"path":"categories/index.html","permalink":"https://fengjiaxin.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java异常机制及原理","slug":"Java异常机制及相关问题","date":"2017-02-03T03:48:39.000Z","updated":"2017-02-03T04:42:44.456Z","comments":true,"path":"2017/02/03/Java异常机制及相关问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/Java异常机制及相关问题/","excerpt":"","text":"编写看这么多Java代码，有时候需要对可能出现的异常进行捕捉，有时候直接抛出，懵懵懂懂，那么今天重新看一遍关于Java异常处理机制，进行系统的总结。 ##1、异常机制概述 ## 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 2 、异常处理的流程 当程序中抛出一个异常后，程序从程序中导致异常的代码处跳出，java虚拟机检测寻找和try关键字匹配的处理该异常的catch块，如果找到，将控制权交到catch块中的代码，然后继续往下执行程序，try块中发生异常的代码不会被重新执行。如果没有找到处理该异常的catch块，在所有的finally块代码被执行和当前线程的所属的ThreadGroup的uncaughtException方法被调用后，遇到异常的当前线程被中止。 3、异常的结构 异常的继承结构：Throwable为基类，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。 ４、Error异常 Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。 5、RuntimeException异常 Exception异常包括RuntimeException异常和其他非RuntimeException的异常。RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。 出现RuntimeException后，系统会把异常一直往上层抛出，知道遇到处理代码为止。若没有处理块，则抛到最上层；如果是多线程就用Thread.run()方法抛出，如果是单线程，就用main()方法抛出。抛出之后，如果是线程，那么这个线程退出了。如果是主程序抛出的异常，那么整个程序就退出了。 6、Checked Exception异常 Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。 7、应该在声明方法抛出异常还是在方法中捕获异常？ 处理原则：捕捉并处理哪些知道如何处理的异常，而传递哪些不知道如何处理的异常。 8、使用finally块释放资源 finally关键字保证无论程序使用任何方式离开try块，finally中的语句都会被执行。在以下三种情况下会进入finally块： try块中的代码正常执行完毕。 在try块中抛出异常。 在try块中执行return、break、continue。 因此，当你需要一个地方来执行在任何情况下都必须执行的代码时，就可以将这些代码放入finally块中。当你的程序中使用了外界资源，如数据库连接，文件等，必须将释放这些资源的代码写入finally块中。 必须注意的是：在finally块中不能抛出异常。JAVA异常处理机制保证无论在任何情况下必须先执行finally块然后再离开try块，因此在try块中发生异常的时候，JAVA虚拟机先转到finally块执行finally块中的代码，finally块执行完毕后，再向外抛出异常。如果在finally块中抛出异常，try块捕捉的异常就不能抛出，外部捕捉到的异常就是finally块中的异常信息，而try块中发生的真正的异常堆栈信息则丢失了。 示例代码如下： Connection con = null; try { con = dataSource.getConnection(); …… } catch(SQLException e) { …… throw e;//进行一些处理后再将数据库异常抛出给调用者处理 } finally { try { con.close(); } catch(SQLException e) { e.printStackTrace(); …… } } 运行程序后，调用者得到的信息如下： java.lang.NullPointerException at myPackage.MyClass.method1(methodl.java:266) 而不是我们期望得到的数据库异常。这是因为这里的con是null的关系，在finally语句中抛出了NullPointerException，在finally块中增加对con是否为null的判断可以避免产生这种情况。 9、在使用异常处理时，还需要注意以下几个问题： Java异常用到了多态的概念，在进行异常捕捉时，先捕捉子类，再捕捉基类的异常信息，否则，捕获子类的代码块永远不会执行。 今早抛出异常，同时对捕捉的异常进行处理；而对于运行时异常，根本不需要理会。 可以根据实际需求自定义异常类，只要继承Exception类即可。 异常能处理就处理，不能处理就抛出。对于一般异常，如果不能进行有效的处理，最好转换为运行时异常抛出，对于最终没有处理的异常，JVM会进行处理。 10、在声明方法时候抛出异常 语法：throws（略） 为什么要在声明方法抛出异常？ 方法是否抛出异常与方法返回值的类型一样重要。假设方法抛出异常却没有声明该方法将抛出异常，那么客户程序员可以调用这个方法而且不用编写处理异常的代码。那么，一旦出现异常，那么这个异常就没有合适的异常控制器来解决。 为什么抛出的异常一定是已检查异常？ RuntimeException与Error可以在任何代码中产生，它们不需要由程序员显示的抛出，一旦出现错误，那么相应的异常会被自动抛出。遇到Error，程序员一般是无能为力的；遇到RuntimeException，那么一定是程序存在逻辑错误，要对程序进行修改；只有已检查异常才是程序员所关心的，程序应该且仅应该抛出或处理已检查异常。而已检查异常是由程序员抛出的，这分为两种情况：客户程序员调用会抛出异常的库函数；客户程序员自己使用throw语句抛出异常。 注意： 覆盖父类某方法的子类方法不能抛出比父类方法更多的异常，所以，有时设计父类的方法时会声明抛出异常，但实际的实现方法的代码却并不抛出异常，这样做的目的就是为了方便子类方法覆盖父类方法时可以抛出异常。 11、在方法中如何抛出异常 语法：throw（略） 抛出什么异常？ 对于一个异常对象，真正有用的信息是异常的对象类型，而异常对象本身毫无意义。比如一个异常对象的类型是ClassCastException，那么这个类名就是唯一有用的信息。所以，在选择抛出什么异常时，最关键的就是选择异常的类名能够明确说明异常情况的类。 异常对象通常有两种构造函数：一种是无参数的构造函数；另一种是带一个字符串的构造函数，这个字符串将作为这个异常对象除了类型名以外的额外说明。 那么总结了这么多，我们做几道题进行热身： 1、Error和Exception有什么区别 答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 2、列出一些你常见的运行时异常？ ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 3、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。 4、TimedOutException不是一个RuntimeException，下面的那些选项载入程序中，使程序可以正常运行？ A public void final() B public void final() throws Exception C public void final() throws TimedOutException D public void final() throw TimedOutException E public throw TimedOutException void final() 答案：BC 试题分析： 如果一个程序在运行时候有异常发生，而这个异常又不是RuntimeException或者Error，那么程序必须对这个异常进行捕获处理或者声明抛出该异常。捕获异常使用try-catch-finally，而声明异常则是在声明方法的同时将会发生的异常进行声明，使用关键字throws。 A项没有使用关键字声明异常，所以是错误的。由于Exception是所有异常的父类，当然也可以代表TimedOutException，所以B项是正确的。C项符合声明异常的格式，是正确的。在D项中，throw是抛出异常，而不是声明异常，关键字使用错误，所以D项是错的。E项的语法格式是错误的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://fengjiaxin.github.io/tags/Exception/"},{"name":"Error","slug":"Error","permalink":"https://fengjiaxin.github.io/tags/Error/"},{"name":"异常处理","slug":"异常处理","permalink":"https://fengjiaxin.github.io/tags/异常处理/"}]},{"title":"如何实现对象的clone","slug":"如何实现对象的clone","date":"2017-02-02T13:38:30.000Z","updated":"2017-02-02T14:29:19.827Z","comments":true,"path":"2017/02/02/如何实现对象的clone/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/如何实现对象的clone/","excerpt":"","text":"有两种方式： 1. 实现Cloneable接口并重写Object类中的clone()方法； Java中所有的类默认继承自Object类，而Object类提供了讴歌clone()方法，这个方法的作用是返回一个Object对象的复制，这个复制函数返回的是一个新的对象而不是一个引用，那么如何使用呢？代码如下： class Obj implements Cloneable{ private int aInt =0; public int getInt(){ return aInt; } public void setAInt(int int1){ aInt = int1; } public void changeInt(){ this.aInt =1; } public Object clone(){ Object o = null; try { o = (Object)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } public class TestRef { public static void main(String[] args) { Obj a = new Obj(); Obj b = (Obj) a.clone(); b.changeInt(); System.out.println(a.getInt());//0 System.out.println(b.getInt());//1 } } 2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆;代码如下： import java.io.Serializable; public class Employee implements Serializable { private static final long serialVersionUID = -6470090944414208496L; private String name; private int id; transient private int salary; @Override public String toString(){ return &quot;Employee{name=&quot;+name+&quot;,id=&quot;+id+&quot;,salary=&quot;+salary+&quot;}&quot;; } //getter and setter methods public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getSalary() { return salary; } public void setSalary(int salary) { this.salary = salary; } } 注意：static代笔类的静态成员，transient代表对象的临时数据，因此被声明为这两种类型的数据成员是不能够被序列化的。 现在我们假设需要把我们的对象写入文件，之后从相同的文件中将其反序列化，因此我们需要一些工具方法，通过使用ObjectInputStream和ObjectOutputStream来达到序列化的目的。 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; /** * A simple class with generic serialize and deserialize method implementations * * */ public class SerializationUtil { // deserialize to Object from given file public static Object deserialize(String fileName) throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(fileName); ObjectInputStream ois = new ObjectInputStream(fis); Object obj = ois.readObject(); ois.close(); return obj; } // serialize the given object and save it to file public static void serialize(Object obj, String fileName) throws IOException { FileOutputStream fos = new FileOutputStream(fileName); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); fos.close(); } } 测试程序： import java.io.IOException; public class SerializationTest { public static void main(String[] args) { String fileName=&quot;employee.ser&quot;; Employee emp = new Employee(); emp.setId(100); emp.setName(&quot;Pankaj&quot;); emp.setSalary(5000); //serialize to file try { SerializationUtil.serialize(emp, fileName); } catch (IOException e) { e.printStackTrace(); return; } Employee empNew = null; try { empNew = (Employee) SerializationUtil.deserialize(fileName); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } System.out.println(&quot;emp Object::&quot;+emp); System.out.println(&quot;empNew Object::&quot;+empNew); } } 运行以上测试程序，可以得到以下输出。 emp Object::Employee{name=Pankaj,id=100,salary=5000} empNew Object::Employee{name=Pankaj,id=100,salary=0} 由于salary是一个transient变量，它的值不会被存入文件中，因此也不会在新的对象中被恢复。类似的，静态变量的值也不会被序列化，因为他们是属于类而非对象的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://fengjiaxin.github.io/tags/clone/"}]},{"title":"hibernate如何提高性能和二级缓存的含义","slug":"hibernate如何提高性能和二级缓存的含义","date":"2017-02-02T12:37:04.000Z","updated":"2017-02-02T15:08:29.673Z","comments":true,"path":"2017/02/02/hibernate如何提高性能和二级缓存的含义/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/hibernate如何提高性能和二级缓存的含义/","excerpt":"","text":"之前编写了hibernate的一些相关代码，现在总结一些细节。 问题： 在使用Hibernate时如何提高性能？ 延迟加载，当hibernate从数据库中获取一个对象数据，获取一个对象的集合属性值时或者获取某一个对象所关联的另一个对象时，并不会立即从数据库中加载到对象中，而是通过建立一个代理对象，把这个对象的属性值都设置为默认值，只有这些数据在被使用时才会从数据库中加载对应的数据。 缓存技术。hibernate提供了一级缓存与二级缓存，合理的利用缓存有助于提高系统的性能，通过合理配置缓存的参数可以避免不合理的利用缓存导致内存的过度消耗降低系统的性能。 优化查询语句。 说了这么多，那么什么是hibernate的二级缓存？ 缓存的目的是为了通过减少应用程序对物理数据源访问的次数来提高程序运行的效率，原理则是把当前或接下来一段时间可能会用到的数据保存在内存中，在使用时直接从内存中读取。 在hibernate中有一级缓存和二级缓存的概念，一级缓存由Session来管理，二级缓存由SessionFactory来管理，在使用时二级缓存可有可无，但是一级缓存必不可少。 一级缓存的使用场合如下：当使用session查询数据时，首先会在Session内部查找该对象是否存在，若存在，直接返回，否则，到数据库中区查询，并将查询结果缓存起来以便后期使用；缺点是当使用Session来表示一次会话中，它的生命周期较短，并且它是线程不安全的，不能够被多个线程共享，因此在实际使用中对效率的提升并不明显。 二级缓存用来为Hibernate配置一种全局的缓存，以便实现多个线程和事物共享。在使用了二级缓存机制后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，最后才去数据库中查找，与一级缓存相比，二级缓存是独立于hibernate的软件部件，属于第三方的产品，hibernate3以后默认使用的产品是EhCache. 二级缓存一般适用于以下几种情况： 数据量较小，如果数据量较大，缓存太多，大量消耗内存，造成内存资源短缺，从而降低系统的性能。 对数据的修改较少，如果进行大量的修改，就需要频繁的同步，也会影响系统的性能。 不会被大量的应用共享的数据，如果数据被大量线程或事物共享，多线程访问的同步机制会影响系统的性能。 不是很重要的数据，如果数据非常重要，对数据的准确性要求非常高，最好不要使用二级缓存。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://fengjiaxin.github.io/tags/hibernate/"}]},{"title":"静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同","slug":"静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同","date":"2017-02-02T11:55:46.000Z","updated":"2017-02-02T12:01:39.257Z","comments":true,"path":"2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","excerpt":"","text":"Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 代码示例如下： /** * 扑克类（一副扑克） * */ public class Poker { private static String[] suites = {&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;}; private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; private Card[] cards; /** * 构造器 * */ public Poker() { cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) { for(int j = 0; j &lt; faces.length; j++) { cards[i * 13 + j] = new Card(suites[i], faces[j]); } } } /** * 洗牌 （随机乱序） * */ public void shuffle() { for(int i = 0, len = cards.length; i &lt; len; i++) { int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; } } /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) { return cards[index]; } /** * 卡片类（一张扑克） * [内部类] * */ public class Card { private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) { this.suite = suite; this.face = face; } @Override public String toString() { String faceStr = &quot;&quot;; switch(face) { case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); } return suite + faceStr; } } } 测试代码如下： class PokerTest { public static void main(String[] args) { Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A } } 面试题：下面的代码哪些地方会产生编译错误？ class Outer { class Inner {} pｕblic static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); } } 解答：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： new Outer().new Inner();","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"静态嵌套类(Static Nested Class)","slug":"静态嵌套类-Static-Nested-Class","permalink":"https://fengjiaxin.github.io/tags/静态嵌套类-Static-Nested-Class/"},{"name":"内部类（Inner Class）","slug":"内部类（Inner-Class）","permalink":"https://fengjiaxin.github.io/tags/内部类（Inner-Class）/"}]},{"title":"抽象类（abstract class）和接口（interface）有什么异同","slug":"抽象类（abstract-class）和接口（interface）有什么异同","date":"2017-02-02T11:21:13.000Z","updated":"2017-02-02T11:45:58.257Z","comments":true,"path":"2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","excerpt":"","text":"如果一个类中包含抽象方法，那么这个类就是抽象类，在Java中可以通过abstract关键字声明该类或该方法时抽象的；接口就是指一些方法的集合，接口中的所有方法都没有方法体。 只要包含一个抽象方法的类就必须别声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明的抽象方法不能包含方法体，在实现时，必须包含相同的或者更低的访问级别；接口中的所有方法都是抽象的，接口中的成员变量都是static final类型。 接口与抽象类的相同点如下： 都不能被实例化。 接口类的实现类或抽象类的子类都只有实现了接口或抽象类的方法后才能被实例化。 接口是抽象类的不同点如下： 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法，而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。 接口需要实现，但是抽象类只能被继承。 接口强调特定功能的实现，其设计理念是“has- a”关系，而抽象类强调所属关系，其设计理念为“is- a”关系。 接口中定义的成员变量默认为public static final,并且必须赋给其初值，其所有成员方法都是public、abstract的；而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法。 接口被用于实现比较常用的功能，便于日后的维护或添加删除方法；而抽象类更倾向于充当公共类的角色，不适用于日后重新对里面的代码进行修改。 一般而言，抽象类多用于在同类事物中有无法具体描述的方法的场景，所以当子类和父类之间存在有逻辑上的层次结构时，推荐使用抽象类；而接口多用于不同类之间，定义不同类之间的通信规则。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"https://fengjiaxin.github.io/tags/抽象类/"},{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"}]},{"title":"Java中字符串与存储的机制","slug":"Java中字符串与存储的机制","date":"2017-02-02T10:29:28.000Z","updated":"2017-02-02T11:22:02.217Z","comments":true,"path":"2017/02/02/Java中字符串与存储的机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中字符串与存储的机制/","excerpt":"","text":"今天准备总结一下String对象的存储机制 字符串的声明与初始化有如下两种情况： String s1 = new String(“abc”)//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后用new关键字在堆中创建新的对象 String s2 = “abc”//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后s2指向字符串常量池中”abc”对象的首地址。 具体来说： String s1 = &quot;abc&quot;//把&quot;abc&quot;放到常量池中，在编译时产生 String s2 = &quot;ab&quot;+&quot;c&quot;//把&quot;ab&quot;+&quot;c&quot;转换成字符串常量&quot;abc&quot;放到常量区中 String s3 = new String(&quot;abc&quot;)//在运行时把&quot;abc&quot;放到堆里面 String对象的intern()方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象 在明白了以上两点，那么我们来做两道笔试题： 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？ StringBuffer对象适用于字符串经常操作，不产生而额外内存，而String对象不可变，一旦创建不能修改，但是操作简单，效率高，所以适用于字符串较少时，操作次数少的情况下。 请说出下面程序的输出。 class StringEqualTest { public static void main(String[] args) { String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); } } **结果为** System.out.println(s1==s2);//false System.out.println(s1==s5);//true System.out.println(s1==s6);//false System.out.println(s1==s6.intern());//true System.out.println(s2==s2.intern());//false 解释：字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象； String s6 = s3+s4//等价于 StringBuilder temp = s3; temp.append(s4); String s6 = temp.toString(); 所以S6是创建一个新的StringBuilder对象的toString()方法处理成String对象，因此s1==s6为false。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"String","slug":"String","permalink":"https://fengjiaxin.github.io/tags/String/"},{"name":"常量池","slug":"常量池","permalink":"https://fengjiaxin.github.io/tags/常量池/"}]},{"title":"Java中i++和++i的区别和理解","slug":"Java中i++和++i的区别和理解","date":"2017-02-02T09:31:43.000Z","updated":"2017-02-02T10:03:16.735Z","comments":true,"path":"2017/02/02/Java中i++和++i的区别和理解/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中i++和++i的区别和理解/","excerpt":"","text":"今天在做Java题时碰到了关于i++的问题，题目是这样的： public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 最终答案是0。 关于值传递我还是理解的，但是i=i++这个语句我又有点懵了，于是找了相关资料，总结就是JVM的机制所引起的，接下来我要详细介绍一下这方面知识，也算给自己一个交代。 jvm里面有两个存储区，一个是暂存区（是一个堆栈，以下称为堆栈），另一个是变量区。jvm会这样运行这条语句： JVM把count值（其值是0）拷贝到临时变量区。 count值加1，这时候count的值是1。 返回临时变量区的值。 返回值赋值给count，此时count值被重置成0。 所以上题的i= i++应该是下面的过程 int i =0; temp = i;//temp 为临时变量 i =i+1;//i =1 i = temp //i =0 对于自增运算++j与j++，由于加一的执行顺序不同，所以Java中有中间缓存变量来储存其单个表达式的值，而j的自增自减的结果依然保留在原来的变量储存区。因为本体是j的值，而单个表达式的值是中间产生的一个临时变量值，是在整条计算表达式结束后就可以抛弃的值，所以用个临时中间缓存变量在放就可以了。 按字面理解就是i++ 等价于 temp =i;//jvm把i的值拷贝到临时变量temp i =i+1;//i自加1 返回临时变量temp的值0作为表达式i++/++i的值 感觉了解了Java的自增原理，那么我们在练习一道题： int j = 0; j =++j + j++ +j++ + j++; 最终结果为7，详细解答如下 j =j+1 =1; temp1 = j =1; temp2 = j =1; j = j+1 =2; temp3 = j = 2； j =j+1 =3; temp4 = j = 3; j = j+1 =4; j = temp1 +temp2 +temp3 +temp4 = 1+1+2+3 =7; 总结：今天算是终于弄明白i++的原理了，有些问题一定要弄清楚，不能糊弄过去，加油！！！","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"}]},{"title":"基本操作","slug":"基本操作","date":"2017-02-01T11:51:36.000Z","updated":"2017-02-01T12:04:59.540Z","comments":true,"path":"2017/02/01/基本操作/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/01/基本操作/","excerpt":"","text":"命令总结常用命令hexo new &quot;postName&quot; #新建文章 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://fengjiaxin.github.io/categories/备忘录/"}],"tags":[{"name":"基本命令操作","slug":"基本命令操作","permalink":"https://fengjiaxin.github.io/tags/基本命令操作/"}]},{"title":"Java典型设计模式-观察者模式","slug":"Java典型设计模式-观察者模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-01-09T05:26:59.884Z","comments":true,"path":"2017/01/09/Java典型设计模式-观察者模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-观察者模式/","excerpt":"","text":"观察者模式是类和类之间的关系，不涉及到继承。 观察者模式很好理解，类似于邮件订阅和RSS订阅，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 public interface Observer { public void update(); } public class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } } public class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } } public interface Subject { /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); } import java.util.Enumeration; import java.util.Vector; public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } public class ObserverTest { public static void main(String[] args) { Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); } } 运行结果： update self! observer1 has received! observer2 has received! 也许看完实例之后还是比较抽象，再将文字描述和代码实例看一两遍吧，然后结合工作中看哪些场景可以使用这种模式以加深理解。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://fengjiaxin.github.io/tags/观察者模式/"}]},{"title":"Java典型设计模式-适配器模式","slug":"Java典型设计模式-适配器模式","date":"2017-01-09T05:03:57.000Z","updated":"2017-01-09T05:19:12.704Z","comments":true,"path":"2017/01/09/Java典型设计模式-适配器模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-适配器模式/","excerpt":"","text":"适配器模式 适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。有点抽象，我们来看看详细的内容。 类的适配器模式 类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。 public class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } } public interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); } public class Adapter extends Source implements Targetable { public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } } public class AdapterTest { public static void main(String[] args) { Targetable target = new Adapter(); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 对象的适配器模式 对象的适配器模式的基本思路和类的适配器模式相同，只是将Adapter类作修改成Wrapper，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source) { super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } } public class AdapterTest { public static void main(String[] args) { Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 接口的适配器模式 接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行了。 在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： public interface Sourceable { public void method1(); public void method2(); } //抽象类Wrapper2： public abstract class Wrapper2 implements Sourceable{ public void method1(){} public void method2(){} } public class SourceSub1 extends Wrapper2 { public void method1(){ System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); } } public class SourceSub2 extends Wrapper2 { public void method2(){ System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); } } public class WrapperTest { public static void main(String[] args) { Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); } } 测试输出： the sourceable interface&apos;s first Sub1! the sourceable interface&apos;s second Sub2! 总结一下三种适配器模式的应用场景 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://fengjiaxin.github.io/tags/适配器模式/"}]},{"title":"Java典型设计模式-创建性模式","slug":"Java典型设计模式-工厂方法模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-01-09T04:27:36.177Z","comments":true,"path":"2017/01/09/Java典型设计模式-工厂方法模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-工厂方法模式/","excerpt":"","text":"1 工厂方法模式 工厂方法模式分为三种：普通工厂模式、多个工厂方法模式和静态工厂方法模式。 1.1 普通工厂模式 普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 public interface MyInterface { public void print(); } public class MyClassOne implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassOne&quot;); } } public class MyClassTwo implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassTwo&quot;); } } public class MyFactory { public MyInterface produce(String type) { if (&quot;One&quot;.equals(type)) { return new MyClassOne(); } else if (&quot;Two&quot;.equals(type)) { return new MyClassTwo(); } else { System.out.println(&quot;没有要找的类型&quot;); return null; } } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produce(&quot;One&quot;); myi.print(); } } 再回头来理解这句话：普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 1.2 多个工厂方法模式 多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。我们修改MyFactory和FactoryTest如下： public class MyFactory { public MyInterface produceOne() { return new MyClassOne(); } public MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produceOne(); myi.print(); } } 再回头来理解这句话：多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。 1.3 静态工厂方法模式 静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。我们修改MyFactory和FactoryTest如下： public class MyFactory { public static MyInterface produceOne() { return new MyClassOne(); } public static MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyInterface myi = MyFactory.produceOne(); myi.print(); } 再回顾：静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 2 抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则。 为解决这个问题，我们来看看抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 这样就符合闭包原则了 下面来看看代码： MyInterface、MyClassOne、MyClassTwo不变。 新增如下接口和类： public interface Provider { public MyInterface produce(); } public class MyFactoryOne implements Provider { @Override public MyInterface produce() { return new MyClassOne(); } } public class MyFactoryTwo implements Provider { @Override public MyInterface produce() { return new MyClassTwo(); } } 修改测试类FactoryTest如下： public class FactoryTest { public static void main(String[] args){ Provider provider = new MyFactoryOne(); MyInterface myi = provider.produce(); myi.print(); } } 再回顾：抽象工厂模式就是创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 3 单例模式 单例模式就是一个类只有一个实例，不允许外界创建新的对象，但是可以调用类的实例，代码如下： public class MyObject { private static MyObject myObject; private MyObject() { } public static MyObject getInstance() { if (myObject != null) { } else { myObject = new MyObject(); } return myObject; } } 但是这样会引发多线程问题，这个问题就先放下，对线程有了更深入的了解后在回看。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"https://fengjiaxin.github.io/tags/工厂方法模式/"},{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"https://fengjiaxin.github.io/tags/抽象工厂模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://fengjiaxin.github.io/tags/单例模式/"}]},{"title":"Java设计模式-三大类","slug":"Java设计模式-三大类","date":"2017-01-09T03:59:35.000Z","updated":"2017-01-09T04:10:59.288Z","comments":true,"path":"2017/01/09/Java设计模式-三大类/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java设计模式-三大类/","excerpt":"","text":"在前面的介绍中我们知道了Java设计模式的六大原则，那么基于这六大原则，前辈们总结出了23种设计模式供大家学习，那么我这里就简单说明介绍一下吧，稍后再下一篇博客在介绍4种典型的设计模式。 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 之后主要介绍工厂方法模式，抽象工厂模式，单例模式，适配器模式，观察者模式，这五个模式在Java面试中可能会问到，所以接下来详细介绍一下这五种模式。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"设计模式六大原则(5): 聚合/复用原则","slug":"设计模式六大原则-5-聚合-复用原则","date":"2017-01-06T03:58:37.000Z","updated":"2017-01-08T04:44:11.164Z","comments":true,"path":"2017/01/06/设计模式六大原则-5-聚合-复用原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-5-聚合-复用原则/","excerpt":"","text":"1 问题的由来 在实际开发中，新建一个类可能会用到多个以前的类的方法，但是在设计时是不能轻易采用继承机制的；因为在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 2 聚合/复用原则 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。 组合或聚合关系可以将成员对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见。 相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 3 举例说明 在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如下所示： 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。 现使用合成复用原则对其进行重构。在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如下所示： CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中。 如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。。 4 总结 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"聚合/复用原则","slug":"聚合-复用原则","permalink":"https://fengjiaxin.github.io/tags/聚合-复用原则/"}]},{"title":"设计模式六大原则(4): 迪米特原则","slug":"设计模式六大原则-4-迪米特原则","date":"2017-01-06T03:58:12.000Z","updated":"2017-01-07T02:44:14.503Z","comments":true,"path":"2017/01/06/设计模式六大原则-4-迪米特原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-4-迪米特原则/","excerpt":"","text":"1 问题的由来 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 2 迪米特原则 通俗的来讲：就是一个类对自己依赖的类知道的越少越好。 对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。 更简单的定义：只与直接的朋友通信。 那么什么是直接的朋友？？？ 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。 出现成员变量、方法参数、方法返回值中的类为直接的朋友， 出现在局部变量中的类则不是直接的朋友。 也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 3 举例 举一个代码例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。 先看一个错误的例子 //总公司员工 class Employee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司员工 class SubEmployee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司管理 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } } //总公司管理 class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1){ System.out.println(e.getId()); } List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } public class Client{ public static void main(String[] args){ CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); } } 主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。 修改后的代码 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } public void printEmployee(){ List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list){ System.out.println(e.getId()); } } } class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 3 总结 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"迪米特原则","slug":"迪米特原则","permalink":"https://fengjiaxin.github.io/tags/迪米特原则/"}]},{"title":"设计模式六大原则(3): 接口隔离原则","slug":"设计模式六大原则-3-接口隔离原则","date":"2017-01-06T03:57:45.000Z","updated":"2017-01-07T02:20:01.272Z","comments":true,"path":"2017/01/06/设计模式六大原则-3-接口隔离原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-3-接口隔离原则/","excerpt":"","text":"1 问题的由来 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类B和类D来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 2 接口隔离原则 客户端不应该依赖它不需要的接口 意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。 类间的依赖关系应该建立在最小的接口上 接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。 接下来是代码示例： public interface I { public void method1(); public void method2(); public void method3(); } public class B implements I{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } @Override public void method3() {//类B并不需要接口I的方法3功能，但是由于实现接口I，所以不得不实现方法3 //在这里写一个空方法 } } public class D implements I{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } @Override public void method1() {//类D并不需要接口I的方法1功能，但是由于实现接口I，所以不得不实现方法1 //在这里写一个空方法 } } //类A通过接口I依赖类B public class A { public void depend1(I i){ i.method1(); } } //类C通过接口I依赖类D public class C { public void depend1(I i){ i.method3(); } } public class Client { public static void main(String[] args) { A a = new A(); I i1 = new B(); a.depend1(i1); C c = new C(); I i2 = new D(); c.depend1(i2); } } 运行结果： 类B实现了接口I的方法1 类D实现了接口I的方法3 可以看出，如果接口过于臃肿，不同业务逻辑的抽象方法都放在一个接口内，会造成它的实现类必须实现自己并不需要的方法 这种设计方式显然是不妥当的。所以应该把接口I拆分成3个接口，使得实现类只需要实现自己需要的接口即可，修改代码如下： public interface I1 { public void method1(); } public interface I2 { public void method2(); } public interface I3 { public void method3(); } public class B implements I1,I2{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } } public class D implements I2,I3{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } } 3 与单一职责区别 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。4 总结 对于接口隔离原则来说，接口尽量小，但是也要有限度。 对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"接口隔离原则","slug":"接口隔离原则","permalink":"https://fengjiaxin.github.io/tags/接口隔离原则/"}]},{"title":"设计模式六大原则(2): 依赖倒置原则","slug":"设计模式六大原则-2-依赖倒置原则","date":"2017-01-06T03:57:15.000Z","updated":"2017-01-07T01:57:16.170Z","comments":true,"path":"2017/01/06/设计模式六大原则-2-依赖倒置原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-2-依赖倒置原则/","excerpt":"","text":"1 问题的由来 类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑。类B和C是底层模块，负责基本的原子操作。假如修改类A，将会给程序带来不必要的风险。 2 依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 抽象：即抽象类或接口，两者是不能够实例化的。 细节：即具体的实现类，实现接口或者继承抽象类所产生的类。 代码例子：这里直接饮用李天炜的讲解例子，我觉得讲的很好。 //具体Jim人类 public class Jim { public void eat(Apple apple){ System.out.println(&quot;Jim eat &quot; + apple.getName()); } } //具体苹果类 public class Apple { public String getName(){ return &quot;apple&quot;; } } public class Client { public static void main(String[] args) { Jim jim = new Jim(); Apple apple = new Apple(); jim.eat(apple); } } 运行结果：Jim eat apple 其实上面这个设计很不好，如果吃香蕉的话，就要改变依赖类，怎么吃水果是人自己的选择，为什么还要修改自己的代码；并且Jim类和Apple类紧耦合，不太符合低耦合，高内聚的原则，那怎么解决这类问题呢？ 而根据依赖倒置原则，我们可以提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。 修改代码如下 //人接口 public interface People { public void eat(Fruit fruit); } //水果接口 public interface Fruit { public String getName(); } //具体Jim人类 public class Jim implements People{ public void eat(Fruit fruit){ System.out.println(&quot;Jim eat &quot; + fruit.getName()); } } //具体苹果类 public class Apple implements Fruit{ public String getName(){ return &quot;apple&quot;; } } //具体香蕉类 public class Banana implements Fruit{ public String getName(){ return &quot;banana&quot;; } } public class Client { public static void main(String[] args) { People jim = new Jim(); Fruit apple = new Apple(); Fruit Banana = new Banana();//这里符合了里氏替换原则 jim.eat(apple); jim.eat(Banana); } } 运行结果： Jim eat apple Jim eat banana People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，做到了高层模块不应该依赖低层模块，两者都应该依赖于抽象。 People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节。 Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。 3 什么是倒置 就是提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。 4 依赖的三种实现方式 对象的依赖关系有三种方式来传递: 接口方法中声明依赖对象 public interface People { public void eat(Fruit fruit); } 构造方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public Jim(Fruit fruit){//构造方法传递依赖对象 this.fruit = fruit; } } Setter方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public void setFruit(Fruit fruit){//setter方式传递依赖对象 this.fruit = fruit; } } 5 优点 从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。 还有一个优点是，实际项目开发中，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。 6 总结 依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。 依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。 但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"依赖倒置原则","slug":"依赖倒置原则","permalink":"https://fengjiaxin.github.io/tags/依赖倒置原则/"}]},{"title":"设计模式六大原则(1): 里氏替换原则","slug":"设计模式六大原则-1-里氏替换原则","date":"2017-01-06T03:56:46.000Z","updated":"2017-01-07T02:00:58.389Z","comments":true,"path":"2017/01/06/设计模式六大原则-1-里氏替换原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-1-里氏替换原则/","excerpt":"","text":"1 问题由来 对象有三大特性：封装、继承、多态，子类在继承父类后，经常任意重写父类的方法，这时候可能会导致父类的原功能发生故障。 2 里氏替换原则 通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。 更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。 已经不能再通俗了，那么我们就以简单的例子更好地理解吧： 这里我引用的是李天炜的例子，当初看的时候理解的很清楚，多谢前辈！ //抽象父类电脑 public abstract class Computer { public abstract void use(); } class IBM extends Computer{ @Override public void use() { System.out.println(&quot;use IBM Computer.&quot;); } } class HP extends Computer{ @Override public void use() { System.out.println(&quot;use HP Computer.&quot;); } } public class Client{ public static void main(String[] args) { Computer ibm = new IBM(); Computer hp = new HP();//引用基类的地方能透明地使用其子类的对象。 ibm.use(); hp.use(); } } 3 四层含义 里氏替换原则包含以下4层含义： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。 子类中可以增加自己特有的方法。 在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 这个其实很好理解，就是入口更宽松，那么就以代码更好地理解吧！ import java.util.HashMap; public class Father { public void func(HashMap m){ System.out.println(&quot;执行父类...&quot;); } } import java.util.Map; public class Son extends Father{ public void func(Map m){//方法的形参比父类的更宽松 System.out.println(&quot;执行子类...&quot;); } } import java.util.HashMap; public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 HashMap h = new HashMap(); f.func(h); } } 运行结果：执行父类… 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 这个也不难理解，就是出口更严格，那么就以代码更好地理解吧！ import java.util.Map; public abstract class Father { public abstract Map func(); } import java.util.HashMap; public class Son extends Father{ @Override public HashMap func(){//方法的返回值比父类的更严格 HashMap h = new HashMap(); h.put(&quot;h&quot;, &quot;执行子类...&quot;); return h; } } public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 System.out.println(f.func()); } } 4 总结 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性，不符合设计模式的低耦合，高内聚，因此系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"里氏替换原则","slug":"里氏替换原则","permalink":"https://fengjiaxin.github.io/tags/里氏替换原则/"}]},{"title":"Java设计模式原则（个人总结）","slug":"Java设计模式-6大原则","date":"2017-01-05T14:06:21.000Z","updated":"2017-01-05T14:26:40.921Z","comments":true,"path":"2017/01/05/Java设计模式-6大原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/Java设计模式-6大原则/","excerpt":"","text":"这学期学习了软件工程课程，对Java语言的理解更近一步，但是不足还是那么多，在设计系统的过程中其实我就一直在思考设计模式的问题，都说了解了设计模式的程序员才能更好地设计出系统，那么今天我就本着执着的精神总结一下关于ava设计模式的的基本原则。 设计模式原则 书上总结有六大原则，首先就简单说明一下这六大原则。 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 里氏代换原则（Liskov Substitution Principle） 子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用 子类返回值的能力是比父类小的 任何子类方法可以声明抛出父类方法声明异常的子类；而不能声明抛出父类没有声明的异常。 依赖倒转原则（Dependence Inversion Principle） 是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 到这里，相信都被概念弄蒙了，其实意思很好理解，就是降低耦合性，提高内聚性，那么下一篇就以代码举例详解设计模式原则，敬请期待！","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"6大原则","slug":"6大原则","permalink":"https://fengjiaxin.github.io/tags/6大原则/"}]},{"title":"JVM内存回收策略","slug":"JVM内存回收策略","date":"2017-01-05T03:17:28.000Z","updated":"2017-01-05T13:13:26.849Z","comments":true,"path":"2017/01/05/JVM内存回收策略/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/JVM内存回收策略/","excerpt":"","text":"开发人员一般情况下不需要了解内存这个概念，因为内存的开辟与回收由JVM操作，但是在学习了操作系统之后，想要了解数据在Java是如何申请内存的，总结而言就是通常的显示内存申请有如下两种： 静态内存分配 动态内存分配 1.1 静态内存分配 在Java中静态内存分配是指在Java编译时就已经能确定需要的内存空间，当程序被加载时系统把内存一次性分配给它；这些内存不会再程序执行时发生变化，直到程序执行结束时内存才会被回收。在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存的。 1.2 动态内存分配和回收 在Java中对象的内存空间是动态分配的，所谓动态分配就是在程序执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。 从前面的分析中可知内存的分配实在对象创建时发生的，而内存的回收是以对象不再引用为前提的，这种动态内存的分配和回收是和Java中的一些数据结构类型关联的。 如何确定这个对象什么时候不再被使用，如何回收，这正是JVM的垃圾收集器的工作。 1.3 如何检测垃圾 垃圾收集器的工作： 正确检测出垃圾对象 释放垃圾对象占用的内存空间 如何检测出垃圾是GC上的关键；从前面的分析可以总结出：只要某个对象不再被其他的活动对象引用，这个对象就可以被回收了，活动对象指的是能够被一个根对象集合到达的对象。 那么根对象集合中有些什么呢？ 在方法中局部变量区的引用 在Java操作栈中的对象引用 在常量池的对象引用 在本地方法中次有的对象引用 类的Class对象 JVM在做垃圾回收时就会检查堆中的所有对象是否都会被这些跟对象直接或间接引用，能够被引用的对象就是活动对象，否则就被GC回收。 1.4 基于分代的垃圾收集算法 算法的设计思路：把对象按照寿命长短分组，分为年轻代和老年代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么把这个对象划分到老年代。老年代的收集频度不像年轻代那么频繁，这样就减少了每次垃圾收集时所要扫描的对象的数量，提高了垃圾回收效率。 这种设计思路是把堆划分为若干个子堆，每个子堆对应一个年龄代，如下图所示： JVM将整个堆划分为Young区，Old区，Perm区，分别存放不同年龄的对象，这三个区存放的对象有如下区别： Young区分为Eden区和Survivor区，其中所有新创建的对象都在Eden区，当Eden区满后会触发minor GC将Eden区让存活的对象复制到其中一个Survivor中，另外一个Survivor区中的存活对象也复制到这个Survivor中，保证始终有一个Survivor区是空的。 Old区存放的是Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将对象存放到Survivor区中，如果Survivor区中仍然存不下这些对象，GC收集器会将这些对象直接存放到Old区，如果Survivor区中的对象足够老，直接存放到Old区中，如果Old区中也满了，触发Full GC，回收整个堆内存。 Perm区存放的是类的Class对象，如果一个类被频繁的加载，可能会导致Perm区满，Perm区的垃圾回收也是有Full GC触发的。 1.5 minor GC、full GC、major GC区别 Minor GC 是指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。注意：除了将Eden区的非活动对象回收后，还会把一些老对象复制到Old区中。 Major GC 是清理老年代。 Full GC 是清理整个堆空间—包括年轻代和老年代。 许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的 1.6 Hotspot三类垃圾收集算法 Serial Collector(单线程收集器)：是JVM在client模式下的默认GC方式，当Eden空间不足时，触发Minor GC，会先检查之前每次Minor GC晋升到Old区的对象的平均大小，如果Old区的剩余空间小于平均大小，则直接触发Full GC，如果Old区的剩余空间大于平均大小，则看HandlePromotionFailure的值。如果为true，仅触发Minor GC，否则再触发一次Full GC。当Survivor区中的To Space放不下这些对象时，这些对象被放入Old区，如果Old或Perm区空间不足，将会触发Full GC。JVM的GC操作是串行的，JVM中的其他应用程序会全部停止。 parallel GC根据Minor GC和Full GC的不同分为三种，分别是ParNewGC，ParallelGC和ParallelOldGC。 ParNewGC：回收策略与Serial Collector相似，只是回收不是单线程的，而是多线程并行回收。 ParallelGC：Server下默认的GC方式。当在Eden中申请内存发生不够的情况时，看当前申请的空间是否大于Eden的一半，如果大于则直接在Old区中分配空间，如果小于则触发Minor GC。触发Minor GC前会检查过去每次晋升Old区的平均大小是否大于Old区的剩余空间。如果大于则再次触发Full GC，在这次触发后仍会按这个规则重新检查一次，Full GC会执行两次。 ParallelOldGC：与ParalelGC不同之处在于Full GC。Parallel GC的Full GC清空整个Heap堆中的垃圾对象，清除Perm区中已被卸载的类信息，并进行压缩。而ParallelOldGC清除Heap堆中的部分垃圾对象，并进行部分的空间压缩。GC程序是多线程，当同样暂停其他所有程序。 CMS Collector：既不是Minor GC，也不是Full GC，是基于两种GC之间的一种GC。触发规则是检查Old区或Prem区的使用率。触发CMS GC回收的只是Old区或Perm区的垃圾对象。与Minor GC或Full GC没有关系。这种模式下的Minor GC触发与回收规则与Serial GC基本一致。不同之处只是GC回收变成多线程而已。有两种情况触发Full GC。一种是Eden分配失败，Minor GC后分配到To Space，To Space不够再分配到Old区，Old区不够则触发Full GC。另外一种情况是，当CMS GC正在进行时先Old区申请内存失败，则会直接触发Full GC。 1.7 三种GC优缺点对比 GC 优点 缺点 Serial Collector(串行) 适合内存有限的情况 回手收慢 Parallel Collector(并行) 效率高 当Heap过大时，应用程序暂停时间较长 CMS Collector(并发) Old区回收暂停时间短 产生内存碎片，整个GC耗时较长，耗CPU","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://fengjiaxin.github.io/tags/GC/"}]},{"title":"数据库访问中遇到的问题","slug":"数据库访问中遇到的问题","date":"2017-01-03T07:45:27.000Z","updated":"2017-01-06T03:54:21.661Z","comments":true,"path":"2017/01/03/数据库访问中遇到的问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/数据库访问中遇到的问题/","excerpt":"","text":"今天在编码中出现了No suitable driver found for jdbc，又是找遍了网上的资料，基本上都说是三个问题： 连接URL格式出现了问题 驱动字符串出错(com.mysql.jdbc.Driver) 三是Classpath中没有加入合适的mysql_jdbc驱动 经过我的仔细检查，出现了两次错误，总结如下： 在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。但是在 Eclipse web 项目中，当执行 Class.forName(“om.mysql.jdbc.Driver”);时 不会去查找驱动的。所以本实例中我们需要把mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。 查看资料说Java1.8之后就不用写Class.forName(“com.mysql.jdbc.Driver”) ; 我就没写，后来将这句代码写上，发现成功连接数据库，下次还是写上吧。 那我就把自己写的DBUtil.java代码贴上吧！ public class DBUtil { public static Connection getConnection() { String username = &quot;root&quot;; String password = &quot;123456&quot;; String url = &quot;jdbc:mysql://localhost:3306/itat_shop&quot;; Connection con = null; //1.加载驱动程序 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); con = DriverManager.getConnection(url, username, password); } catch(ClassNotFoundException |SQLException e) { e.printStackTrace(); } return con; } public static void close(Connection con) { try { if(con!=null) con.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(java.sql.PreparedStatement ps) { try { if(ps!=null) ps.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(ResultSet rs) { try { if(rs!=null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }","categories":[{"name":"JAVA问题总结","slug":"JAVA问题总结","permalink":"https://fengjiaxin.github.io/categories/JAVA问题总结/"}],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"https://fengjiaxin.github.io/tags/jdbc/"},{"name":"mysql","slug":"mysql","permalink":"https://fengjiaxin.github.io/tags/mysql/"}]},{"title":"返回类型是接口的分析","slug":"返回类型是接口的分析","date":"2016-12-27T02:36:51.000Z","updated":"2017-01-05T14:09:54.099Z","comments":true,"path":"2016/12/27/返回类型是接口的分析/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/27/返回类型是接口的分析/","excerpt":"","text":"今天在学习Servlet的过程中，书上关于DaoFactory的代码如下： public class DAOFactory { public static IUserDao getUserDao() { return new UserDao(); } } 在这里IUserDao是一个接口类型，但是返回的确实一个实现类，这明显不是一个类型啊，我就带着疑问上网搜索，总结如下： 接口虽然不能被实例化，但是接口的实现类都可以向上转型为接口； 面向接口编程是指我们在编写代码时对数据参数的定义尽量写成接口，待真正实现的时候再用实际类型代替； 代码的耦合性降低，在运行时我只需修改实现类类型，就可以实现不同的功能，而不必要修改接口的代码。 总结：接口的实现类可以向上转型为接口类，表面上返回的是接口类型，实际上返回的却是接口的实现类，如果需要取出接口的实现类，可以向下转型。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"},{"name":"单例设计模式","slug":"单例设计模式","permalink":"https://fengjiaxin.github.io/tags/单例设计模式/"}]},{"title":"Servlet技术笔记","slug":"Servlet技术笔记","date":"2016-12-26T07:49:21.000Z","updated":"2017-01-05T14:09:00.997Z","comments":true,"path":"2016/12/26/Servlet技术笔记/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/26/Servlet技术笔记/","excerpt":"","text":"1 ServletAPI：1.1 Servlet接口的主要方法及作用： init():在Servlet实例化之后，Servlet容器会调用init()方法，来初始化该对象。 service():容器调用Service()方法来处理客户端的请求。 destroy():容器检测到一个Servlet对象应该从服务器中被移除的时候，容器调用该对象的destroy()方法，以便Servlet对象可以释放使用的资源。 getServletConfig():返回调用init()方法时传递给Servlet对象的ServletConfig对象。 1.2 ServletRequest和ServletResponse： Servlet由Servlet容器管理，当客户端请求时，容器创建一个ServletRequest对象，封装请求数据，同事创建一个ServletResponse对象，封装响应数据，这两个对象被容器作为service()方法的参数传递给Servlet。 1.3 ServletConfig: Servlet容器使用ServletConfig对象在Servlet初始化期间向它传递配置信息，一个Servlet只能有一个ServletConfig对象。 1.4 简单实例 编写HelloWorldServlet例子，源代码见HelloServlet.java 1.5HttpServlet HttpServlet继承自GenericServlet，当容器收到一个针对HttpServlet对象的请求时，调用顺序如下： 调用public 的service()方法； 将参数类型转换为HttpServletRequest和HttpServletResponse，然后调用protected 的service()方法，将转换后的参数传进去； 在protected 的service()方法中，首先调用HttpServletRequest对象的getMethod()方法，确定是get，还是post方法。然后调用相应的doGet()或者doPost()等方法。 因此，在编写HttpServlet的派生类时，只许重写响应的doXXX()方法。 1.6 HttpServletRequest和HttpServletResponse get()方法：提交的数据提交到URL中，传递给后台服务器。 post()方法：提交的数据作为请求正文的内容发送到服务端，在URL看不到附加的请求数据。 2 简单实例：OutputInfoServlet：代码见OutputInfoServlet.java。 一个登陆实例：需要编写LoginServlet2.java，CenterServlet.java，success.html，web.xml。 3 Servlet异常 ServletException：可以被init()，service()，doXXX()等方法抛出。 UnavailableException：是ServletException的子类，用于向Servlet容器指示这个Servlet永久的或暂时的不可用。 4 Servlet生命周期 加载和实例化：Servlet容器负责加载和实例化Servlet，容器是通过反射机制来创建Servlet实例，调用不带参数的构造方法。 初始化：调用init()方法，在处理客户端请求时完成一些初始化工作。 请求处理：调用Service()方法，若执行期间有错误，可以抛出ServletException或UnavailableException异常，如果UnavailableException指示该实例永久不可用，则调用该实例的desttroy()方法。 服务终止：Servlet容器检测Servlet实例应该被移除时，调用destroy()方法，释放该实例使用的资源，等待Java的垃圾回收期回收。 5 Servlet上下文 运行在Java虚拟机中的每一个Web应用程序都有一个与之相关的Servlet上下文，Servlet API提供了ServletContext接口表示上下文，接口中定义了一些方法，Servlet可以使用这些方法与它的Servlet容器践行通信。 编写页面访问统计的实例：一个Web应用程序只有一个ServletContext对象，而且该对象可以被Web应用程序的所有Servlet所访问，因此使用ServletContext对象保存共享信息。 源码如下：CountServlet.java 注意：不同的Web应用程序具有不同的Servlet上下文，所以不同web应用程序不能利用ServletContext来共享属性；并且访问次数在重启Tomcat服务器后，重新计数，所以为了永久保存访问次数，可以存到文件或数据库中。 6 请求转发6.1 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建，用于封装一个路径标识的服务器资源。利用该对象，可以把请求转发给Servlet或JSP页面。 forward()：用于将请求从一个Servlet传递给服务器上的另外的Servlet或JSP页面或HTML文件；这个方法必须在响应被提交给客户端之前调用，调用后，原先在响应缓存中没有提交的内容将被自动清除。 include()：用于在响应中包含其他资源的内容。 上述两个方法区别：利用include()方法将请求转发给其他Servlet，被调用的Servlet对该请求做出的响应将并入原先的响应对象中，原先的Servlet还可以继续输出响应信息；而利用forward()方法将请求转发给其他的Servlet，将由被调用的Servlet负责对请求做出响应，而原先的Servlet的执行则终止。 6.2 得到RequestDispatcher对象 ServletContext接口的getRequestDispatcher()方法：参数必须以/开始，被解释为相对于当前上下文根的路径。 ServletRequest接口的getRequestDispatcher()方法：参数不但可以是相对于上下文的路径，也可以是相对于当前Servlet的路径；例如/myServlet、myServlet均合法。 6.3 请求转发的实例 CenterServlet.java，LoginServlet2.java。 6.4 sendRedirect()和forward()的区别HttpServletResponse接口的sendRedirect()和RequestDispatcher接口的forward()方法都可以利用另外的资源为客户端服务，但是工作原理有本质的区别。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1让Servlet2 为客户端服务 Servlet1调用SendRedirect()方法，将客户端的请求重定向到Servlet2 浏览器访问Servlet2 Servlet2 对客户端的请求做出响应 重定向这个过程对用户透明，浏览器会自动完成新的访问。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1想让Servlet2对客户端进行响应，调用forward()方法，将请求转发给Servlet2进行处理 Servlet2对请求做出响应 调用forward()方法，对浏览器来说是透明的，浏览器只知道发出一个请求。 还有一个重要区别：sendRidirect()方法不但可以在位于同一主机上的不同web应用程序之间的重定向，而且可以将客户端重定向到其他服务器上的web应用程序资源","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://fengjiaxin.github.io/tags/Servlet/"}]},{"title":"StacK的一些例子","slug":"Stack","date":"2016-12-20T12:41:17.000Z","updated":"2017-01-05T14:09:40.128Z","comments":true,"path":"2016/12/20/Stack/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/20/Stack/","excerpt":"","text":"栈就是后进先出的数据结构1. 栈的简单实现，采用数组实现class StackX{ private int maxSize; private long[] stackArray; private int top; public StackX(int s){ maxSize = s; stackArray = new long[maxSize]; top=-1; } public void push(long value){ stackArray[++top] = value; } public long pop(){ return stackArray[top--]; } public long peek(){ return stackArray[top]; } public boolean isEmpty(){ return (top==-1); } public boolean isFull(){ return (top==maxSize-1); } } class stackApp { public static void main(String[] args) { StackX theStack = new StackX(10); theStack.push(20); theStack.push(40); theStack.push(60); theStack.push(80); while(!theStack.isEmpty()){ long value = theStack.pop(); System.out.print(value); System.out.print(&quot; &quot;); } System.out.println(&quot;&quot;); } } 2. 实现单词逆序功能class StackY private int maxSize; private char[] stackArray; private int top; public StackY(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } public boolean isFull(){ return (top==maxSize-1); } } class Reverser{ private String input; private String output; public Reverser(String in){ this.input =in; } public String doRev(){ int stackSize =input.length(); StackY theStack = new StackY(stackSize); for(int i=0;i&lt;input.length();i++){ char ch = input.charAt(i); theStack.push(ch); } output = &quot;&quot;; while(!theStack.isEmpty()){ char ch = theStack.pop(); output = output +ch; } return output; } } class ReverseApp{ public static void main(String[] args) throws IOException{ String input,output; while(true){ System.out.print(&quot;Enter a String:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; Reverser theReverser = new Reverser(input); output = theReverser.doRev(); System.out.println(&quot;Reverse:&quot;+output); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 3. 实现分隔符匹配 具体实现思想：程序从字符串不断读取字符，每次读取一个字符，若发现它是左分隔符，将它压栈，当从输入中读到一个右分割符时，弹出栈顶的的左分割符，并且查看它是否和右分隔符相匹配，如果不匹配，则程序报错；如果栈中没有左分隔符和右分隔符匹配，程序也报错；分隔符没有被匹配，表现为把所有的字符读入之后，栈中仍留有分隔符。 class StackZ{ private int maxSize; private char[] stackArray; private int top; public StackZ(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } } class BracketChecker{ private String input; public BracketChecker(String in){ this.input =in; } public void check(){ int stackSize = input.length(); StackZ theStack = new StackZ(stackSize); for(int j =0;j&lt;input.length();j++){ char ch =input.charAt(j); switch(ch) { case&apos;{&apos;: case&apos;[&apos;: case&apos;(&apos;: theStack.push(ch); break; case&apos;}&apos;: case&apos;]&apos;: case&apos;)&apos;: if(!theStack.isEmpty()){ char chx = theStack.pop(); if(chx ==&apos;{&apos; &amp;&amp; ch!=&apos;}&apos; || chx ==&apos;[&apos; &amp;&amp; ch!=&apos;]&apos; || chx ==&apos;(&apos; &amp;&amp; ch!=&apos;)&apos;) System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); }else System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); break; default: break; } } if(!theStack.isEmpty()){ System.out.println(&quot;Error :missing right delimiter&quot;); } } } class BracketsApp{ public static void main(String[] args) throws IOException{ String input; while(true){ System.out.print(&quot;Enter string containing delimiters:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; BracketChecker theChecker = new BracketChecker(input); theChecker.check(); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 总结：在编程过程中，好的编程习惯就是将方法细化，任何可能重复的方法将其封装到一个方法中，下次再用调用即可。","categories":[{"name":"JAVA数据结构","slug":"JAVA数据结构","permalink":"https://fengjiaxin.github.io/categories/JAVA数据结构/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://fengjiaxin.github.io/tags/Stack/"},{"name":"数据结构","slug":"数据结构","permalink":"https://fengjiaxin.github.io/tags/数据结构/"}]},{"title":"关于javaWeb学习过程中的一些个人感悟","slug":"关于javaWeb学习过程中的一些个人感悟","date":"2016-12-19T07:48:47.000Z","updated":"2017-02-02T12:38:36.306Z","comments":true,"path":"2016/12/19/关于javaWeb学习过程中的一些个人感悟/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/19/关于javaWeb学习过程中的一些个人感悟/","excerpt":"","text":"在本科阶段，毕设是利用SpringMVC +Hibernate+sql做一个教务信息发布平台，当时是机械兔的我哪里会啊，就是不断的找网上相似的教学视频，然后看源码进行修改，说句实话，当时就是盲目的该，有些错误只能google,自己一点也分析不出来，但是没办法，为了完成毕业设计，只好照猫画虎的改。 但是现在研究生阶段开发评标系统，网上也没有源码，我也毫无参考，对框架就更无从编写，在与前辈的交流过程中，发现自己对Servlet和Jsp了解太少，基础知识太弱，并且很多框架就是将Servlet进行封装，如果不明白底层的原理，将来运用框架也一定会有很多问题的。框架不断在变，但是基础原理并没有变，为了以后能更扎实的编码学习。现在开始记录我的学习Servlet和Jsp之旅，特此见证。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://fengjiaxin.github.io/categories/个人感悟/"}],"tags":[]}]}