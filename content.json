[{"title":"StacK的一些例子","date":"2016-12-20T12:41:17.000Z","path":"2016/12/20/Stack/","text":"栈就是后进先出的数据结构1. 栈的简单实现，采用数组实现class StackX{ private int maxSize; private long[] stackArray; private int top; public StackX(int s){ maxSize = s; stackArray = new long[maxSize]; top=-1; } public void push(long value){ stackArray[++top] = value; } public long pop(){ return stackArray[top--]; } public long peek(){ return stackArray[top]; } public boolean isEmpty(){ return (top==-1); } public boolean isFull(){ return (top==maxSize-1); }} class stackApp { public static void main(String[] args) { StackX theStack = new StackX(10); theStack.push(20); theStack.push(40); theStack.push(60); theStack.push(80); while(!theStack.isEmpty()){ long value = theStack.pop(); System.out.print(value); System.out.print(&quot; &quot;); } System.out.println(&quot;&quot;); } } 2. 实现单词逆序功能class StackY private int maxSize; private char[] stackArray; private int top; public StackY(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } public boolean isFull(){ return (top==maxSize-1); } } class Reverser{ private String input; private String output; public Reverser(String in){ this.input =in; } public String doRev(){ int stackSize =input.length(); StackY theStack = new StackY(stackSize); for(int i=0;i&lt;input.length();i++){ char ch = input.charAt(i); theStack.push(ch); } output = &quot;&quot;; while(!theStack.isEmpty()){ char ch = theStack.pop(); output = output +ch; } return output; } } class ReverseApp{ public static void main(String[] args) throws IOException{ String input,output; while(true){ System.out.print(&quot;Enter a String:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; Reverser theReverser = new Reverser(input); output = theReverser.doRev(); System.out.println(&quot;Reverse:&quot;+output); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 3. 实现分隔符匹配具体实现思想：程序从字符串不断读取字符，每次读取一个字符，若发现它是左分隔符，将它压栈，当从输入中读到一个右分割符时，弹出栈顶的的左分割符，并且查看它是否和右分隔符相匹配，如果不匹配，则程序报错；如果栈中没有左分隔符和右分隔符匹配，程序也报错；分隔符没有被匹配，表现为把所有的字符读入之后，栈中仍留有分隔符。class StackZ{ private int maxSize; private char[] stackArray; private int top; public StackZ(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } } class BracketChecker{ private String input; public BracketChecker(String in){ this.input =in; } public void check(){ int stackSize = input.length(); StackZ theStack = new StackZ(stackSize); for(int j =0;j&lt;input.length();j++){ char ch =input.charAt(j); switch(ch) { case&apos;{&apos;: case&apos;[&apos;: case&apos;(&apos;: theStack.push(ch); break; case&apos;}&apos;: case&apos;]&apos;: case&apos;)&apos;: if(!theStack.isEmpty()){ char chx = theStack.pop(); if(chx ==&apos;{&apos; &amp;&amp; ch!=&apos;}&apos; || chx ==&apos;[&apos; &amp;&amp; ch!=&apos;]&apos; || chx ==&apos;(&apos; &amp;&amp; ch!=&apos;)&apos;) System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); }else System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); break; default: break; } } if(!theStack.isEmpty()){ System.out.println(&quot;Error :missing right delimiter&quot;); } } } class BracketsApp{ public static void main(String[] args) throws IOException{ String input; while(true){ System.out.print(&quot;Enter string containing delimiters:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; BracketChecker theChecker = new BracketChecker(input); theChecker.check(); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 总结：在编程过程中，好的编程习惯就是将方法细化，任何可能重复的方法将其封装到一个方法中，下次再用调用即可。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fengjiaxin.github.io/tags/数据结构/"}]}]