{"meta":{"title":"冯佳欣的博客","subtitle":"滴水穿石","description":"记录一点一滴","author":"冯佳欣","url":"https://fengjiaxin.github.io"},"pages":[{"title":"分类","date":"2017-01-05T10:16:57.000Z","updated":"2017-01-05T11:38:57.999Z","comments":true,"path":"categories/index.html","permalink":"https://fengjiaxin.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-05T10:17:16.000Z","updated":"2017-01-05T11:39:14.780Z","comments":true,"path":"tags/index.html","permalink":"https://fengjiaxin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Set中hashCode学习","slug":"Set中hashCode()学习","date":"2017-02-10T00:48:25.000Z","updated":"2017-02-10T01:38:30.685Z","comments":true,"path":"2017/02/10/Set中hashCode()学习/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/10/Set中hashCode()学习/","excerpt":"","text":"我在复习Set的时候，知道Set集合中的元素不重复，是利用对象的hashCode()方法保证的，我本身也学过数据结构的hash表，但是本着不撞南墙不死心的态度，我决定总结一下hash算法并分析Java中的hashCode()究竟是怎么一回事。 #Hash表： # Hash表也称散列表，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。 ##1.设计思想： ## Hash表采用一个映射函数 f : key —&gt; address 将关键字映射到该记录在表中的存储位置，从而在想要查找该记录时，可以直接根据关键字和映射关系计算出该记录在表中的存储位置，通常情况下，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置(注意这里的存储位置只是表中的存储位置，并不是实际的物理地址)称作为Hash地址。 ##2.构造方法： ## 1)直接定址法 取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000作为Hash地址。 2)平方取中法 对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。 3)折叠法 将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。 4)除留取余法 如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。 在这里p的选取非常关键，p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。 3.Hash表大小的确定 Hash表大小的确定也非常关键，如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费，如果选取小了的话，则容易造成冲突。在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。 4.冲突的解决 在上述例子中，发生了冲突现象，因此需要办法来解决，否则记录无法进行正确的存储。通常情况下有2种解决办法： 1)开放定址法 即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法； 比如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash表长为14，Hash函数为address(key)=key%11，当插入12，13，25时可以直接插入，而当插入23时，地址1被占用了，因此沿着地址1依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将23插入其中。 2)链地址法 采用数组和链表相结合的办法，将Hash地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如上述例子中，采用链地址法形成的Hash表存储表示为： 虽然能够采用一些办法去减少冲突，但是冲突是无法完全避免的。因此需要根据实际情况选取解决冲突的办法。 5.Hash表的平均查找长度 Hash表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。 查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数； 查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，再除以表长即为查找不成功时的平均查找长度。 下面举个例子： 有一组关键字{23，12，14，2，3，5}，表长为14，Hash函数为key%11，则关键字在表中的存储如下： 地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 关键字 23 12 14 2 3 5 比较次数 1 2 1 3 3 2 因此查找成功时的平均查找长度为(1+2+1+3+3+2)/6=11/6； 查找失败时的平均查找长度为(1+7+6+5+4+3+2+1+1+1+1+1+1+1)/14=38/14； 这里有一个概念装填因子=表中的记录数/哈希表的长度，如果装填因子越小，表明表中还有很多的空单元，则发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。因此，Hash表的平均查找长度和装填因子有关。 6.Hash表的优缺点 Hash表存在的优点显而易见，能够在常数级的时间复杂度上进行查找，并且插入数据和删除数据比较容易。但是它也有某些缺点，比如不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。 到这里Hash表我也复习的差不多，那我开始分析Object对象的hashCode()方法和set中的HashCode()方法： 一、java对象的比较 等号(==)：对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等； equals()：对比两个对象实例是否相等；当对象所属的类没有重写根类Object的equals()方法时，equals()判断的是对象实例的ID（内存地址），是否是同一对象实例；该方法就是使用的等号(==)的判断结果。 当对象所属的类重写equals()方法（可能因为需要自己特有的“逻辑相等”概念)时，equals()判断的根据就因具体实现而异，有些类是需要比较对象的某些指或内容，如String类重写equals()来判断字符串的值是否相等。判断逻辑相等。 hashCode(): 计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 查看Object类中的hashCode()方法源代码： public native int hashCode(); 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的；所以native关键字的函数都是操作系统实现的，java只能调用。 默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。 二、hashCode的作用 Java中的集合（Collection）有两类，一类是List，再有一类是Set。后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 Java采用了哈希表的原理，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值，然后将哈希值和集合长度进行&amp;运算，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就表示发生冲突，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。 这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。 简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！ 三、Java 对象的equal方法和hashCode方法的关系 Java对象相同指的是两个对象通过eqauls方法判断的结果为true Java对象的eqauls方法和hashCode方法是这样规定的： 相等的对象必须具有相等的哈希码（或者散列码）。 如果两个对象的hashCode相同，它们并不一定相同。 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。 关于第二点，两个对象的hashCode相同，它们并不一定相同 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 总结： (1)绑定。 当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 (2)绑定原因。 Hashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。 (3)默认。 ==默认比较对象在JVM中的地址。 hashCode 默认返回对象在JVM中的存储地址。 equal比较对象，默认也是比较对象在JVM中的地址，同==","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"hashCode","slug":"hashCode","permalink":"https://fengjiaxin.github.io/tags/hashCode/"}]},{"title":"华为在线笔试总结（一）","slug":"华为在线笔试总结（二）","date":"2017-02-09T10:56:53.000Z","updated":"2017-02-09T11:27:53.118Z","comments":true,"path":"2017/02/09/华为在线笔试总结（二）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/09/华为在线笔试总结（二）/","excerpt":"","text":"在总结之前，我先复习一下有关String对象的知识。 # String类 # String类是final类型的，所以不能被被继承，方法不能被覆盖。它是一个引用数据类型，它的对象是一个字符串，程序中用” “标示的都是字符串。字符串是一个特殊的对象，字符串对象最大的特点是它为一个常量，一经初始化，永远不会改变，这是它跟其它引用数据类型最大的不同之处。 常见的操作方法： 1、获取1.1 字符串中的包含的字符数，也就是字符串的长度； int length（）:获取长度。 （跟数组length的区别） 1.2 根据位置获取位置上某个字符。 char charAt（int index）： 1.3 根据字符获取该字符在字符串中的位置。 int indexOf（int ch）：返回的是ch在字符串中第一次出现的位置。 int indexOf（int ch,int fromIndex）:从fromIndex指定位置开始，获取ch在字符串中的位置。 int indexOf（String str）：返回的是str在字符串中第一次出现的位置。 int indexOf（String str,int fromIndex）:从fromIndex指定位置开始，获取str在字符串中的位置。（str字符串） int lastIndexOf（int ch）：返回指定字符在此字符串中最后一次出现的索引。 2、判断2.1 字符串中是否包含某一个字串。 boolean contains(str);① 2.2 字符串中是否有内容 boolean isEmpty（）;原理就是判断长度是否为0； 2.3 字符串中是否是以指定内容开头。 boolean startsWith（str）; 2.4 字符串中是否是以指定内容结尾。 boolean endsWith（str）; 2.5 判读字符串的内容是否相同，复写了Object类中的equals方法。 boolean equals（str）； 2.6 判断内容是否相同，并忽略大小写。 boolean equalsIgnoreCase（str）； 3. 转换3.1 将字符数组转成字符串； 构造函数：String（char[]） String（char[]，offset，count）：将字符数组中的一部分转成字符串。 offset起始位置，count取字符的个数。 静态方法： static String copyValueOf(char[]); static String copyValueOf(char[] data,int offset ,int count) static String valueOf(char[]): 3.2 将字符串转成字符数组； char[] toCharArray(); 3.3 将字节数组转成字符串； String（byte[]） String（byte[]，offset，count） 3.4 将字符串转成字节数组; Byte[] getBytes(); 3.5 将基本数据类型转成字符串。 static String valueOf（int） static String valueOf（double） (3+””和String valueOf（3）) 特殊：字符串和字节数组在转换过程中，是可以指定编码表的。 4. 替换String replace（oldchar，newchar）； 5. 切割String[] split（regex）； 6. 字串，获取字符串中的一部分。String substring(begin); String substring(begin,end); 7. 转换，去除空格，比较。7.1 将字符串转成大写或者小写。 String toUpperCase(); String toLowerCase(); 7.2 将字符串两端的多个空格去除。 String trim(); 7.3 对两个字符串进行自然顺序的比较。 Int compareTo(string ); # 接下来就是笔试题： # 扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:)3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR 基本规则： （1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列； （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子） （3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌； （4）输入的两手牌不会出现相等的情况。 答案提示： （1）除了炸弹和对王之外，其他必须同类型比较。 （2）输入已经保证合法性，不用检查输入是否是合法的牌。 （3）输入的顺子已经经过从小到大排序，因此不用再排序了. 输入描述: 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。 输出描述: 输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。 输入例子: 4 4 4 4-joker JOKER 输出例子: joker JOKER 注意：本道题目的输入规定是4 4 4 4-joker JOKER要想获取两组字符串 正确做法是： Scanner sc = new Scanner(System.in); String[] left,right; String[] line; String nextLine,outString; while(sc.hasNext()) { nextLine = sc.nextLine(); line = nextLine.split(&quot;-&quot;); left = line[0].split(&quot; &quot;); right = line[1].split(&quot; &quot;); //处理业务逻辑 } 那么当牌个数相等时如何比较牌面大小呢？ 一种简单的方法就是获取字符串所在基础字符串的位置 即 private static int count(String str){ return &quot;345678910JOKA2jokerJOKER&quot;.indexOf(str); } 写到这里，基本答案就出来了。 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); String[] left,right; String[] line; String nextLine,outString; while(sc.hasNext()){ nextLine = sc.nextLine(); if(nextLine.contains(&quot;joker JOKER&quot;)) outString = &quot;joker JOKER&quot;; else{ line = nextLine.split(&quot;-&quot;); left = line[0].split(&quot; &quot;); right = line[1].split(&quot; &quot;); if(left.length ==4 &amp;&amp; right.length!=4) outString = line[0]; else if(left.length!=4 &amp;&amp; right.length==4) outString = line[1]; else if(left.length==right.length){ if(count(left[0])&gt;count(right[0])) outString = line[0]; else outString = line[1]; }else{ outString = &quot;ERROR&quot;; } } System.out.println(outString); } } private static int count(String str){ return &quot;345678910JQKA2jokerJOKER&quot;.indexOf(str); } }","categories":[{"name":"笔试总结","slug":"笔试总结","permalink":"https://fengjiaxin.github.io/categories/笔试总结/"}],"tags":[]},{"title":"华为在线笔试总结（一）","slug":"华为在线笔试总结（一）","date":"2017-02-09T10:04:25.000Z","updated":"2017-02-09T10:31:16.585Z","comments":true,"path":"2017/02/09/华为在线笔试总结（一）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/09/华为在线笔试总结（一）/","excerpt":"","text":"在总结之前，我得自身反省一下，明明想法其实已经想的差不多了，但是总差一些细节，尤其关于Scanner类，这个类非常重要，方法一定要记住。 ## Scanner类## 在源码中应该包括下句： import java.util.Scanner; Scanner是新增的一个简易文本扫描器，在 JDK 5.0之前，是没有的。 构造方法： public Scanner(InputStream source) //用指定的输入流来创建一个Scanner对象 方法： public void close() //关闭 public Scanner useDelimiter(String pattern) //设置分隔模式 ,String可以用Pattern取代 public boolean hasNext() //检测输入中，是否，还有单词 public boolean hasNextInt() //检测输入中，是否，还有单词 public String next() //读取下一个单词，默认把空格作为分隔符 public int hasNextInt();查看是否有int类型的token的分割段 public String nextLine() //读行 读取键盘输入 Scanner sc = new Scanner(System.in); while(sc.hasNext()) { //处理业务 } 好了，在了解了一些基本信息后，我们开始看题： 输入包括多组测试数据。每组输入第一行是两个正整数N和M（0 &lt; N &lt;= 30000,0 &lt; M &lt; 5000）,分别代表学生的数目和操作的数目。学生ID编号从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为’Q’的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少；当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 我第一次做题的时候忽略了两点： M限制了查询次数 A、B的大小关系不确定 在了解了这两个陷阱后，代码如下： import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int num = 0; int count = 0; int A=0,B =0; while(sc.hasNext()){ num = sc.nextInt(); count = sc.nextInt(); int[] grade = new int[num]; for(int i=0;sc.hasNext() &amp;&amp; i&lt;num ;i++) grade[i] = sc.nextInt(); String ch = null; for(int i=0;sc.hasNext() &amp;&amp; i&lt;count;i++){ ch = sc.next(); A = sc.nextInt(); B = sc.nextInt(); if(ch.equals(&quot;U&quot;)) grade[A-1] = B; if(ch.equals(&quot;Q&quot;)){ int result = max(grade,A,B); System.out.println(result); } } } } public static int max(int[] array,int begin,int end){ int min = Math.min(begin,end)-1; int max = Math.max(begin,end); int result = array[min]; for(int i =min+1;i&lt;max;i++){ if(array[i]&gt;result) result = array[i]; } return result; } } 总结：在习惯了编辑器后，发现有些代码拼写不正确，还有多练习把！！！","categories":[{"name":"笔试总结","slug":"笔试总结","permalink":"https://fengjiaxin.github.io/categories/笔试总结/"}],"tags":[]},{"title":"排序的Java实现","slug":"排序的Java实现","date":"2017-02-04T12:46:53.000Z","updated":"2017-02-09T08:37:43.018Z","comments":true,"path":"2017/02/04/排序的Java实现/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/04/排序的Java实现/","excerpt":"","text":"数据结构学习了好久，有时候不复习都快忘了，那么今天我就来复习一下内部排序，包括选择排序、插入排序、冒泡排序、归并排序、快速排序、希尔排序、堆排序；然后简单介绍一下各种排序的思想，然后利用Java进行实现；最后比较各算法的优劣。 1、选择排序 基本原理：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮比较，得到较小的记录并与第二个记录的位置进行交换；重复该过程，直到进行比较的记录只有一个时为止。 具体实现： public class TestSelectSort { public static void main(String[] args) { int[] a = {5,4,9,8,7,6,0,1,3,2}; selectSort(a); show(a); } public static void selectSort(int[] a){ int i,j; int temp =0,flag =0; for(i =0;i&lt;a.length;i++){ temp =a[i]; flag =i; for(j =i+1;j&lt;a.length;j++){ if(a[j]&lt;temp){ temp= a[j]; flag =j; } } if(flag!=i){ a[flag] =a[i]; a[i] = temp; } } } public static void show(int[] a){ for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } } 2、插入排序： 基本思想：对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列；接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中，直到最后一个记录插入到有序序列为止。 具体实现： public class TestInsertSort { public static void main(String[] args) { int[] array = {7,3,4,9,10,6}; insertSort(array); for(int i=0;i&lt;array.length;i++) System.out.print(array[i]+&quot; &quot;); } public static void insertSort(int[] a){ if(a!=null){ for(int i=1;i&lt;a.length;i++){ int temp = a[i],j =i; if(temp&lt;a[j-1]){ while(j&gt;=1 &amp;&amp; temp&lt;a[j-1]){ a[j] = a[j-1]; j--; } } a[j] = temp; } } } } 3、冒泡排序 基本思想：对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行第一轮比较和换位后，n个记录最大的记录位于第n位；然后对前(n-1)个记录进行第二轮比较；重复该过程直到进行比较的记录只剩下一个为止。 具体实现： public class TestBubbleSort { public static void main(String[] args) { int[] array = {4,2,9,10,8,6}; BubbleSort(array); for(int i=0;i&lt;array.length;i++){ System.out.print(array[i]+&quot; &quot;); } } public static void BubbleSort(int[] a){ int i,j,temp,len = a.length; for( i=0;i&lt;len-1;i++){ for(j =0;j&lt;len-i-1;j++){ if(a[j]&gt;a[j+1]){ temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } } 4、归并排序 基本思想：对于给定的一组记录（假设共有n个记录），首先将每两个相邻的长度为1的子序列进行归并，得到n/2（向上取整）个长度为2或1的有序子序列，在将其进行两两归并，反复执行此过程，直到得到一个有序序列。 具体实现： public class TestMergeSort { public static void main(String[] args) { int[] a = {5,3,4,2,9,7,6,1}; MergeSort(a, 0, a.length-1); for(int i =0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void Merge(int[] array,int left,int middle,int right){ int i,j,k,n1,n2; n1 = middle-left+1; n2 = right-middle; int[] L = new int[n1]; int[] R = new int[n2]; for(i =0,k =left;i&lt;n1;i++,k++) L[i] = array[k]; for(j =0,k=middle+1;j&lt;n2;j++,k++) R[j] = array[k]; for(k =left,i =0,j =0;i&lt;n1 &amp;&amp; j&lt;n2;k++){ if(L[i]&lt;R[j]) array[k] = L[i++]; else array[k] = R[j++]; } //没有再声明一个变量是因为一下两种情况只会出现一种情况。 if(i&lt;n1){ for(j =i;j&lt;n1;j++,k++) array[k] =L[j]; } if(j&lt;n2){ for(i =j;i&lt;n2;i++,k++) array[k] =R[i]; } } public static void MergeSort(int[] array,int left,int right){ if(left&lt;right){ int middle = (left+right)/2; MergeSort(array, left, middle); MergeSort(array,middle+1,right); Merge(array,left,middle,right); } } } 5、快速排序 基本思想：对于一组给定的记录，通过一趟排序后，将原序列分为两个部分，其中前一部分的所有记录均比后一部分的所有记录小，然后再依次对前后两部分的记录进行快速排序，递归该过程，直到序列中的所有记录均有序为止。 具体实现： public class TestQuickSort { public static void main(String[] args) { int[] a = {5,3,2,9,7,6,1}; quickSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void sort(int[] array,int low,int high){ int i,j,index; if(low&gt;=high) return; i =low; j = high; index = array[low]; while(i&lt;j){ while(i&lt;j &amp;&amp; array[j]&gt;index) j--; if(i&lt;j) array[i++] = array[j]; while(i&lt;j &amp;&amp; array[i]&lt;index) i++; if(i&lt;j){ array[j--] = array[i]; } } array[i] = index; sort(array,low,i-1); sort(array,i+1,high); } public static void quickSort(int[] array){ sort(array,0,array.length-1); } } 6、希尔排序 基本思想：先将待排序的的数组元素分成多个子序列，使得整个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，代整个待排序序列“基本有序后”，最后在对所有元素进行一次直接插入排序。 具体实现： public class TestShellSort { public static void main(String[] args) { int[] a = {5,3,2,9,7,6,1}; shellSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void shellSort(int[] array){ int len = array.length; int i,j,h;//h为步长 int temp; for(h =len/2;h&gt;0;h/=2){ for(i =h;i&lt;len;i++){//从每组至少第二个元素开始遍历 temp = array[i]; for(j=i-h;j&gt;=0;j-=h){ if(temp&lt;array[j]) array[j+h] = array[j]; else break; } array[j+h] = temp; } } } } 7、堆排序 基本思想：对于给定的n个记录，初始时把这些记录看做一颗顺序存储的二叉树，然后将其调整为一个最大堆，然后将堆的最后一个元素和堆顶元素进行交换，堆的最后一个元素即为最大记录；接着将前（n-1）个元素重新调整为一个最大堆，在将堆顶元素和最后一个元素进行交换得到次的的记录，重复该过程直到调整的堆中只剩下一个元素为止，该元素为最小记录，此时得到一个有序序列。 具体实现： public class TestHeapSort { public static void main(String[] args) { int[] a = {4,3,2,7,6,5}; heapSort(a); for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); } public static void adjustHeap(int[] a,int pos,int len){ int temp; int child; for(temp = a[pos];2*pos+1&lt;=len;pos = child){ child = 2*pos+1; if(child&lt;len &amp;&amp; a[child+1]&gt;a[child]) child++; if(a[child]&gt;temp) a[pos] = a[child]; else break; } a[pos] = temp; } public static void heapSort(int[] array){ int i; int len = array.length; for(i=len/2-1;i&gt;=0;i--) adjustHeap(array, i, len-1); for(i = len-1;i&gt;=0;i--){ int temp = array[0]; array[0] = array[i]; array[i] = temp; adjustHeap(array, 0, i-1); } } } 8、这7种排序算法的比较","categories":[{"name":"JAVA数据结构","slug":"JAVA数据结构","permalink":"https://fengjiaxin.github.io/categories/JAVA数据结构/"}],"tags":[]},{"title":"JAVA多线程（二）","slug":"JAVA多线程（二）","date":"2017-02-04T10:41:27.000Z","updated":"2017-02-04T11:44:08.110Z","comments":true,"path":"2017/02/04/JAVA多线程（二）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/04/JAVA多线程（二）/","excerpt":"","text":"接着上篇博客继续，还有一些多线程的概念，我以前也没听过，正好整理学习一下，加油！！ 1、sleep()方法与wait()方法的不同？ 区别主要显示在一下几个方面： 原理不同，sleep()方法时Thread的静态方法，是线程控制自身流程的，会让此线程暂停一段时间，把机会让给其他线程；而wait()方法时Object的方法，用于线程见的通信，这个方法会使拥有该对象锁的进程等待，直到其他线程调用notify()方法。 对锁的处理机制不同，sleep()方法不涉及线程间通信，不释放锁，而wait()会释放掉它所占用的锁，从而使线程所在对象的其他synchronized数据可被别的线程使用。 使用区域不同，sleep()可以在任何地方使用，而wait()方法必须放在同步控制方法或语句块中使用；除此之外，sleep()方法必须捕获异常，而wait()方法不需要，在sleep()过程中，有可能被其他对象调用它的interrupt(),产生interruptedException异常。 那么扩展一下：sleep()和yield()有什么区别？ sleep()给其他线程运行机会时不考虑线程的优先级，而yield()只给相同优先级或更高优先级的线程运行的机会。 线程执行sleep()后转入阻塞状态，所以在休眠的时间段内肯定不会被执行；但是yield()只是使当前线程重新回到可执行状态，所以可能执行yield()后进入到可执行状态后马上又被执行。 sleep()方法抛出InterruptedException，而yield()没有声明任何异常。 sleep()方法比yield()有更好地可移植性（操作系统方面）。 2、终止线程的方法？ stop()和suspend()方法。 stop()方法释放已经锁定的所有监视资源，suspend()不会释放锁。这两种方式都不安全，一般建议让线程自行结束进入Dead状态；在学习这个方法前，先补充一下基础知识。 关键字volatile,类型修饰符，系统每次用它时都是直接从内存中读取，而不是从缓存中读取。 那么建议方式是通过设置flag()标志来控制循环是否执行，通过这种方法来让线程离开run()方法从而终止线程。 实例代码如下： public class MyThreadStop implements Runnable { private volatile Boolean flag; public void stop(){ flag = false; } @Override public void run() { while(flag){ //执行 } } } 在上例中，调用stop()虽然能够终止线程，但是，当线程处于非运行状态时，这个方法就不可用啦，此时可以使用interrupt()方法来打破阻塞的情况，当interrupt()被调用时，会抛出interruptedException异常，可以通过在run()方法中来捕获这个异常让线程安全退出。 示例代码如下： public class MYThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread go to sleep&quot;); try { Thread.sleep(5000); System.out.println(&quot;thread end&quot;); } catch (InterruptedException e) { //e.printStackTrace(); System.out.println(&quot;thread is interupted&quot;); } } }); thread.start(); thread.interrupt(); } } 运行结果如下： thread go to sleep thread is interupted 3、什么是守护线程？ 守护线程是指程序在运行时在后台提供一种通用服务的线程，用户线程跟守护线程的差别在：如果用户线程已经全部退出运行，只剩下守护线程存在，JVM也就退出了。 在Java中，守护线程一般具有较低的优先级，它可以由用户设置，方法就是在调用start()前调用对象的setDaemon(true)方法，注意：当在一个守护线程中产生了其他线程，那么这些新产生的线程默认还是守护线程。 说了这么多，代码实战一下更加清晰明了： class ThreadJoin extends Thread{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;:begin&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;:end&quot;); } } public class ThreadJoinDemo { public static void main(String[] args) { System.out.println(&quot;test:begin&quot;); Thread t1 = new ThreadJoin(); t1.setDaemon(true); t1.start(); System.out.println(&quot;test:end&quot;); } } 运行结果： test:begin test:end Thread-0:begin 其中守护线程最典型的的一个例子就是垃圾回收器，只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源。 4、join()方法的作用是什么？ join()的作用是让调用该方法的线程在执行完run()方法后，再执行join()方法后面的代码。简单来说就是将两个线程合并，实现同步的功能；具体就是可以通过线程A的join()方法来等待线程A的结束，或者使用线程A的join(2000)方法来等待线程A的结束，但最多只等2s。 来，写个代码实例把： public class JoinTest { public static void main(String[] args) { Thread t = new Thread(new ThreadImp()); t.start(); try { t.join(1000); if(t.isAlive()){ System.out.println(&quot;t has not finished&quot;); }else{ System.out.println(&quot;t has finished&quot;); } System.out.println(&quot;joinFinish&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } class ThreadImp implements Runnable{ @Override public void run() { System.out.println(&quot;ThreadImp begin:&quot;); try { Thread.sleep(5000); System.out.println(&quot;ThreadImp end:&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果如下： ThreadImp begin: t has not finished joinFinish ThreadImp end: 到这里，关于线程的知识差不多整理完毕，有很多知识我也是重新学习了一遍，代码重新编写一次，写了这么多可真累，不过以后再捡起来就相对容易些了，先记录这些吧，以后再有新知识，新感悟在补充。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://fengjiaxin.github.io/tags/多线程/"}]},{"title":"JAVA多线程（一）","slug":"JAVA多线程（一）","date":"2017-02-03T12:42:34.000Z","updated":"2017-02-04T10:40:29.378Z","comments":true,"path":"2017/02/03/JAVA多线程（一）/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/JAVA多线程（一）/","excerpt":"","text":"在上学期学习了操作系统的相关知识，首先学的就是进程与线程的知识概念，但是linux操作系统是用c语言编写的，并且关于线程的代码太底端，平时做题也是运用伪代码来写的，那么今天在整理Java多线程的相关知识的同时，正好与之前学习的操作系统知识相结合，那么这篇文章主要介绍一下多线程的Java实现。 1、线程与进程的概念 线程是指程序在执行过程中，能够执行程序代码的一个执行单元，在Java语言中有四种状态：运行、就绪、挂起、结束。 进程是指一段正在执行的程序，而线程有时成为轻量级进程，是程序执行的最小单元，一个进程可以有多个线程，各个线程之间共享程序的内存空间（代码段、数据段、堆空间）以及一些进程级的资源，但是各个线程拥有自己的栈空间。 在网上找到一个图片很合适的表现的进程与线程的对比关系，图如下： 在操作系统级别上，程序的执行都是以进程为单位，每个进程通常有多个线程互不影响并发的执行，那么为什么使用多线程呢？ 使用多线程可以减少程序的响应时间。 与进程相比，线程的创建和切换开销更小。 多CPU或多核计算机本身就具有执行多线程的能力。 使用多线程能简化程序的结构，使程序便于理解和维护。 2、同步和异步的区别？ 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 3、如何实现JAVA多线程？ Java虚拟机允许应用程序并发的运行多个线程，在Java中，一共有三种实现方式，那么根据我的掌握程度，我只写前两个实现方式。 继承Thread类，重写run()方法 声明实现Runnable接口类，并实现run()方法。 对于方式一： 启动线程的唯一方法就是通过Thread的start()方法。start()方法是一个本地方法，将启动一个新线程，并执行run()方法；需要注意的是：调用start()方法是使得该线程变为可运行状态，什么时候运行线程代码是由操作系统决定。 代码示例如下： class Demo extends Thread { private String name; Demo(String name)//构造函数 { //this.name = name; super(name); } public void run()//复写run方法 { for ( int i = 0 ; i &lt; 60 ; i++ ) { System.out.println(Thread.currentThread().getName()+&quot;run=&quot;+i); } } } public class ThreadExtendsDemo { public static void main(String[] args) { Demo t1 = new Demo(&quot;one&quot;);//创建一个对象t1 Demo t2 = new Demo(&quot;two&quot;); t1.start();// 通过调用start方法，开启多线程 t2.start(); run(); } private static void run() { for(int i =0;i&lt;60;i++) System.out.println(&quot;main&quot; +i); } } 需要注意的是： t1.start()开启线程并执行该线程的run方法。 t1.run()仅仅是对象调用方法。而线程创建了，并没有运行。还是在主线程的运行中。 对于方式二： 首先定义类实现Runnable接口，实现run()方法；然后创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象；最有调用Thread的start()方法。 代码示例如下： class MyThread implements Runnable{ @Override public void run() { System.out.println(&quot;Thread Body&quot;); } } public class ThreadImmDemo { public static void main(String[] args) { MyThread thread = new MyThread(); Thread t = new Thread(thread); t.start(); } } 其实，不管是通过继承Thread类还是通过实现Runnable接口来实现多线程的方法，最终还是通过Thread对象的API来控制线程。 在学习了这两种方式实现多线程，那么有一个问题：一个类是否可以同时继承Thread类并实现Runnable接口？ 答案是可以的;代码示例如下： public class Test extends Thread implements Runnable { public static void main(String[] args) { Thread t = new Thread(new Test()); t.start(); } } 上面这段代码是可以编译通过的，因为Test类从Thread类继承了run()方法，这个继承的run()方法可以被当做对RUnnable接口的实现，因此此段代码可以编译通过。 4、run()方法和start()方法的区别？ 通常，系统通过调用线程类的start()方法来启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以被JVM来调度执行；在调度过程中，JVM通过调用线程类的run()方法来完成实际的操作，当run()方法结束后，此线程就会终止。 如果直接调用run()方法，这会别当做一个普通的函数调用，程序中仍然只有主线程这一个线程；由此可知，只有通过调用线程类的start()方法才能真正达到多线程的目的。 5、多线程同步的实现方法？Java主要提供了3种实现同步机制的方法： 1 synchronized关键字 在Java中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的一段synchronized代码时，需要先获取这个锁，然后去执行相应的代码，执行结束后，释放锁。 synchronized关键字有两种用法：synchronized方法和synchronized块，此外，该关键字可以用作于静态方法、类、或某个实例。 讲解了这么多，我编写一个买票程序，使用两个线程买票，一个线程在同步块中，一个线程在同步函数中，代码实例如下： class Ticket implements Runnable{ private int ticket =100; boolean flag = true; @Override public void run() { if(flag){ while(true){ synchronized (this) { if(ticket&gt;0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;runs=&quot;+ticket--); } catch (InterruptedException e) { e.printStackTrace(); } } } } } else{ show(); } } private synchronized void show() { while(true){ if(ticket&gt;0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;show =&quot;+ticket--); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public class TicketDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } t.flag = false; t2.start(); } } 那么如果同步函数被static修饰后，使用的锁是什么呢？我们知道静态进内存时一定没有本类对象，但一定有该类对应的字节码文件对象，即类.class,实在不行，我们创建一个对象，Object obj = new Objext();然后利用obj锁。 2 wait()和notify()方法 在synchronized代码被执行期间，线程可以通过调用对象的wait()方法，释放对象锁，进入等待状态，并且可以调用notify()或notifyAll()方法通知正在等待的其他线程。其中，notify()方法仅唤醒一个线程（等待队列的第一个线程），并允许它去获得锁；notifyAll()方法唤醒所有等待这个对象的线程并允许他们获得锁（让这些线程竞争获得）。 接下来编写一个生产者消费者的实例，代码实例如下： public class ProducerConsumerDemo { public static void main(String[] args) { Resource res = new Resource(); Producer pro = new Producer(res); Consumer con = new Consumer(res); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } class Resource{ private String name ; private int count =1; private boolean flag = false;//true代表有产品，false代笔没有产品 //生产 public synchronized void set(String name){ while(flag){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } this.name = name; System.out.println(Thread.currentThread().getName()+&quot;...生产者&quot;+this.name); flag = true; this.notifyAll(); } //消费 public synchronized void out(){ while(!flag){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName()+&quot;...消费者&quot;+this.name); flag = false; this.notifyAll(); } } class Producer implements Runnable{ private Resource res; Producer(Resource res){ this.res = res; } @Override public void run() { while(true){ res.set(&quot;商品&quot;); } } } class Consumer implements Runnable{ private Resource res; Consumer(Resource res){ this.res = res; } @Override public void run() { while(true){ res.out(); } } } 3 Lock JDK5后新增了Lock接口以及一个实现类ReentrantLock(重入锁)，我也第一次接触，好好学习一下，Lock也可以用来实现多线程的同步，它提供一些放法实现多线程的同步： 1 lock():以阻塞的方式获取锁，即如果获取到了锁，立即返回，如果别的线程持有锁，当前线程等待，直到获取锁后返回。 2 tryLock():以非阻塞的方式来获取锁，只是试探获取，如果获取到锁，立即返回true,否则返回false。 3 lockInterruptibly():如果获取到了锁，立即返回，否则，当前线程处于休眠状态，直到获得锁，注意：如果当前线程被别的线程中断，会收到InterruptedException异常。 先总结到这里，没想到写了这么多还有很多没写完，那么只好再写一篇啦。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://fengjiaxin.github.io/tags/多线程/"}]},{"title":"finally块中的代码什么时候被执行","slug":"finally块中的代码什么时候被执行","date":"2017-02-03T10:08:53.000Z","updated":"2017-02-09T07:32:05.735Z","comments":true,"path":"2017/02/03/finally块中的代码什么时候被执行/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/finally块中的代码什么时候被执行/","excerpt":"","text":"在上篇文章明白异常处理机制后，我们知道一般捕获异常用try/catch,一般情况下会有finally块，那么今天我就整理一下finally代码块的相关知识。 那么我们提出一个问题：try{}里有一个return语句，那么紧跟try的finally{}的代码是否会被执行？如果会的话，什么时候被执行，在return前还是return后？ 解答：在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally中的代码一定会被执行，因此任何语句要执行都只能在return前执行（除非碰到exit函数），因此finally块中的代码在return前执行。此外，如果try-finally或catch-finally中都有return,那么finally块中的return语句将会覆盖别处的return语句，最终返回到调用者那里的是finally中的return值。 代码示例如下： public class TestFinally1 { public static int testfinally(){ try{ return 1; }catch(Exception e){ return 0; }finally{ System.out.println(&quot;execute finally&quot;); } } public static void main(String[] args) { int result = testfinally(); System.out.println(result); } } 结果运行如下： execute finally 1 从上面的例子中可以看出，在执行return语句之前确实执行了finally块中的代码；那么如果在finally块中放置return语句，会不会覆盖呢？ 代码示例如下： public static int testfinally2(){ try { return 1; } catch (Exception e) { return 0; }finally{ System.out.println(&quot;execute finally2&quot;); return 3; } } public static void main(String[] args) { int result = testfinally2(); System.out.println(result); } 结果运行如下： execute finally2 3 从上面的例子中可以看出，当finally块中有return语句时，将会覆盖函数中其它return语句；此外，由于在一个方法体中内部定义的变量都存储在栈中，在这个函数结束后，其对应的栈会被回收，此时在其方法体中定义的变量将不存在了，因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。因此，对于基本类型的数据，在finally块中改变return的值对返回值没有任何影响，而对引用类型的数据会有影响。 代码示例如下： public class TestReturn { public static int testFinally1(){ int result =1; try{ result =2; return result; }catch(Exception e){ return 0; }finally{ result = 3; System.out.println(&quot;excuate testFinally1&quot;); } } public static StringBuffer testFinally2(){ StringBuffer s = new StringBuffer(&quot;hello&quot;); try{ return s; }catch(Exception e){ return null; }finally{ s.append(&quot; world&quot;); System.out.println(&quot;excuate testFinally2&quot;); } } public static void main(String[] args) { System.out.println(testFinally1()); System.out.println(testFinally2()); } } 结果运行如下： excuate testFinally1 2 excuate testFinally2 hello world 解析：程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后在返回。 在testFinally1()方法调用return前，先把result的值1存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值将不会影响到程序的返回结果。 testFinally2()中，在调用return前先把s存储在一个指定的位置，由于s为引用类型，因此在finally块中修改s将会修改程序的返回结果。 写了这么多，总结的也应该比较到位，那我在网上找一道相关的面试题进行解答。 出现在Java程序中的finally块是不是一定会被执行？ 答:不一定，以下两种情况都不会。 当程序在进入try{}语句块之前就出现异常，会直接结束。例如在try{}之前有语句int i= 9/0;那么会直接抛出异常，导致没有执行try{}中的代码。 当程序在try{}中强制退出也不会执行。例如在try{System.exit(0)}。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"finally代码块","slug":"finally代码块","permalink":"https://fengjiaxin.github.io/tags/finally代码块/"}]},{"title":"Java异常机制及原理","slug":"Java异常机制及相关问题","date":"2017-02-03T03:48:39.000Z","updated":"2017-02-09T07:31:40.878Z","comments":true,"path":"2017/02/03/Java异常机制及相关问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/03/Java异常机制及相关问题/","excerpt":"","text":"编写看这么多Java代码，有时候需要对可能出现的异常进行捕捉，有时候直接抛出，懵懵懂懂，那么今天重新看一遍关于Java异常处理机制，进行系统的总结。 1、异常机制概述 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 2 、异常处理的流程 当程序中抛出一个异常后，程序从程序中导致异常的代码处跳出，java虚拟机检测寻找和try关键字匹配的处理该异常的catch块，如果找到，将控制权交到catch块中的代码，然后继续往下执行程序，try块中发生异常的代码不会被重新执行。如果没有找到处理该异常的catch块，在所有的finally块代码被执行和当前线程的所属的ThreadGroup的uncaughtException方法被调用后，遇到异常的当前线程被中止。 3、异常的结构 异常的继承结构：Throwable为基类，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。 ４、Error异常 Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。 5、RuntimeException异常 Exception异常包括RuntimeException异常和其他非RuntimeException的异常。RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。 出现RuntimeException后，系统会把异常一直往上层抛出，知道遇到处理代码为止。若没有处理块，则抛到最上层；如果是多线程就用Thread.run()方法抛出，如果是单线程，就用main()方法抛出。抛出之后，如果是线程，那么这个线程退出了。如果是主程序抛出的异常，那么整个程序就退出了。 6、Checked Exception异常 Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。 7、应该在声明方法抛出异常还是在方法中捕获异常？ 处理原则：捕捉并处理哪些知道如何处理的异常，而传递哪些不知道如何处理的异常。 8、使用finally块释放资源 finally关键字保证无论程序使用任何方式离开try块，finally中的语句都会被执行。在以下三种情况下会进入finally块： try块中的代码正常执行完毕。 在try块中抛出异常。 在try块中执行return、break、continue。 因此，当你需要一个地方来执行在任何情况下都必须执行的代码时，就可以将这些代码放入finally块中。当你的程序中使用了外界资源，如数据库连接，文件等，必须将释放这些资源的代码写入finally块中。 必须注意的是：在finally块中不能抛出异常。JAVA异常处理机制保证无论在任何情况下必须先执行finally块然后再离开try块，因此在try块中发生异常的时候，JAVA虚拟机先转到finally块执行finally块中的代码，finally块执行完毕后，再向外抛出异常。如果在finally块中抛出异常，try块捕捉的异常就不能抛出，外部捕捉到的异常就是finally块中的异常信息，而try块中发生的真正的异常堆栈信息则丢失了。 示例代码如下： Connection con = null; try { con = dataSource.getConnection(); …… } catch(SQLException e) { …… throw e;//进行一些处理后再将数据库异常抛出给调用者处理 } finally { try { con.close(); } catch(SQLException e) { e.printStackTrace(); …… } } 运行程序后，调用者得到的信息如下： java.lang.NullPointerException at myPackage.MyClass.method1(methodl.java:266) 而不是我们期望得到的数据库异常。这是因为这里的con是null的关系，在finally语句中抛出了NullPointerException，在finally块中增加对con是否为null的判断可以避免产生这种情况。 9、在使用异常处理时，还需要注意以下几个问题： Java异常用到了多态的概念，在进行异常捕捉时，先捕捉子类，再捕捉基类的异常信息，否则，捕获子类的代码块永远不会执行。 今早抛出异常，同时对捕捉的异常进行处理；而对于运行时异常，根本不需要理会。 可以根据实际需求自定义异常类，只要继承Exception类即可。 异常能处理就处理，不能处理就抛出。对于一般异常，如果不能进行有效的处理，最好转换为运行时异常抛出，对于最终没有处理的异常，JVM会进行处理。 10、在声明方法时候抛出异常 语法：throws（略） 为什么要在声明方法抛出异常？ 方法是否抛出异常与方法返回值的类型一样重要。假设方法抛出异常却没有声明该方法将抛出异常，那么客户程序员可以调用这个方法而且不用编写处理异常的代码。那么，一旦出现异常，那么这个异常就没有合适的异常控制器来解决。 为什么抛出的异常一定是已检查异常？ RuntimeException与Error可以在任何代码中产生，它们不需要由程序员显示的抛出，一旦出现错误，那么相应的异常会被自动抛出。遇到Error，程序员一般是无能为力的；遇到RuntimeException，那么一定是程序存在逻辑错误，要对程序进行修改；只有已检查异常才是程序员所关心的，程序应该且仅应该抛出或处理已检查异常。而已检查异常是由程序员抛出的，这分为两种情况：客户程序员调用会抛出异常的库函数；客户程序员自己使用throw语句抛出异常。 注意： 覆盖父类某方法的子类方法不能抛出比父类方法更多的异常，所以，有时设计父类的方法时会声明抛出异常，但实际的实现方法的代码却并不抛出异常，这样做的目的就是为了方便子类方法覆盖父类方法时可以抛出异常。 11、在方法中如何抛出异常 语法：throw（略） 抛出什么异常？ 对于一个异常对象，真正有用的信息是异常的对象类型，而异常对象本身毫无意义。比如一个异常对象的类型是ClassCastException，那么这个类名就是唯一有用的信息。所以，在选择抛出什么异常时，最关键的就是选择异常的类名能够明确说明异常情况的类。 异常对象通常有两种构造函数：一种是无参数的构造函数；另一种是带一个字符串的构造函数，这个字符串将作为这个异常对象除了类型名以外的额外说明。 那么总结了这么多，我们做几道题进行热身： 1、Error和Exception有什么区别 答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 2、列出一些你常见的运行时异常？ ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 3、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。 4、TimedOutException不是一个RuntimeException，下面的那些选项载入程序中，使程序可以正常运行？ A public void final() B public void final() throws Exception C public void final() throws TimedOutException D public void final() throw TimedOutException E public throw TimedOutException void final() 答案：BC 试题分析： 如果一个程序在运行时候有异常发生，而这个异常又不是RuntimeException或者Error，那么程序必须对这个异常进行捕获处理或者声明抛出该异常。捕获异常使用try-catch-finally，而声明异常则是在声明方法的同时将会发生的异常进行声明，使用关键字throws。 A项没有使用关键字声明异常，所以是错误的。由于Exception是所有异常的父类，当然也可以代表TimedOutException，所以B项是正确的。C项符合声明异常的格式，是正确的。在D项中，throw是抛出异常，而不是声明异常，关键字使用错误，所以D项是错的。E项的语法格式是错误的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://fengjiaxin.github.io/tags/Exception/"},{"name":"Error","slug":"Error","permalink":"https://fengjiaxin.github.io/tags/Error/"}]},{"title":"如何实现对象的clone","slug":"如何实现对象的clone","date":"2017-02-02T13:38:30.000Z","updated":"2017-02-02T14:29:19.827Z","comments":true,"path":"2017/02/02/如何实现对象的clone/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/如何实现对象的clone/","excerpt":"","text":"有两种方式： 1. 实现Cloneable接口并重写Object类中的clone()方法； Java中所有的类默认继承自Object类，而Object类提供了讴歌clone()方法，这个方法的作用是返回一个Object对象的复制，这个复制函数返回的是一个新的对象而不是一个引用，那么如何使用呢？代码如下： class Obj implements Cloneable{ private int aInt =0; public int getInt(){ return aInt; } public void setAInt(int int1){ aInt = int1; } public void changeInt(){ this.aInt =1; } public Object clone(){ Object o = null; try { o = (Object)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } public class TestRef { public static void main(String[] args) { Obj a = new Obj(); Obj b = (Obj) a.clone(); b.changeInt(); System.out.println(a.getInt());//0 System.out.println(b.getInt());//1 } } 2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆;代码如下： import java.io.Serializable; public class Employee implements Serializable { private static final long serialVersionUID = -6470090944414208496L; private String name; private int id; transient private int salary; @Override public String toString(){ return &quot;Employee{name=&quot;+name+&quot;,id=&quot;+id+&quot;,salary=&quot;+salary+&quot;}&quot;; } //getter and setter methods public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getSalary() { return salary; } public void setSalary(int salary) { this.salary = salary; } } 注意：static代笔类的静态成员，transient代表对象的临时数据，因此被声明为这两种类型的数据成员是不能够被序列化的。 现在我们假设需要把我们的对象写入文件，之后从相同的文件中将其反序列化，因此我们需要一些工具方法，通过使用ObjectInputStream和ObjectOutputStream来达到序列化的目的。 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; /** * A simple class with generic serialize and deserialize method implementations * * */ public class SerializationUtil { // deserialize to Object from given file public static Object deserialize(String fileName) throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(fileName); ObjectInputStream ois = new ObjectInputStream(fis); Object obj = ois.readObject(); ois.close(); return obj; } // serialize the given object and save it to file public static void serialize(Object obj, String fileName) throws IOException { FileOutputStream fos = new FileOutputStream(fileName); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); fos.close(); } } 测试程序： import java.io.IOException; public class SerializationTest { public static void main(String[] args) { String fileName=&quot;employee.ser&quot;; Employee emp = new Employee(); emp.setId(100); emp.setName(&quot;Pankaj&quot;); emp.setSalary(5000); //serialize to file try { SerializationUtil.serialize(emp, fileName); } catch (IOException e) { e.printStackTrace(); return; } Employee empNew = null; try { empNew = (Employee) SerializationUtil.deserialize(fileName); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } System.out.println(&quot;emp Object::&quot;+emp); System.out.println(&quot;empNew Object::&quot;+empNew); } } 运行以上测试程序，可以得到以下输出。 emp Object::Employee{name=Pankaj,id=100,salary=5000} empNew Object::Employee{name=Pankaj,id=100,salary=0} 由于salary是一个transient变量，它的值不会被存入文件中，因此也不会在新的对象中被恢复。类似的，静态变量的值也不会被序列化，因为他们是属于类而非对象的。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://fengjiaxin.github.io/tags/clone/"}]},{"title":"hibernate如何提高性能和二级缓存的含义","slug":"hibernate如何提高性能和二级缓存的含义","date":"2017-02-02T12:37:04.000Z","updated":"2017-02-09T09:06:21.158Z","comments":true,"path":"2017/02/02/hibernate如何提高性能和二级缓存的含义/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/hibernate如何提高性能和二级缓存的含义/","excerpt":"","text":"之前编写了hibernate的一些相关代码，现在总结一些细节。 问题： 在使用Hibernate时如何提高性能？ 延迟加载，当hibernate从数据库中获取一个对象数据，获取一个对象的集合属性值时或者获取某一个对象所关联的另一个对象时，并不会立即从数据库中加载到对象中，而是通过建立一个代理对象，把这个对象的属性值都设置为默认值，只有这些数据在被使用时才会从数据库中加载对应的数据。 缓存技术。hibernate提供了一级缓存与二级缓存，合理的利用缓存有助于提高系统的性能，通过合理配置缓存的参数可以避免不合理的利用缓存导致内存的过度消耗降低系统的性能。 优化查询语句。 说了这么多，那么什么是hibernate的二级缓存？ 缓存的目的是为了通过减少应用程序对物理数据源访问的次数来提高程序运行的效率，原理则是把当前或接下来一段时间可能会用到的数据保存在内存中，在使用时直接从内存中读取。 在hibernate中有一级缓存和二级缓存的概念，一级缓存由Session来管理，二级缓存由SessionFactory来管理，在使用时二级缓存可有可无，但是一级缓存必不可少。 一级缓存的使用场合如下：当使用session查询数据时，首先会在Session内部查找该对象是否存在，若存在，直接返回，否则，到数据库中区查询，并将查询结果缓存起来以便后期使用；缺点是当使用Session来表示一次会话中，它的生命周期较短，并且它是线程不安全的，不能够被多个线程共享，因此在实际使用中对效率的提升并不明显。 二级缓存用来为Hibernate配置一种全局的缓存，以便实现多个线程和事物共享。在使用了二级缓存机制后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，最后才去数据库中查找，与一级缓存相比，二级缓存是独立于hibernate的软件部件，属于第三方的产品，hibernate3以后默认使用的产品是EhCache. 二级缓存一般适用于以下几种情况： 数据量较小，如果数据量较大，缓存太多，大量消耗内存，造成内存资源短缺，从而降低系统的性能。 对数据的修改较少，如果进行大量的修改，就需要频繁的同步，也会影响系统的性能。 不会被大量的应用共享的数据，如果数据被大量线程或事物共享，多线程访问的同步机制会影响系统的性能。 不是很重要的数据，如果数据非常重要，对数据的准确性要求非常高，最好不要使用二级缓存。","categories":[{"name":"Web总结","slug":"Web总结","permalink":"https://fengjiaxin.github.io/categories/Web总结/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://fengjiaxin.github.io/tags/hibernate/"}]},{"title":"静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同","slug":"静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同","date":"2017-02-02T11:55:46.000Z","updated":"2017-02-09T07:52:37.110Z","comments":true,"path":"2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同/","excerpt":"","text":"Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 代码示例如下： /** * 扑克类（一副扑克） * */ public class Poker { private static String[] suites = {&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;}; private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; private Card[] cards; /** * 构造器 * */ public Poker() { cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) { for(int j = 0; j &lt; faces.length; j++) { cards[i * 13 + j] = new Card(suites[i], faces[j]); } } } /** * 洗牌 （随机乱序） * */ public void shuffle() { for(int i = 0, len = cards.length; i &lt; len; i++) { int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; } } /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) { return cards[index]; } /** * 卡片类（一张扑克） * [内部类] * */ public class Card { private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) { this.suite = suite; this.face = face; } @Override public String toString() { String faceStr = &quot;&quot;; switch(face) { case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); } return suite + faceStr; } } } 测试代码如下： class PokerTest { public static void main(String[] args) { Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A } } 面试题：下面的代码哪些地方会产生编译错误？ class Outer { class Inner {} pｕblic static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); } } 解答：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： new Outer().new Inner();","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"静态嵌套类","slug":"静态嵌套类","permalink":"https://fengjiaxin.github.io/tags/静态嵌套类/"},{"name":"内部类","slug":"内部类","permalink":"https://fengjiaxin.github.io/tags/内部类/"}]},{"title":"抽象类（abstract class）和接口（interface）有什么异同","slug":"抽象类（abstract-class）和接口（interface）有什么异同","date":"2017-02-02T11:21:13.000Z","updated":"2017-02-02T11:45:58.257Z","comments":true,"path":"2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/抽象类（abstract-class）和接口（interface）有什么异同/","excerpt":"","text":"如果一个类中包含抽象方法，那么这个类就是抽象类，在Java中可以通过abstract关键字声明该类或该方法时抽象的；接口就是指一些方法的集合，接口中的所有方法都没有方法体。 只要包含一个抽象方法的类就必须别声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明的抽象方法不能包含方法体，在实现时，必须包含相同的或者更低的访问级别；接口中的所有方法都是抽象的，接口中的成员变量都是static final类型。 接口与抽象类的相同点如下： 都不能被实例化。 接口类的实现类或抽象类的子类都只有实现了接口或抽象类的方法后才能被实例化。 接口是抽象类的不同点如下： 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法，而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。 接口需要实现，但是抽象类只能被继承。 接口强调特定功能的实现，其设计理念是“has- a”关系，而抽象类强调所属关系，其设计理念为“is- a”关系。 接口中定义的成员变量默认为public static final,并且必须赋给其初值，其所有成员方法都是public、abstract的；而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法。 接口被用于实现比较常用的功能，便于日后的维护或添加删除方法；而抽象类更倾向于充当公共类的角色，不适用于日后重新对里面的代码进行修改。 一般而言，抽象类多用于在同类事物中有无法具体描述的方法的场景，所以当子类和父类之间存在有逻辑上的层次结构时，推荐使用抽象类；而接口多用于不同类之间，定义不同类之间的通信规则。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"https://fengjiaxin.github.io/tags/抽象类/"},{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"}]},{"title":"Java中字符串与存储的机制","slug":"Java中字符串与存储的机制","date":"2017-02-02T10:29:28.000Z","updated":"2017-02-02T11:22:02.217Z","comments":true,"path":"2017/02/02/Java中字符串与存储的机制/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中字符串与存储的机制/","excerpt":"","text":"今天准备总结一下String对象的存储机制 字符串的声明与初始化有如下两种情况： String s1 = new String(“abc”)//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后用new关键字在堆中创建新的对象 String s2 = “abc”//s1是引用对象，首先在常量池寻找是否有”abc”字符串对象，如果没有则在字符串常量池中创建一个对象，然后s2指向字符串常量池中”abc”对象的首地址。 具体来说： String s1 = &quot;abc&quot;//把&quot;abc&quot;放到常量池中，在编译时产生 String s2 = &quot;ab&quot;+&quot;c&quot;//把&quot;ab&quot;+&quot;c&quot;转换成字符串常量&quot;abc&quot;放到常量区中 String s3 = new String(&quot;abc&quot;)//在运行时把&quot;abc&quot;放到堆里面 String对象的intern()方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象 在明白了以上两点，那么我们来做两道笔试题： 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？ StringBuffer对象适用于字符串经常操作，不产生而额外内存，而String对象不可变，一旦创建不能修改，但是操作简单，效率高，所以适用于字符串较少时，操作次数少的情况下。 请说出下面程序的输出。 class StringEqualTest { public static void main(String[] args) { String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); } } **结果为** System.out.println(s1==s2);//false System.out.println(s1==s5);//true System.out.println(s1==s6);//false System.out.println(s1==s6.intern());//true System.out.println(s2==s2.intern());//false 解释：字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象； String s6 = s3+s4//等价于 StringBuilder temp = s3; temp.append(s4); String s6 = temp.toString(); 所以S6是创建一个新的StringBuilder对象的toString()方法处理成String对象，因此s1==s6为false。","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"String","slug":"String","permalink":"https://fengjiaxin.github.io/tags/String/"},{"name":"常量池","slug":"常量池","permalink":"https://fengjiaxin.github.io/tags/常量池/"}]},{"title":"Java中i++和++i的区别和理解","slug":"Java中i++和++i的区别和理解","date":"2017-02-02T09:31:43.000Z","updated":"2017-02-02T10:03:16.735Z","comments":true,"path":"2017/02/02/Java中i++和++i的区别和理解/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/02/Java中i++和++i的区别和理解/","excerpt":"","text":"今天在做Java题时碰到了关于i++的问题，题目是这样的： public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 最终答案是0。 关于值传递我还是理解的，但是i=i++这个语句我又有点懵了，于是找了相关资料，总结就是JVM的机制所引起的，接下来我要详细介绍一下这方面知识，也算给自己一个交代。 jvm里面有两个存储区，一个是暂存区（是一个堆栈，以下称为堆栈），另一个是变量区。jvm会这样运行这条语句： JVM把count值（其值是0）拷贝到临时变量区。 count值加1，这时候count的值是1。 返回临时变量区的值。 返回值赋值给count，此时count值被重置成0。 所以上题的i= i++应该是下面的过程 int i =0; temp = i;//temp 为临时变量 i =i+1;//i =1 i = temp //i =0 对于自增运算++j与j++，由于加一的执行顺序不同，所以Java中有中间缓存变量来储存其单个表达式的值，而j的自增自减的结果依然保留在原来的变量储存区。因为本体是j的值，而单个表达式的值是中间产生的一个临时变量值，是在整条计算表达式结束后就可以抛弃的值，所以用个临时中间缓存变量在放就可以了。 按字面理解就是i++ 等价于 temp =i;//jvm把i的值拷贝到临时变量temp i =i+1;//i自加1 返回临时变量temp的值0作为表达式i++/++i的值 感觉了解了Java的自增原理，那么我们在练习一道题： int j = 0; j =++j + j++ +j++ + j++; 最终结果为7，详细解答如下 j =j+1 =1; temp1 = j =1; temp2 = j =1; j = j+1 =2; temp3 = j = 2； j =j+1 =3; temp4 = j = 3; j = j+1 =4; j = temp1 +temp2 +temp3 +temp4 = 1+1+2+3 =7; 总结：今天算是终于弄明白i++的原理了，有些问题一定要弄清楚，不能糊弄过去，加油！！！","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"}]},{"title":"基本操作","slug":"基本操作","date":"2017-02-01T11:51:36.000Z","updated":"2017-02-09T07:52:24.959Z","comments":true,"path":"2017/02/01/基本操作/","link":"","permalink":"https://fengjiaxin.github.io/2017/02/01/基本操作/","excerpt":"","text":"命令总结常用命令hexo new &quot;postName&quot; #新建文章 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://fengjiaxin.github.io/categories/备忘录/"}],"tags":[]},{"title":"Java典型设计模式-观察者模式","slug":"Java典型设计模式-观察者模式","date":"2017-01-09T05:04:09.000Z","updated":"2017-02-09T07:35:20.395Z","comments":true,"path":"2017/01/09/Java典型设计模式-观察者模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-观察者模式/","excerpt":"","text":"观察者模式是类和类之间的关系，不涉及到继承。 观察者模式很好理解，类似于邮件订阅和RSS订阅，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 public interface Observer { public void update(); } public class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } } public class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } } public interface Subject { /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); } import java.util.Enumeration; import java.util.Vector; public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } public class ObserverTest { public static void main(String[] args) { Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); } } 运行结果： update self! observer1 has received! observer2 has received! 也许看完实例之后还是比较抽象，再将文字描述和代码实例看一两遍吧，然后结合工作中看哪些场景可以使用这种模式以加深理解。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://fengjiaxin.github.io/tags/行为型模式/"}]},{"title":"Java典型设计模式-适配器模式","slug":"Java典型设计模式-适配器模式","date":"2017-01-09T05:03:57.000Z","updated":"2017-02-09T07:34:19.730Z","comments":true,"path":"2017/01/09/Java典型设计模式-适配器模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-适配器模式/","excerpt":"","text":"适配器模式 适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。有点抽象，我们来看看详细的内容。 类的适配器模式 类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。 public class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } } public interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); } public class Adapter extends Source implements Targetable { public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } } public class AdapterTest { public static void main(String[] args) { Targetable target = new Adapter(); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 对象的适配器模式 对象的适配器模式的基本思路和类的适配器模式相同，只是将Adapter类作修改成Wrapper，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source) { super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } } public class AdapterTest { public static void main(String[] args) { Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); } } AdapterTest的运行结果： this is original method! this is the targetable method! 接口的适配器模式 接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行了。 在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： public interface Sourceable { public void method1(); public void method2(); } //抽象类Wrapper2： public abstract class Wrapper2 implements Sourceable{ public void method1(){} public void method2(){} } public class SourceSub1 extends Wrapper2 { public void method1(){ System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); } } public class SourceSub2 extends Wrapper2 { public void method2(){ System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); } } public class WrapperTest { public static void main(String[] args) { Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); } } 测试输出： the sourceable interface&apos;s first Sub1! the sourceable interface&apos;s second Sub2! 总结一下三种适配器模式的应用场景 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://fengjiaxin.github.io/tags/结构型模式/"}]},{"title":"Java典型设计模式-工厂方法模式","slug":"Java典型设计模式-工厂方法模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-09T07:38:25.119Z","comments":true,"path":"2017/01/09/Java典型设计模式-工厂方法模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-工厂方法模式/","excerpt":"","text":"### 工厂方法模式 ### 工厂方法模式分为三种：普通工厂模式、多个工厂方法模式和静态工厂方法模式。 #### 1 普通工厂模式 #### 普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 public interface MyInterface { public void print(); } public class MyClassOne implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassOne&quot;); } } public class MyClassTwo implements MyInterface { @Override public void print() { System.out.println(&quot;MyClassTwo&quot;); } } public class MyFactory { public MyInterface produce(String type) { if (&quot;One&quot;.equals(type)) { return new MyClassOne(); } else if (&quot;Two&quot;.equals(type)) { return new MyClassTwo(); } else { System.out.println(&quot;没有要找的类型&quot;); return null; } } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produce(&quot;One&quot;); myi.print(); } } 再回头来理解这句话：普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 ### 2 多个工厂方法模式 ### 多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。我们修改MyFactory和FactoryTest如下： public class MyFactory { public MyInterface produceOne() { return new MyClassOne(); } public MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyFactory factory = new MyFactory(); MyInterface myi = factory.produceOne(); myi.print(); } } 再回头来理解这句话：多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。 ### 3 静态工厂方法模式 ### 静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。我们修改MyFactory和FactoryTest如下： public class MyFactory { public static MyInterface produceOne() { return new MyClassOne(); } public static MyInterface produceTwo() { return new MyClassTwo(); } } public class FactoryTest { public static void main(String[] args){ MyInterface myi = MyFactory.produceOne(); myi.print(); } 再回顾：静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"Java典型设计模式-抽象工厂方法模式","slug":"Java典型设计模式-抽象工厂方法模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-09T07:39:42.282Z","comments":true,"path":"2017/01/09/Java典型设计模式-抽象工厂方法模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-抽象工厂方法模式/","excerpt":"","text":"### 抽象工厂模式 ### 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则。 为解决这个问题，我们来看看抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 这样就符合闭包原则了 下面来看看代码： MyInterface、MyClassOne、MyClassTwo不变。 新增如下接口和类： public interface Provider { public MyInterface produce(); } public class MyFactoryOne implements Provider { @Override public MyInterface produce() { return new MyClassOne(); } } public class MyFactoryTwo implements Provider { @Override public MyInterface produce() { return new MyClassTwo(); } } 修改测试类FactoryTest如下： public class FactoryTest { public static void main(String[] args){ Provider provider = new MyFactoryOne(); MyInterface myi = provider.produce(); myi.print(); } } 再回顾：抽象工厂模式就是创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"Java典型设计模式-单例模式","slug":"Java典型设计模式-单例模式","date":"2017-01-09T04:01:47.000Z","updated":"2017-02-09T07:49:14.410Z","comments":true,"path":"2017/01/09/Java典型设计模式-单例模式/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/09/Java典型设计模式-单例模式/","excerpt":"","text":"### 单例模式 ### 单例模式就是一个类只有一个实例，不允许外界创建新的对象，但是可以调用类的实例，代码如下： public class MyObject { private static MyObject myObject; private MyObject() { } public static MyObject getInstance() { if (myObject != null) { } else { myObject = new MyObject(); } return myObject; } } 但是这样会引发多线程问题，这个问题就先放下，对线程有了更深入的了解后在回看。 在学习了线程的知识后，从新看单例模式，发现果然不是只有上面一种单例模式，那么根据我学习的知识进行一下补充： 在Java语言中实现单例模式通常有两种表现方式： 饿汉式单例类：类加载时，就进行对象实例化。 懒汉式单例类：第一次引用类时，才进行对象实例化。上面的例子是非同步懒汉式单例类。 饿汉式单例类代码如下： package Design.Creational.Singleton; //恶汉式单例 public class Singleton1 { private static Singleton1 m_instance = new Singleton1(); private Singleton1(){ } public static Singleton1 getInstance(){ return m_instance; } } 第一个例子是线程不安全的，如果有连个线程同时调用实例方法，那么有可能会生成两个实例，违反了单例模式。 同步懒汉式代码如下： package Design.Creational.Singleton; //懒汉式单例 public class Singleton2 { private static Singleton2 m_instance = null; private Singleton2(){ } public synchronized static Singleton2 getInstance(){ if(m_instance==null) m_instance = new Singleton2(); return m_instance; } }","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://fengjiaxin.github.io/tags/创建型模式/"}]},{"title":"设计模式六大原则(5): 聚合/复用原则","slug":"设计模式六大原则-5-聚合-复用原则","date":"2017-01-06T03:58:37.000Z","updated":"2017-02-09T07:27:28.677Z","comments":true,"path":"2017/01/06/设计模式六大原则-5-聚合-复用原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-5-聚合-复用原则/","excerpt":"","text":"1 问题的由来 在实际开发中，新建一个类可能会用到多个以前的类的方法，但是在设计时是不能轻易采用继承机制的；因为在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 2 聚合/复用原则 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。 组合或聚合关系可以将成员对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见。 相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 3 举例说明 在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如下所示： 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。 现使用合成复用原则对其进行重构。在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如下所示： CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中。 如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。。 4 总结 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(4): 迪米特原则","slug":"设计模式六大原则-4-迪米特原则","date":"2017-01-06T03:58:12.000Z","updated":"2017-02-09T07:27:38.587Z","comments":true,"path":"2017/01/06/设计模式六大原则-4-迪米特原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-4-迪米特原则/","excerpt":"","text":"1 问题的由来 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 2 迪米特原则 通俗的来讲：就是一个类对自己依赖的类知道的越少越好。 对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。 更简单的定义：只与直接的朋友通信。 那么什么是直接的朋友？？？ 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。 出现成员变量、方法参数、方法返回值中的类为直接的朋友， 出现在局部变量中的类则不是直接的朋友。 也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 3 举例 举一个代码例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。 先看一个错误的例子 //总公司员工 class Employee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司员工 class SubEmployee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司管理 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } } //总公司管理 class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1){ System.out.println(e.getId()); } List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } public class Client{ public static void main(String[] args){ CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); } } 主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。 修改后的代码 class SubCompanyManager{ public List&lt;SubEmployee&gt; getAllEmployee(){ List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(&quot;分公司&quot;+i); list.add(emp); } return list; } public void printEmployee(){ List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list){ System.out.println(e.getId()); } } } class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 3 总结 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(3): 接口隔离原则","slug":"设计模式六大原则-3-接口隔离原则","date":"2017-01-06T03:57:45.000Z","updated":"2017-02-09T07:27:49.935Z","comments":true,"path":"2017/01/06/设计模式六大原则-3-接口隔离原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-3-接口隔离原则/","excerpt":"","text":"1 问题的由来 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类B和类D来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 2 接口隔离原则 客户端不应该依赖它不需要的接口 意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。 类间的依赖关系应该建立在最小的接口上 接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。 接下来是代码示例： public interface I { public void method1(); public void method2(); public void method3(); } public class B implements I{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } @Override public void method3() {//类B并不需要接口I的方法3功能，但是由于实现接口I，所以不得不实现方法3 //在这里写一个空方法 } } public class D implements I{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } @Override public void method1() {//类D并不需要接口I的方法1功能，但是由于实现接口I，所以不得不实现方法1 //在这里写一个空方法 } } //类A通过接口I依赖类B public class A { public void depend1(I i){ i.method1(); } } //类C通过接口I依赖类D public class C { public void depend1(I i){ i.method3(); } } public class Client { public static void main(String[] args) { A a = new A(); I i1 = new B(); a.depend1(i1); C c = new C(); I i2 = new D(); c.depend1(i2); } } 运行结果： 类B实现了接口I的方法1 类D实现了接口I的方法3 可以看出，如果接口过于臃肿，不同业务逻辑的抽象方法都放在一个接口内，会造成它的实现类必须实现自己并不需要的方法 这种设计方式显然是不妥当的。所以应该把接口I拆分成3个接口，使得实现类只需要实现自己需要的接口即可，修改代码如下： public interface I1 { public void method1(); } public interface I2 { public void method2(); } public interface I3 { public void method3(); } public class B implements I1,I2{ @Override public void method1() { System.out.println(&quot;类B实现了接口I的方法1&quot;); } @Override public void method2() { System.out.println(&quot;类B实现了接口I的方法2&quot;); } } public class D implements I2,I3{ @Override public void method2() { System.out.println(&quot;类D实现了接口I的方法2&quot;); } @Override public void method3() { System.out.println(&quot;类D实现了接口I的方法3&quot;); } } 3 与单一职责区别 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。4 总结 对于接口隔离原则来说，接口尽量小，但是也要有限度。 对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(2): 依赖倒置原则","slug":"设计模式六大原则-2-依赖倒置原则","date":"2017-01-06T03:57:15.000Z","updated":"2017-02-09T07:27:59.062Z","comments":true,"path":"2017/01/06/设计模式六大原则-2-依赖倒置原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-2-依赖倒置原则/","excerpt":"","text":"1 问题的由来 类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑。类B和C是底层模块，负责基本的原子操作。假如修改类A，将会给程序带来不必要的风险。 2 依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 抽象：即抽象类或接口，两者是不能够实例化的。 细节：即具体的实现类，实现接口或者继承抽象类所产生的类。 //具体Jim人类 public class Jim { public void eat(Apple apple){ System.out.println(&quot;Jim eat &quot; + apple.getName()); } } //具体苹果类 public class Apple { public String getName(){ return &quot;apple&quot;; } } public class Client { public static void main(String[] args) { Jim jim = new Jim(); Apple apple = new Apple(); jim.eat(apple); } } 运行结果：Jim eat apple 其实上面这个设计很不好，如果吃香蕉的话，就要改变依赖类，怎么吃水果是人自己的选择，为什么还要修改自己的代码；并且Jim类和Apple类紧耦合，不太符合低耦合，高内聚的原则，那怎么解决这类问题呢？ 而根据依赖倒置原则，我们可以提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。 修改代码如下 //人接口 public interface People { public void eat(Fruit fruit); } //水果接口 public interface Fruit { public String getName(); } //具体Jim人类 public class Jim implements People{ public void eat(Fruit fruit){ System.out.println(&quot;Jim eat &quot; + fruit.getName()); } } //具体苹果类 public class Apple implements Fruit{ public String getName(){ return &quot;apple&quot;; } } //具体香蕉类 public class Banana implements Fruit{ public String getName(){ return &quot;banana&quot;; } } public class Client { public static void main(String[] args) { People jim = new Jim(); Fruit apple = new Apple(); Fruit Banana = new Banana();//这里符合了里氏替换原则 jim.eat(apple); jim.eat(Banana); } } 运行结果： Jim eat apple Jim eat banana People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，做到了高层模块不应该依赖低层模块，两者都应该依赖于抽象。 People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节。 Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。 3 什么是倒置 就是提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。 4 依赖的三种实现方式 对象的依赖关系有三种方式来传递: 接口方法中声明依赖对象 public interface People { public void eat(Fruit fruit); } 构造方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public Jim(Fruit fruit){//构造方法传递依赖对象 this.fruit = fruit; } } Setter方法传递依赖对象 public class Jim implements People{ private Fruit fruit; public void setFruit(Fruit fruit){//setter方式传递依赖对象 this.fruit = fruit; } } 5 优点 从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。 还有一个优点是，实际项目开发中，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。 6 总结 依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。 依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。 但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"设计模式六大原则(1): 里氏替换原则","slug":"设计模式六大原则-1-里氏替换原则","date":"2017-01-06T03:56:46.000Z","updated":"2017-02-09T07:28:07.834Z","comments":true,"path":"2017/01/06/设计模式六大原则-1-里氏替换原则/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/06/设计模式六大原则-1-里氏替换原则/","excerpt":"","text":"1 问题由来 对象有三大特性：封装、继承、多态，子类在继承父类后，经常任意重写父类的方法，这时候可能会导致父类的原功能发生故障。 2 里氏替换原则 通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。 更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。 //抽象父类电脑 public abstract class Computer { public abstract void use(); } class IBM extends Computer{ @Override public void use() { System.out.println(&quot;use IBM Computer.&quot;); } } class HP extends Computer{ @Override public void use() { System.out.println(&quot;use HP Computer.&quot;); } } public class Client{ public static void main(String[] args) { Computer ibm = new IBM(); Computer hp = new HP();//引用基类的地方能透明地使用其子类的对象。 ibm.use(); hp.use(); } } 3 四层含义 里氏替换原则包含以下4层含义： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。 子类中可以增加自己特有的方法。 在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 这个其实很好理解，就是入口更宽松，那么就以代码更好地理解吧！ import java.util.HashMap; public class Father { public void func(HashMap m){ System.out.println(&quot;执行父类...&quot;); } } import java.util.Map; public class Son extends Father{ public void func(Map m){//方法的形参比父类的更宽松 System.out.println(&quot;执行子类...&quot;); } } import java.util.HashMap; public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 HashMap h = new HashMap(); f.func(h); } } 运行结果：执行父类… 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 这个也不难理解，就是出口更严格，那么就以代码更好地理解吧！ import java.util.Map; public abstract class Father { public abstract Map func(); } import java.util.HashMap; public class Son extends Father{ @Override public HashMap func(){//方法的返回值比父类的更严格 HashMap h = new HashMap(); h.put(&quot;h&quot;, &quot;执行子类...&quot;); return h; } } public class Client{ public static void main(String[] args) { Father f = new Son();//引用基类的地方能透明地使用其子类的对象。 System.out.println(f.func()); } } 4 总结 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性，不符合设计模式的低耦合，高内聚，因此系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"Java设计模式简介（个人总结）","slug":"Java设计模式简介（个人总结）","date":"2017-01-05T14:06:21.000Z","updated":"2017-02-09T07:30:09.355Z","comments":true,"path":"2017/01/05/Java设计模式简介（个人总结）/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/Java设计模式简介（个人总结）/","excerpt":"","text":"这学期学习了软件工程课程，对Java语言的理解更近一步，但是不足还是那么多，在设计系统的过程中其实我就一直在思考设计模式的问题，都说了解了设计模式的程序员才能更好地设计出系统，那么今天我就本着执着的精神总结一下关于ava设计模式的的基本原则。 设计模式原则 书上总结有六大原则，首先就简单说明一下这六大原则。 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 里氏代换原则（Liskov Substitution Principle） 子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用 子类返回值的能力是比父类小的 任何子类方法可以声明抛出父类方法声明异常的子类；而不能声明抛出父类没有声明的异常。 依赖倒转原则（Dependence Inversion Principle） 是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 到这里，相信都被概念弄蒙了，其实意思很好理解，就是降低耦合性，提高内聚性。基于这六大原则，前辈们总结出了23种设计模式供大家学习，那么我这里就简单说明介绍一下吧，稍后再下一篇博客在介绍4种典型的设计模式。 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 之后主要介绍工厂方法模式，抽象工厂模式，单例模式，适配器模式，观察者模式，这五个模式在Java面试中可能会问到，所以接下来详细介绍一下这五种模式。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[]},{"title":"JVM内存管理（一）","slug":"JVM内存管理","date":"2017-01-05T03:17:28.000Z","updated":"2017-02-08T04:01:58.225Z","comments":true,"path":"2017/01/05/JVM内存管理/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/JVM内存管理/","excerpt":"","text":"在学习了Java之后，我们知道不需要显示的调用分配内存的函数，因为GC会帮我们回收释放内存，但是作为程序员，需要了解Java是如何管理内存的，这样在出现OutOfMemoryError时，才不至于手忙脚乱，那么在学习JVM内存管理，我们也需要从操作系统的角度来理解相关知识。 1、物理内存与虚拟内存 物理内存就是RAM，随机存储器，在计算机中，还有寄存器，用于存储计算单元执行指令的中间结果。虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，共享指的只是空间上的共享，在逻辑上仍然是不能互相访问的；虚拟地址不但可以让进程共享物理内存、提高内存利用率，而且还可以扩展内存的地址空间。 2、内核空见和用户空间内核空间主要指的是操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑，为了保证操作系统的稳定性，运行在操作系统中的用户程序不能访问操作系统所使用的内存空间，用户程序可以调用操作系统提供的接口实现访问硬件资源、网络连接等功能。 3、在Java中哪些组件需要使用内存？Java启动后作为一个进程运行在操作系统中，那么这个进程有哪些部分需要分配内存空间？ Java堆：Java堆是用于存储Java对象的内存区域；在Java堆中内存空间的管理由JVM来控制，对象创建由Java应用程序控制，但是对象空间所占的空间释放由管理堆内存的垃圾收集器来完成。 线程：Java运行实际程序的实体是线程。 类和类加载器：他们被存储在堆中，这个区域成为永久代。 NIO：基于通道和缓冲区来执行IO的新方式，分配的内存使用的是本机内存而不是Java堆上的内存，显然不需要讲数据复制到Java内存中。 JNI：JNI技术使得本机代码（C）可以调用Java方法，所以JNI也会增加Java运行时的本机内存占用。 4、JVM内存结构JVM时按照运行时数据的存储结构来划分内存结构的，JVM在运行Java程序时，将他们划分为几种不同格式的数据，分别存储在不同的区域，这些数据统一称为运行时数据，运行时数据包括Java程序本身的数据信息和JVM运行Java程序需要的额外数据信息。 在Java虚拟机规范中将Java运行时数据划分为6种，分别是PC寄存器数据、Java栈、堆、方法区、本地方法区、运行时常量池。 PC寄存器：用于保存当前正在正常执行的程序的内存地址。 Java栈：每当创建一个线程时，JVM就会为这个线程创建一个对应的Java栈，在Java栈中又会含有多个栈帧，这些栈帧时与每个方法联系起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些内部变量、操作栈和方法返回值等信息。 堆：是存储Java对象的地方，是JVM管理Java对象的核心存储区域，每一个存储在堆中的Java对象都会是这个对象的类的一个副本，它会复制包括继承自他父类的所有非静态属性。 方法区：用于存储类结构信息的地方，属于Java堆中的永久区，可以被所有线程共享。 运行时常量池：代表运行时每个class文件中的常量表，是方法区的一部分。 本地方法栈：是为JVM运行Native方法准备的空间，和Java栈的作用类似 5、JVM内存分配策略 操作系统将内存分配策略分为三种。分别是静态内存分配、栈内存分配、堆内存分配。 静态内存分配指的是在程序编译时就能够确定每个数据在运行时的存储空间需求，在编译时就就可以给它们分配固定的内存空间。 栈式内存分配也成为动态内存分配，由一个雷士与堆栈的运行栈来实现的，和静态内存相反，程序对数据区的需求在编译时时完全未知的，只有到运行时才知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区的大小才能为其分配内存。 堆分配内存：在编写程序时除了在编译时能确定数据的存储空间和在程序入口处能知道存储空间外，还有一种情况就是当程序真正运行到相应代码时才会知道空间的大小。 JVM内存分配主要基于两种：堆和栈 Java栈式如何分配内存的呢？Java栈的分配是和线程绑定在一起的，当我们创建一个线程时，JVM就会为这个线程创建一个新的Java栈，一个线程的方法的调用和返回对应于这个Java栈中的压栈和出栈；当线程激活一个java方法时，JVM就会在线程的Java堆栈里新压入一个帧，帧就成为了当前帧。 栈的存取速度比堆块，仅次于寄存器，栈数据可以共享，但是存在栈中的数据大小和生存周期必须是确定的。 每个Java应用都唯一对应一个JVM实例，每个实例对应一个堆；应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用程序的所有线程共享，所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。 Java的堆是一个运行时数据区，堆是由垃圾回收器来负责，堆的优势是可以动态的分配内存大小，生存周期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的GC会自动收走这些不再使用的数据；缺点是由于是在运行时动态分配内存，存取速度较慢。 6、静态内存分配与回收 开发人员一般情况下不需要了解内存这个概念，因为内存的开辟与回收由JVM操作，但是在学习了操作系统之后，想要了解数据在Java是如何申请内存的，总结而言就是通常的显示内存申请有如下两种： 静态内存分配 动态内存分配 1.1 静态内存分配 在Java中静态内存分配是指在Java编译时就已经能确定需要的内存空间，当程序被加载时系统把内存一次性分配给它；这些内存不会再程序执行时发生变化，直到程序执行结束时内存才会被回收。在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存的。 1.2 动态内存分配和回收 在Java中对象的内存空间是动态分配的，所谓动态分配就是在程序执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。 从前面的分析中可知内存的分配实在对象创建时发生的，而内存的回收是以对象不再引用为前提的，这种动态内存的分配和回收是和Java中的一些数据结构类型关联的。 如何确定这个对象什么时候不再被使用，如何回收，这正是JVM的垃圾收集器的工作。 1.3 如何检测垃圾 垃圾收集器的工作： 正确检测出垃圾对象 释放垃圾对象占用的内存空间 如何检测出垃圾是GC上的关键；从前面的分析可以总结出：只要某个对象不再被其他的活动对象引用，这个对象就可以被回收了，活动对象指的是能够被一个根对象集合到达的对象。 那么根对象集合中有些什么呢？ 在方法中局部变量区的引用：对象直接存储在栈帧的局部变量区中。 在Java操作栈中的对象引用：对象直接在操作栈中持有。 在常量池的对象引用：每个类都会包含一个常量池，这些常用池中就会包含很多对象的引用。 在本地方法中次有的对象引用 类的Class对象 JVM在做垃圾回收时就会检查堆中的所有对象是否都会被这些跟对象直接或间接引用，能够被引用的对象就是活动对象，否则就被GC回收。 1.4 基于分代的垃圾收集算法 算法的设计思路：把对象按照寿命长短分组，分为年轻代和老年代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么把这个对象划分到老年代。老年代的收集频度不像年轻代那么频繁，这样就减少了每次垃圾收集时所要扫描的对象的数量，提高了垃圾回收效率。 这种设计思路是把堆划分为若干个子堆，每个子堆对应一个年龄代，如下图所示： JVM将整个堆划分为Young区，Old区，Perm区，分别存放不同年龄的对象，这三个区存放的对象有如下区别： Young区分为Eden区和Survivor区，其中所有新创建的对象都在Eden区，当Eden区满后会触发minor GC将Eden区让存活的对象复制到其中一个Survivor中，另外一个Survivor区中的存活对象也复制到这个Survivor中，保证始终有一个Survivor区是空的。 Old区存放的是Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将对象存放到Survivor区中，如果Survivor区中仍然存不下这些对象，GC收集器会将这些对象直接存放到Old区，如果Survivor区中的对象足够老，直接存放到Old区中，如果Old区中也满了，触发Full GC，回收整个堆内存。 Perm区存放的是类的Class对象，如果一个类被频繁的加载，可能会导致Perm区满，Perm区的垃圾回收也是有Full GC触发的。 1.5 minor GC、full GC、major GC区别 Minor GC 是指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。注意：除了将Eden区的非活动对象回收后，还会把一些老对象复制到Old区中。 Major GC 是清理老年代。 Full GC 是清理整个堆空间—包括年轻代和老年代。 许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的 1.6 Hotspot三类垃圾收集算法 Serial Collector(单线程收集器)：是JVM在client模式下的默认GC方式，当Eden空间不足时，触发Minor GC，会先检查之前每次Minor GC晋升到Old区的对象的平均大小，如果Old区的剩余空间小于平均大小，则直接触发Full GC，如果Old区的剩余空间大于平均大小，则看HandlePromotionFailure的值。如果为true，仅触发Minor GC，否则再触发一次Full GC。当Survivor区中的To Space放不下这些对象时，这些对象被放入Old区，如果Old或Perm区空间不足，将会触发Full GC。JVM的GC操作是串行的，JVM中的其他应用程序会全部停止。 parallel GC根据Minor GC和Full GC的不同分为三种，分别是ParNewGC，ParallelGC和ParallelOldGC。 ParNewGC：回收策略与Serial Collector相似，只是回收不是单线程的，而是多线程并行回收。 ParallelGC：Server下默认的GC方式。当在Eden中申请内存发生不够的情况时，看当前申请的空间是否大于Eden的一半，如果大于则直接在Old区中分配空间，如果小于则触发Minor GC。触发Minor GC前会检查过去每次晋升Old区的平均大小是否大于Old区的剩余空间。如果大于则再次触发Full GC，在这次触发后仍会按这个规则重新检查一次，Full GC会执行两次。 ParallelOldGC：与ParalelGC不同之处在于Full GC。Parallel GC的Full GC清空整个Heap堆中的垃圾对象，清除Perm区中已被卸载的类信息，并进行压缩。而ParallelOldGC清除Heap堆中的部分垃圾对象，并进行部分的空间压缩。GC程序是多线程，当同样暂停其他所有程序。 CMS Collector：既不是Minor GC，也不是Full GC，是基于两种GC之间的一种GC。触发规则是检查Old区或Prem区的使用率。触发CMS GC回收的只是Old区或Perm区的垃圾对象。与Minor GC或Full GC没有关系。这种模式下的Minor GC触发与回收规则与Serial GC基本一致。不同之处只是GC回收变成多线程而已。有两种情况触发Full GC。一种是Eden分配失败，Minor GC后分配到To Space，To Space不够再分配到Old区，Old区不够则触发Full GC。另外一种情况是，当CMS GC正在进行时先Old区申请内存失败，则会直接触发Full GC。 1.7 三种GC优缺点对比 GC 优点 缺点 Serial Collector(串行) 适合内存有限的情况 回手收慢 Parallel Collector(并行) 效率高 当Heap过大时，应用程序暂停时间较长 CMS Collector(并发) Old区回收暂停时间短 产生内存碎片，整个GC耗时较长，耗CPU","categories":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/categories/JAVA总结/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://fengjiaxin.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://fengjiaxin.github.io/tags/GC/"}]},{"title":"数据库访问中遇到的问题","slug":"数据库访问中遇到的问题","date":"2017-01-03T07:45:27.000Z","updated":"2017-02-09T09:05:02.660Z","comments":true,"path":"2017/01/03/数据库访问中遇到的问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/数据库访问中遇到的问题/","excerpt":"","text":"今天在编码中出现了No suitable driver found for jdbc，又是找遍了网上的资料，基本上都说是三个问题： 连接URL格式出现了问题 驱动字符串出错(com.mysql.jdbc.Driver) 三是Classpath中没有加入合适的mysql_jdbc驱动 经过我的仔细检查，出现了两次错误，总结如下： 在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。但是在 Eclipse web 项目中，当执行 Class.forName(“om.mysql.jdbc.Driver”);时 不会去查找驱动的。所以本实例中我们需要把mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。 查看资料说Java1.8之后就不用写Class.forName(“com.mysql.jdbc.Driver”) ; 我就没写，后来将这句代码写上，发现成功连接数据库，下次还是写上吧。 那我就把自己写的DBUtil.java代码贴上吧！ public class DBUtil { public static Connection getConnection() { String username = &quot;root&quot;; String password = &quot;123456&quot;; String url = &quot;jdbc:mysql://localhost:3306/itat_shop&quot;; Connection con = null; //1.加载驱动程序 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); con = DriverManager.getConnection(url, username, password); } catch(ClassNotFoundException |SQLException e) { e.printStackTrace(); } return con; } public static void close(Connection con) { try { if(con!=null) con.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(java.sql.PreparedStatement ps) { try { if(ps!=null) ps.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(ResultSet rs) { try { if(rs!=null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }","categories":[{"name":"问题总结","slug":"问题总结","permalink":"https://fengjiaxin.github.io/categories/问题总结/"}],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"https://fengjiaxin.github.io/tags/jdbc/"},{"name":"mysql","slug":"mysql","permalink":"https://fengjiaxin.github.io/tags/mysql/"}]},{"title":"返回类型是接口的分析","slug":"返回类型是接口的分析","date":"2016-12-27T02:36:51.000Z","updated":"2017-02-09T07:52:12.952Z","comments":true,"path":"2016/12/27/返回类型是接口的分析/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/27/返回类型是接口的分析/","excerpt":"","text":"今天在学习Servlet的过程中，书上关于DaoFactory的代码如下： public class DAOFactory { public static IUserDao getUserDao() { return new UserDao(); } } 在这里IUserDao是一个接口类型，但是返回的确实一个实现类，这明显不是一个类型啊，我就带着疑问上网搜索，总结如下： 接口虽然不能被实例化，但是接口的实现类都可以向上转型为接口； 面向接口编程是指我们在编写代码时对数据参数的定义尽量写成接口，待真正实现的时候再用实际类型代替； 代码的耦合性降低，在运行时我只需修改实现类类型，就可以实现不同的功能，而不必要修改接口的代码。 总结：接口的实现类可以向上转型为接口类，表面上返回的是接口类型，实际上返回的却是接口的实现类，如果需要取出接口的实现类，可以向下转型。","categories":[{"name":"JAVA设计模式","slug":"JAVA设计模式","permalink":"https://fengjiaxin.github.io/categories/JAVA设计模式/"}],"tags":[{"name":"接口","slug":"接口","permalink":"https://fengjiaxin.github.io/tags/接口/"}]},{"title":"Servlet技术笔记","slug":"Servlet技术笔记","date":"2016-12-26T07:49:21.000Z","updated":"2017-02-09T09:06:06.242Z","comments":true,"path":"2016/12/26/Servlet技术笔记/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/26/Servlet技术笔记/","excerpt":"","text":"1 ServletAPI：1.1 Servlet接口的主要方法及作用： init():在Servlet实例化之后，Servlet容器会调用init()方法，来初始化该对象。 service():容器调用Service()方法来处理客户端的请求。 destroy():容器检测到一个Servlet对象应该从服务器中被移除的时候，容器调用该对象的destroy()方法，以便Servlet对象可以释放使用的资源。 getServletConfig():返回调用init()方法时传递给Servlet对象的ServletConfig对象。 1.2 ServletRequest和ServletResponse： Servlet由Servlet容器管理，当客户端请求时，容器创建一个ServletRequest对象，封装请求数据，同事创建一个ServletResponse对象，封装响应数据，这两个对象被容器作为service()方法的参数传递给Servlet。 1.3 ServletConfig: Servlet容器使用ServletConfig对象在Servlet初始化期间向它传递配置信息，一个Servlet只能有一个ServletConfig对象。 1.4 简单实例 编写HelloWorldServlet例子，源代码见HelloServlet.java 1.5HttpServlet HttpServlet继承自GenericServlet，当容器收到一个针对HttpServlet对象的请求时，调用顺序如下： 调用public 的service()方法； 将参数类型转换为HttpServletRequest和HttpServletResponse，然后调用protected 的service()方法，将转换后的参数传进去； 在protected 的service()方法中，首先调用HttpServletRequest对象的getMethod()方法，确定是get，还是post方法。然后调用相应的doGet()或者doPost()等方法。 因此，在编写HttpServlet的派生类时，只许重写响应的doXXX()方法。 1.6 HttpServletRequest和HttpServletResponse get()方法：提交的数据提交到URL中，传递给后台服务器。 post()方法：提交的数据作为请求正文的内容发送到服务端，在URL看不到附加的请求数据。 2 简单实例：OutputInfoServlet：代码见OutputInfoServlet.java。 一个登陆实例：需要编写LoginServlet2.java，CenterServlet.java，success.html，web.xml。 3 Servlet异常 ServletException：可以被init()，service()，doXXX()等方法抛出。 UnavailableException：是ServletException的子类，用于向Servlet容器指示这个Servlet永久的或暂时的不可用。 4 Servlet生命周期 加载和实例化：Servlet容器负责加载和实例化Servlet，容器是通过反射机制来创建Servlet实例，调用不带参数的构造方法。 初始化：调用init()方法，在处理客户端请求时完成一些初始化工作。 请求处理：调用Service()方法，若执行期间有错误，可以抛出ServletException或UnavailableException异常，如果UnavailableException指示该实例永久不可用，则调用该实例的desttroy()方法。 服务终止：Servlet容器检测Servlet实例应该被移除时，调用destroy()方法，释放该实例使用的资源，等待Java的垃圾回收期回收。 5 Servlet上下文 运行在Java虚拟机中的每一个Web应用程序都有一个与之相关的Servlet上下文，Servlet API提供了ServletContext接口表示上下文，接口中定义了一些方法，Servlet可以使用这些方法与它的Servlet容器践行通信。 编写页面访问统计的实例：一个Web应用程序只有一个ServletContext对象，而且该对象可以被Web应用程序的所有Servlet所访问，因此使用ServletContext对象保存共享信息。 源码如下：CountServlet.java 注意：不同的Web应用程序具有不同的Servlet上下文，所以不同web应用程序不能利用ServletContext来共享属性；并且访问次数在重启Tomcat服务器后，重新计数，所以为了永久保存访问次数，可以存到文件或数据库中。 6 请求转发6.1 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建，用于封装一个路径标识的服务器资源。利用该对象，可以把请求转发给Servlet或JSP页面。 forward()：用于将请求从一个Servlet传递给服务器上的另外的Servlet或JSP页面或HTML文件；这个方法必须在响应被提交给客户端之前调用，调用后，原先在响应缓存中没有提交的内容将被自动清除。 include()：用于在响应中包含其他资源的内容。 上述两个方法区别：利用include()方法将请求转发给其他Servlet，被调用的Servlet对该请求做出的响应将并入原先的响应对象中，原先的Servlet还可以继续输出响应信息；而利用forward()方法将请求转发给其他的Servlet，将由被调用的Servlet负责对请求做出响应，而原先的Servlet的执行则终止。 6.2 得到RequestDispatcher对象 ServletContext接口的getRequestDispatcher()方法：参数必须以/开始，被解释为相对于当前上下文根的路径。 ServletRequest接口的getRequestDispatcher()方法：参数不但可以是相对于上下文的路径，也可以是相对于当前Servlet的路径；例如/myServlet、myServlet均合法。 6.3 请求转发的实例 CenterServlet.java，LoginServlet2.java。 6.4 sendRedirect()和forward()的区别HttpServletResponse接口的sendRedirect()和RequestDispatcher接口的forward()方法都可以利用另外的资源为客户端服务，但是工作原理有本质的区别。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1让Servlet2 为客户端服务 Servlet1调用SendRedirect()方法，将客户端的请求重定向到Servlet2 浏览器访问Servlet2 Servlet2 对客户端的请求做出响应 重定向这个过程对用户透明，浏览器会自动完成新的访问。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1想让Servlet2对客户端进行响应，调用forward()方法，将请求转发给Servlet2进行处理 Servlet2对请求做出响应 调用forward()方法，对浏览器来说是透明的，浏览器只知道发出一个请求。 还有一个重要区别：sendRidirect()方法不但可以在位于同一主机上的不同web应用程序之间的重定向，而且可以将客户端重定向到其他服务器上的web应用程序资源","categories":[{"name":"Web总结","slug":"Web总结","permalink":"https://fengjiaxin.github.io/categories/Web总结/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://fengjiaxin.github.io/tags/Servlet/"}]},{"title":"StacK的一些例子","slug":"Stack","date":"2016-12-20T12:41:17.000Z","updated":"2017-02-09T07:51:42.857Z","comments":true,"path":"2016/12/20/Stack/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/20/Stack/","excerpt":"","text":"栈就是后进先出的数据结构1. 栈的简单实现，采用数组实现class StackX{ private int maxSize; private long[] stackArray; private int top; public StackX(int s){ maxSize = s; stackArray = new long[maxSize]; top=-1; } public void push(long value){ stackArray[++top] = value; } public long pop(){ return stackArray[top--]; } public long peek(){ return stackArray[top]; } public boolean isEmpty(){ return (top==-1); } public boolean isFull(){ return (top==maxSize-1); } } class stackApp { public static void main(String[] args) { StackX theStack = new StackX(10); theStack.push(20); theStack.push(40); theStack.push(60); theStack.push(80); while(!theStack.isEmpty()){ long value = theStack.pop(); System.out.print(value); System.out.print(&quot; &quot;); } System.out.println(&quot;&quot;); } } 2. 实现单词逆序功能class StackY private int maxSize; private char[] stackArray; private int top; public StackY(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } public boolean isFull(){ return (top==maxSize-1); } } class Reverser{ private String input; private String output; public Reverser(String in){ this.input =in; } public String doRev(){ int stackSize =input.length(); StackY theStack = new StackY(stackSize); for(int i=0;i&lt;input.length();i++){ char ch = input.charAt(i); theStack.push(ch); } output = &quot;&quot;; while(!theStack.isEmpty()){ char ch = theStack.pop(); output = output +ch; } return output; } } class ReverseApp{ public static void main(String[] args) throws IOException{ String input,output; while(true){ System.out.print(&quot;Enter a String:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; Reverser theReverser = new Reverser(input); output = theReverser.doRev(); System.out.println(&quot;Reverse:&quot;+output); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 3. 实现分隔符匹配 具体实现思想：程序从字符串不断读取字符，每次读取一个字符，若发现它是左分隔符，将它压栈，当从输入中读到一个右分割符时，弹出栈顶的的左分割符，并且查看它是否和右分隔符相匹配，如果不匹配，则程序报错；如果栈中没有左分隔符和右分隔符匹配，程序也报错；分隔符没有被匹配，表现为把所有的字符读入之后，栈中仍留有分隔符。 class StackZ{ private int maxSize; private char[] stackArray; private int top; public StackZ(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } } class BracketChecker{ private String input; public BracketChecker(String in){ this.input =in; } public void check(){ int stackSize = input.length(); StackZ theStack = new StackZ(stackSize); for(int j =0;j&lt;input.length();j++){ char ch =input.charAt(j); switch(ch) { case&apos;{&apos;: case&apos;[&apos;: case&apos;(&apos;: theStack.push(ch); break; case&apos;}&apos;: case&apos;]&apos;: case&apos;)&apos;: if(!theStack.isEmpty()){ char chx = theStack.pop(); if(chx ==&apos;{&apos; &amp;&amp; ch!=&apos;}&apos; || chx ==&apos;[&apos; &amp;&amp; ch!=&apos;]&apos; || chx ==&apos;(&apos; &amp;&amp; ch!=&apos;)&apos;) System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); }else System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); break; default: break; } } if(!theStack.isEmpty()){ System.out.println(&quot;Error :missing right delimiter&quot;); } } } class BracketsApp{ public static void main(String[] args) throws IOException{ String input; while(true){ System.out.print(&quot;Enter string containing delimiters:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; BracketChecker theChecker = new BracketChecker(input); theChecker.check(); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 总结：在编程过程中，好的编程习惯就是将方法细化，任何可能重复的方法将其封装到一个方法中，下次再用调用即可。","categories":[{"name":"JAVA数据结构","slug":"JAVA数据结构","permalink":"https://fengjiaxin.github.io/categories/JAVA数据结构/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://fengjiaxin.github.io/tags/Stack/"}]},{"title":"关于javaWeb学习过程中的一些个人感悟","slug":"关于javaWeb学习过程中的一些个人感悟","date":"2016-12-19T07:48:47.000Z","updated":"2017-02-02T12:38:36.306Z","comments":true,"path":"2016/12/19/关于javaWeb学习过程中的一些个人感悟/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/19/关于javaWeb学习过程中的一些个人感悟/","excerpt":"","text":"在本科阶段，毕设是利用SpringMVC +Hibernate+sql做一个教务信息发布平台，当时是机械兔的我哪里会啊，就是不断的找网上相似的教学视频，然后看源码进行修改，说句实话，当时就是盲目的该，有些错误只能google,自己一点也分析不出来，但是没办法，为了完成毕业设计，只好照猫画虎的改。 但是现在研究生阶段开发评标系统，网上也没有源码，我也毫无参考，对框架就更无从编写，在与前辈的交流过程中，发现自己对Servlet和Jsp了解太少，基础知识太弱，并且很多框架就是将Servlet进行封装，如果不明白底层的原理，将来运用框架也一定会有很多问题的。框架不断在变，但是基础原理并没有变，为了以后能更扎实的编码学习。现在开始记录我的学习Servlet和Jsp之旅，特此见证。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://fengjiaxin.github.io/categories/个人感悟/"}],"tags":[]}]}