{"meta":{"title":"fengjiaxin's blog","subtitle":"滴水穿石","description":"记录一点一滴","author":"冯佳欣","url":"https://fengjiaxin.github.io"},"pages":[{"title":"categories","date":"2017-01-05T10:16:57.000Z","updated":"2017-01-05T10:18:57.342Z","comments":true,"path":"categories/index.html","permalink":"https://fengjiaxin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-05T10:17:16.000Z","updated":"2017-01-05T10:18:34.325Z","comments":true,"path":"tags/index.html","permalink":"https://fengjiaxin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM内存回收策略","slug":"JVM内存回收策略","date":"2017-01-05T03:17:28.000Z","updated":"2017-01-05T07:34:38.813Z","comments":true,"path":"2017/01/05/JVM内存回收策略/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/05/JVM内存回收策略/","excerpt":"","text":"开发人员一般情况下不需要了解内存这个概念，因为内存的开辟与回收由JVM操作，但是在学习了操作系统之后，想要了解数据在Java是如何申请内存的，总结而言就是通常的显示内存申请有如下两种： 静态内存分配 动态内存分配 1.1 静态内存分配 在Java中静态内存分配是指在Java编译时就已经能确定需要的内存空间，当程序被加载时系统把内存一次性分配给它；这些内存不会再程序执行时发生变化，直到程序执行结束时内存才会被回收。在Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存的。 1.2 动态内存分配和回收 在Java中对象的内存空间是动态分配的，所谓动态分配就是在程序执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。 从前面的分析中可知内存的分配实在对象创建时发生的，而内存的回收是以对象不再引用为前提的，这种动态内存的分配和回收是和Java中的一些数据结构类型关联的。 如何确定这个对象什么时候不再被使用，如何回收，这正是JVM的垃圾收集器的工作。 1.3 如何检测垃圾垃圾收集器的工作： 正确检测出垃圾对象 释放垃圾对象占用的内存空间 如何检测出垃圾是GC上的关键；从前面的分析可以总结出：只要某个对象不再被其他的活动对象引用，这个对象就可以被回收了，活动对象指的是能够被一个跟对象集合到达的对象。 那么跟对象集合中有些什么呢？ 在方法中局部变量区的引用 在Java操作栈中的对象引用 在常量池的对象引用 在本地方法中次有的对象引用 类的Class对象 JVM在做垃圾回收时就会检查堆中的所有对象是否都会被这些跟对象直接或间接引用，能够被引用的对象就是活动对象，否则就被GC回收。 1.4 基于分代的垃圾收集算法算法的设计思路：把对象按照寿命长短分组，分为年轻代和老年代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么把这个对象划分到老年代。老年代的收集频度不像年轻代那么频繁，这样就减少了每次垃圾收集时所要扫描的对象的数量，提高了垃圾回收效率。","categories":[],"tags":[{"name":"JAVA总结","slug":"JAVA总结","permalink":"https://fengjiaxin.github.io/tags/JAVA总结/"}]},{"title":"Servlet技术笔记","slug":"Servlet技术笔记","date":"2017-01-03T07:49:21.000Z","updated":"2017-01-03T10:02:51.004Z","comments":true,"path":"2017/01/03/Servlet技术笔记/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/Servlet技术笔记/","excerpt":"","text":"1 ServletAPI：1.1 Servlet接口的主要方法及作用： init():在Servlet实例化之后，Servlet容器会调用init()方法，来初始化该对象。 service():容器调用Service()方法来处理客户端的请求。 destroy():容器检测到一个Servlet对象应该从服务器中被移除的时候，容器调用该对象的destroy()方法，以便Servlet对象可以释放使用的资源。 getServletConfig():返回调用init()方法时传递给Servlet对象的ServletConfig对象。 1.2 ServletRequest和ServletResponse： Servlet由Servlet容器管理，当客户端请求时，容器创建一个ServletRequest对象，封装请求数据，同事创建一个ServletResponse对象，封装响应数据，这两个对象被容器作为service()方法的参数传递给Servlet。 1.3 ServletConfig: Servlet容器使用ServletConfig对象在Servlet初始化期间向它传递配置信息，一个Servlet只能有一个ServletConfig对象。 1.4 简单实例 编写HelloWorldServlet例子，源代码见HelloServlet.java 1.5HttpServlet HttpServlet继承自GenericServlet，当容器收到一个针对HttpServlet对象的请求时，调用顺序如下： 调用public 的service()方法； 将参数类型转换为HttpServletRequest和HttpServletResponse，然后调用protected 的service()方法，将转换后的参数传进去； 在protected 的service()方法中，首先调用HttpServletRequest对象的getMethod()方法，确定是get，还是post方法。然后调用相应的doGet()或者doPost()等方法。 因此，在编写HttpServlet的派生类时，只许重写响应的doXXX()方法。 1.6 HttpServletRequest和HttpServletResponse get()方法：提交的数据提交到URL中，传递给后台服务器。 post()方法：提交的数据作为请求正文的内容发送到服务端，在URL看不到附加的请求数据。 2 简单实例：OutputInfoServlet：代码见OutputInfoServlet.java。 一个登陆实例：需要编写LoginServlet2.java，CenterServlet.java，success.html，web.xml。 3 Servlet异常 ServletException：可以被init()，service()，doXXX()等方法抛出。 UnavailableException：是ServletException的子类，用于向Servlet容器指示这个Servlet永久的或暂时的不可用。 4 Servlet生命周期 加载和实例化：Servlet容器负责加载和实例化Servlet，容器是通过反射机制来创建Servlet实例，调用不带参数的构造方法。 初始化：调用init()方法，在处理客户端请求时完成一些初始化工作。 请求处理：调用Service()方法，若执行期间有错误，可以抛出ServletException或UnavailableException异常，如果UnavailableException指示该实例永久不可用，则调用该实例的desttroy()方法。 服务终止：Servlet容器检测Servlet实例应该被移除时，调用destroy()方法，释放该实例使用的资源，等待Java的垃圾回收期回收。 5 Servlet上下文 运行在Java虚拟机中的每一个Web应用程序都有一个与之相关的Servlet上下文，Servlet API提供了ServletContext接口表示上下文，接口中定义了一些方法，Servlet可以使用这些方法与它的Servlet容器践行通信。 编写页面访问统计的实例：一个Web应用程序只有一个ServletContext对象，而且该对象可以被Web应用程序的所有Servlet所访问，因此使用ServletContext对象保存共享信息。 源码如下：CountServlet.java 注意：不同的Web应用程序具有不同的Servlet上下文，所以不同web应用程序不能利用ServletContext来共享属性；并且访问次数在重启Tomcat服务器后，重新计数，所以为了永久保存访问次数，可以存到文件或数据库中。 6 请求转发6.1 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建，用于封装一个路径标识的服务器资源。利用该对象，可以把请求转发给Servlet或JSP页面。 forward()：用于将请求从一个Servlet传递给服务器上的另外的Servlet或JSP页面或HTML文件；这个方法必须在响应被提交给客户端之前调用，调用后，原先在响应缓存中没有提交的内容将被自动清除。 include()：用于在响应中包含其他资源的内容。 上述两个方法区别：利用include()方法将请求转发给其他Servlet，被调用的Servlet对该请求做出的响应将并入原先的响应对象中，原先的Servlet还可以继续输出响应信息；而利用forward()方法将请求转发给其他的Servlet，将由被调用的Servlet负责对请求做出响应，而原先的Servlet的执行则终止。 6.2 得到RequestDispatcher对象 ServletContext接口的getRequestDispatcher()方法：参数必须以/开始，被解释为相对于当前上下文根的路径。 ServletRequest接口的getRequestDispatcher()方法：参数不但可以是相对于上下文的路径，也可以是相对于当前Servlet的路径；例如/myServlet、myServlet均合法。 6.3 请求转发的实例 CenterServlet.java，LoginServlet2.java。 6.4 sendRedirect()和forward()的区别HttpServletResponse接口的sendRedirect()和RequestDispatcher接口的forward()方法都可以利用另外的资源为客户端服务，但是工作原理有本质的区别。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1让Servlet2 为客户端服务 Servlet1调用SendRedirect()方法，将客户端的请求重定向到Servlet2 浏览器访问Servlet2 Servlet2 对客户端的请求做出响应 重定向这个过程对用户透明，浏览器会自动完成新的访问。 上图的交互过程如下： 浏览器访问Servlet1 Servlet1想让Servlet2对客户端进行响应，调用forward()方法，将请求转发给Servlet2进行处理 Servlet2对请求做出响应 调用forward()方法，对浏览器来说是透明的，浏览器只知道发出一个请求。 还有一个重要区别：sendRidirect()方法不但可以在位于同一主机上的不同web应用程序之间的重定向，而且可以将客户端重定向到其他服务器上的web应用程序资源","categories":[{"name":"Servlet/JSP 技术详解","slug":"Servlet-JSP-技术详解","permalink":"https://fengjiaxin.github.io/categories/Servlet-JSP-技术详解/"}],"tags":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://fengjiaxin.github.io/tags/个人笔记/"}]},{"title":"关于javaWeb学习过程中的一些个人感悟","slug":"关于javaWeb学习过程中的一些个人感悟","date":"2017-01-03T07:48:47.000Z","updated":"2017-01-03T10:05:16.641Z","comments":true,"path":"2017/01/03/关于javaWeb学习过程中的一些个人感悟/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/关于javaWeb学习过程中的一些个人感悟/","excerpt":"","text":"在本科阶段，毕设是利用SpringMVC +Hibernate+sql做一个教务信息发布平台，当时是机械兔的我哪里会啊，就是不断的找网上相似的教学视频，然后看源码进行修改，说句实话，当时就是盲目的该，有些错误只能google,自己一点也分析不出来，但是没办法，为了完成毕业设计，只好照猫画虎的改。 但是现在研究生阶段开发评标系统，网上也没有源码，我也毫无参考，对框架就更无从编写，在与前辈的交流过程中，发现自己对Servlet和Jsp了解太少，基础知识太弱，并且很多框架就是将Servlet进行封装，如果不明白底层的原理，将来运用框架也一定会有很多问题的。框架不断在变，但是基础原理并没有变，为了以后能更扎实的编码学习。现在开始记录我的学习Servlet和Jsp之旅，特此见证。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://fengjiaxin.github.io/categories/个人感悟/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://fengjiaxin.github.io/tags/JavaWeb/"}]},{"title":"数据库访问中遇到的问题","slug":"数据库访问中遇到的问题","date":"2017-01-03T07:45:27.000Z","updated":"2017-01-03T10:06:08.881Z","comments":true,"path":"2017/01/03/数据库访问中遇到的问题/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/数据库访问中遇到的问题/","excerpt":"","text":"今天在编码中出现了No suitable driver found for jdbc，又是找遍了网上的资料，基本上都说是三个问题： 连接URL格式出现了问题(Connection conn=DriverManager.getConnection(“jdbc:mysql://localhost:3306/XX”,”root”,”XXXX” 驱动字符串出错(com.mysql.jdbc.Driver) 三是Classpath中没有加入合适的mysql_jdbc驱动 经过我的仔细检查，出现了两次错误，总结如下： 在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。但是在 Eclipse web 项目中，当执行 Class.forName(“om.mysql.jdbc.Driver”);时 不会去查找驱动的。所以本实例中我们需要把mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。 查看资料说Java1.8之后就不用写Class.forName(“com.mysql.jdbc.Driver”) ; 我就没写，后来将这句代码写上，发现成功连接数据库，下次还是写上吧。 那我就把自己写的DBUtil.java代码贴上吧！ public class DBUtil { public static Connection getConnection() { String username = &quot;root&quot;; String password = &quot;123456&quot;; String url = &quot;jdbc:mysql://localhost:3306/itat_shop&quot;; Connection con = null; //1.加载驱动程序 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); con = DriverManager.getConnection(url, username, password); } catch(ClassNotFoundException |SQLException e) { e.printStackTrace(); } return con; } public static void close(Connection con) { try { if(con!=null) con.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(java.sql.PreparedStatement ps) { try { if(ps!=null) ps.close(); } catch (SQLException e) { e.printStackTrace(); } } public static void close(ResultSet rs) { try { if(rs!=null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }","categories":[{"name":"常见问题","slug":"常见问题","permalink":"https://fengjiaxin.github.io/categories/常见问题/"}],"tags":[{"name":"Java连接jdbc","slug":"Java连接jdbc","permalink":"https://fengjiaxin.github.io/tags/Java连接jdbc/"}]},{"title":"返回类型是接口的分析","slug":"返回类型是接口的分析","date":"2017-01-03T02:36:51.000Z","updated":"2017-01-03T10:05:39.977Z","comments":true,"path":"2017/01/03/返回类型是接口的分析/","link":"","permalink":"https://fengjiaxin.github.io/2017/01/03/返回类型是接口的分析/","excerpt":"","text":"今天在学习Servlet的过程中，书上关于DaoFactory的代码如下： public class DAOFactory { public static IUserDao getUserDao() { return new UserDao(); } } 在这里IUserDao是一个接口类型，但是返回的确实一个实现类，这明显不是一个类型啊，我就带着疑问上网搜索，总结如下： 接口虽然不能被实例化，但是接口的实现类都可以向上转型为接口； 面向接口编程是指我们在编写代码时对数据参数的定义尽量写成接口，待真正实现的时候再用实际类型代替； 代码的耦合性降低，在运行时我只需修改实现类类型，就可以实现不同的功能，而不必要修改接口的代码。 总结：接口的实现类可以向上转型为接口类，表面上返回的是接口类型，实际上返回的却是接口的实现类，如果需要取出接口的实现类，可以向下转型。","categories":[{"name":"常见问题","slug":"常见问题","permalink":"https://fengjiaxin.github.io/categories/常见问题/"}],"tags":[{"name":"Java接口","slug":"Java接口","permalink":"https://fengjiaxin.github.io/tags/Java接口/"}]},{"title":"StacK的一些例子","slug":"Stack","date":"2016-12-20T12:41:17.000Z","updated":"2017-01-05T03:29:00.920Z","comments":true,"path":"2016/12/20/Stack/","link":"","permalink":"https://fengjiaxin.github.io/2016/12/20/Stack/","excerpt":"","text":"栈就是后进先出的数据结构1. 栈的简单实现，采用数组实现class StackX{ private int maxSize; private long[] stackArray; private int top; public StackX(int s){ maxSize = s; stackArray = new long[maxSize]; top=-1; } public void push(long value){ stackArray[++top] = value; } public long pop(){ return stackArray[top--]; } public long peek(){ return stackArray[top]; } public boolean isEmpty(){ return (top==-1); } public boolean isFull(){ return (top==maxSize-1); } } class stackApp { public static void main(String[] args) { StackX theStack = new StackX(10); theStack.push(20); theStack.push(40); theStack.push(60); theStack.push(80); while(!theStack.isEmpty()){ long value = theStack.pop(); System.out.print(value); System.out.print(&quot; &quot;); } System.out.println(&quot;&quot;); } } 2. 实现单词逆序功能class StackY private int maxSize; private char[] stackArray; private int top; public StackY(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } public boolean isFull(){ return (top==maxSize-1); } } class Reverser{ private String input; private String output; public Reverser(String in){ this.input =in; } public String doRev(){ int stackSize =input.length(); StackY theStack = new StackY(stackSize); for(int i=0;i&lt;input.length();i++){ char ch = input.charAt(i); theStack.push(ch); } output = &quot;&quot;; while(!theStack.isEmpty()){ char ch = theStack.pop(); output = output +ch; } return output; } } class ReverseApp{ public static void main(String[] args) throws IOException{ String input,output; while(true){ System.out.print(&quot;Enter a String:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; Reverser theReverser = new Reverser(input); output = theReverser.doRev(); System.out.println(&quot;Reverse:&quot;+output); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 3. 实现分隔符匹配 具体实现思想：程序从字符串不断读取字符，每次读取一个字符，若发现它是左分隔符，将它压栈，当从输入中读到一个右分割符时，弹出栈顶的的左分割符，并且查看它是否和右分隔符相匹配，如果不匹配，则程序报错；如果栈中没有左分隔符和右分隔符匹配，程序也报错；分隔符没有被匹配，表现为把所有的字符读入之后，栈中仍留有分隔符。 class StackZ{ private int maxSize; private char[] stackArray; private int top; public StackZ(int s){ maxSize = s; stackArray = new char[maxSize]; top =-1; } public void push(char j){ stackArray[++top] =j; } public char pop(){ return stackArray[top--]; } public char peek(){ return stackArray[top]; } public boolean isEmpty(){ return top==-1; } } class BracketChecker{ private String input; public BracketChecker(String in){ this.input =in; } public void check(){ int stackSize = input.length(); StackZ theStack = new StackZ(stackSize); for(int j =0;j&lt;input.length();j++){ char ch =input.charAt(j); switch(ch) { case&apos;{&apos;: case&apos;[&apos;: case&apos;(&apos;: theStack.push(ch); break; case&apos;}&apos;: case&apos;]&apos;: case&apos;)&apos;: if(!theStack.isEmpty()){ char chx = theStack.pop(); if(chx ==&apos;{&apos; &amp;&amp; ch!=&apos;}&apos; || chx ==&apos;[&apos; &amp;&amp; ch!=&apos;]&apos; || chx ==&apos;(&apos; &amp;&amp; ch!=&apos;)&apos;) System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); }else System.out.println(&quot;Error: &quot;+ch+&quot; at &quot;+j); break; default: break; } } if(!theStack.isEmpty()){ System.out.println(&quot;Error :missing right delimiter&quot;); } } } class BracketsApp{ public static void main(String[] args) throws IOException{ String input; while(true){ System.out.print(&quot;Enter string containing delimiters:&quot;); System.out.flush(); input = getString(); if(input.equals(&quot;&quot;)) break; BracketChecker theChecker = new BracketChecker(input); theChecker.check(); } } public static String getString() throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; } } 总结：在编程过程中，好的编程习惯就是将方法细化，任何可能重复的方法将其封装到一个方法中，下次再用调用即可。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fengjiaxin.github.io/tags/数据结构/"}]}]}